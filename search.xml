<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/c-sin7/lhsin.cn/2023/06/10/%E7%AE%97%E6%B3%95/code_0610/"/>
      <url>/c-sin7/lhsin.cn/2023/06/10/%E7%AE%97%E6%B3%95/code_0610/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>code_0609</title>
      <link href="/c-sin7/lhsin.cn/2023/06/09/%E7%AE%97%E6%B3%95/code_0609/"/>
      <url>/c-sin7/lhsin.cn/2023/06/09/%E7%AE%97%E6%B3%95/code_0609/</url>
      
        <content type="html"><![CDATA[<h1 id="code-0609"><a href="#code-0609" class="headerlink" title="code_0609"></a>code_0609</h1><h2 id="修改图中的边权"><a href="#修改图中的边权" class="headerlink" title="修改图中的边权"></a>修改图中的边权</h2><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230609183408344.png" alt="image-20230609183408344" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230609183525281.png" alt="image-20230609183525281" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230609183639004.png" alt="image-20230609183639004" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230609183745050.png" alt="image-20230609183745050" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230609183814640.png" alt="image-20230609183814640" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230609184043421.png" alt="image-20230609184043421" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230609184117495.png" alt="image-20230609184117495" style="zoom:80%;" /><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230609184132359.png" alt="image-20230609184132259" style="zoom:80%;" /><h3 id="图结构的表达"><a href="#图结构的表达" class="headerlink" title="图结构的表达"></a>图结构的表达</h3><p>1）邻接表法</p><p>2）邻接矩阵法</p><p>3）除此之外还有其他众多的方式</p><h3 id="图的宽度优先-amp-深度优先遍历"><a href="#图的宽度优先-amp-深度优先遍历" class="headerlink" title="图的宽度优先&amp;深度优先遍历"></a>图的宽度优先&amp;深度优先遍历</h3><h4 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h4><p>1，利用队列实现</p><p>2，从源节点开始依次按照宽度进队列，然后弹出</p><p>3，每弹出一个点，把该节点所有没有进过队列的邻接点放入队列</p><p>4，直到队列变空</p><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>1，利用栈实现</p><p>2，从源节点开始把节点按照深度放入栈，然后弹出</p><p>3，每弹出一个点，把该节点下一个没有进过栈的邻接点放入栈</p><p>4，直到栈变空 </p><h3 id="图的拓扑排序算法"><a href="#图的拓扑排序算法" class="headerlink" title="图的拓扑排序算法"></a>图的拓扑排序算法</h3><p>1）在图中找到所有入度为0的点输出</p><p>2）把所有入度为0的点在图中删掉，继续找入度为0的点输出，周而复始</p><p>3）图的所有点都被删除后，依次输出的顺序就是拓扑排序</p><p>要求：有向图且其中没有环应用：事件安排、编译顺序</p><h3 id="最小生成树算法之Kruskal"><a href="#最小生成树算法之Kruskal" class="headerlink" title="最小生成树算法之Kruskal"></a>最小生成树算法之Kruskal</h3><p>1）总是从权值最小的边开始考虑，依次考察权值依次变大的边</p><p>2）当前的边要么进入最小生成树的集合，要么丢弃</p><p>3）如果当前的边进入最小生成树的集合中不会形成环，就要当前边</p><p>4）如果当前的边进入最小生成树的集合中会形成环，就不要当前边</p><p>5）考察完所有边之后，最小生成树的集合也得到了</p><h3 id="最小生成树算法之Prim"><a href="#最小生成树算法之Prim" class="headerlink" title="最小生成树算法之Prim"></a>最小生成树算法之Prim</h3><p>1）可以从任意节点出发来寻找最小生成树</p><p>2）某个点加入到被选取的点中后，解锁这个点出发的所有新的边</p><p>3）在所有解锁的边中选最小的边，然后看看这个边会不会形成环</p><p>4）如果会，不要当前边，继续考察剩下解锁的边中最小的边，重复3）</p><p>5）如果不会，要当前边，将该边的指向点加入到被选取的点中，重复2）</p><p>6）当所有点都被选取，最小生成树就得到了</p><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>1）Dijkstra算法必须指定一个源点</p><p>2）生成一个源点到各个点的最小距离表，一开始只有一条记录，即原点到自己最小距离为0，源点到其他所有点的最小距离都为正无穷大</p><p>3）从距离表中拿出没拿过记录里的最小记录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步</p><p>4）源点到所有的点记录如果都被拿过一遍，过程停止，最小距离表得到了</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> java </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code_0608</title>
      <link href="/c-sin7/lhsin.cn/2023/06/08/%E7%AE%97%E6%B3%95/code_0608/"/>
      <url>/c-sin7/lhsin.cn/2023/06/08/%E7%AE%97%E6%B3%95/code_0608/</url>
      
        <content type="html"><![CDATA[<h1 id="code-0608"><a href="#code-0608" class="headerlink" title="code_0608"></a>code_0608</h1><h4 id="一个int类型的数，提取出二进制中最右侧的1来"><a href="#一个int类型的数，提取出二进制中最右侧的1来" class="headerlink" title="一个int类型的数，提取出二进制中最右侧的1来"></a>一个int类型的数，提取出二进制中最右侧的1来</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> rightestOne <span class="token operator">=</span> eor <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>eor<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>-eor</code> 表示对 <code>eor</code> 取反后再加上 1，即得到 <code>eor</code> 的补码表示中最右侧的 1 所对应的值</p><h4 id="将i位置值设置为1"><a href="#将i位置值设置为1" class="headerlink" title="将i位置值设置为1"></a>将i位置值设置为1</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>ans <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这段代码的作用是将 <code>ans</code> 的第 <code>i</code> 位设置为 1，其它位不变。</p><p>具体地，<code>1 &lt;&lt; i</code> 的值是二进制数 <code>0000...0001</code> 向左移动 <code>i</code> 位后得到的结果，即在第 <code>i</code> 位上是 1，其它位都是 0，</p><p>例如当 <code>i=3</code> 时，<code>1 &lt;&lt; i</code> 的值为 <code>0000...1000</code>。然后使用或运算符 <code>|</code>，将 <code>ans</code> 的第 <code>i</code> 位设置为 1，而其它位则根据 <code>ans</code> 原先的值来保持不变。例如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 假设原来的 ans 值为 1011</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置第 1 位为 1，即在第二位上设置为 1</span>ans <span class="token operator">|=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">toBinaryString</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 打印输出 11011</span></code></pre><p>在上述代码中，原来的 <code>ans</code> 值为 1011（十进制的 11），我们希望将它的第 2 位（从右往左数，即二进制数的第 2 位）设置为 1，即得到二进制数 11011（十进制的 27）。使用上述代码即可实现该目的，输出结果为 <code>11011</code>，与预期相符。</p><h4 id="使用双端队列实现栈有两种方式："><a href="#使用双端队列实现栈有两种方式：" class="headerlink" title="使用双端队列实现栈有两种方式："></a>使用双端队列实现栈有两种方式：</h4><ol><li>在队列头部实现栈的 push 操作，即调用 <code>addFromHead</code> 方法插入元素，在队列头部调用 <code>popFromHead</code> 方法去除元素。</li><li>在队列尾部实现栈的 push 操作，即调用 <code>addFromBottom</code> 方法插入元素，在队列尾部调用 <code>popFromBottom</code> 方法去除元素。</li></ol><h4 id="“打表”"><a href="#“打表”" class="headerlink" title="“打表”"></a>“打表”</h4><p>可以理解为“预处理表格数据”，即将一些数据事先计算好并保存在数据结构中，以供程序运行时直接调用，而无需再进行计算。打表在某些场景下可以提高算法的效率和程序的运行速度，通常使用的数据结构有数组、哈希表、二维矩阵等。</p><p>例如，在计算斐波那契数列的时候，由于每个数的值都只跟前两个数的值有关，可以事先计算出数列中的所有数字并存在一个数组中，程序在需要时直接调用即可，这样可以避免重复计算，提高程序效率。这就是打表的一个常见应用。</p><p>另外，在算法竞赛中，打表也是一种常用的技巧，通过合理的打表可以大幅缩短算法的运行时间，从而在比赛中取得更好的成绩。</p><h4 id="NP-Complete问题"><a href="#NP-Complete问题" class="headerlink" title="NP-Complete问题"></a>NP-Complete问题</h4><p>是指一类非常重要的计算机科学问题，它表示了所有NP问题中最困难的一类问题之一，目前没有已知的有效算法可以在多项式时间内解决它们，即不存在可以在“多项式时间”内解决该问题的算法。</p><p>NP问题是指在多项式时间内可以验证一个解是否正确的问题，例如旅行商问题（TSP问题）和子集和问题（Subset Sum）就是NP问题，因为在多项式时间内可以验证某个解是否是正确的。而NP-Complete问题是一类特殊的NP问题，它具有这样的特性：如果有一种NP问题可以在多项式时间内转化成某个NP-Complete问题，那么这个NP问题就可以被认为是“和NP-Complete问题同样困难”的问题。</p><p>可视化数据网站：<a href="http://int-e.eu/~bf3/squares/view.html#13,11">http://int-e.eu/~bf3/squares/view.html#13,11</a></p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230608200322152.png" alt="image-20230608200322152" style="zoom:80%;" /><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230608200300117.png" alt="image-20230608200300117"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> java </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>code_0607</title>
      <link href="/c-sin7/lhsin.cn/2023/06/07/%E7%AE%97%E6%B3%95/code_0607/"/>
      <url>/c-sin7/lhsin.cn/2023/06/07/%E7%AE%97%E6%B3%95/code_0607/</url>
      
        <content type="html"><![CDATA[<h1 id="code-0607"><a href="#code-0607" class="headerlink" title="code_0607"></a>code_0607</h1><h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><p>方法一：int-&gt;String</p><p>需要额外的非常量空间来创建问题描述中所不允许的字符串。</p><p>方法二：将数字本身反转<br>问题：</p><p>反转后的数字可能大于 int.MAX，整数溢出。</p><p>为避免数字反转可能导致的溢出问题，考虑只反转数字的一半</p><p>例如，输入 1221，可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，二者相同，是回文。</p><p>算法：</p><p>首先，处理一些临界情况。</p><ol><li>所有负数都不可能是回文</li><li>除了 0 以外，所有个位是 0 的数字不可能是回文</li></ol><p>对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。</p><p>如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。</p><p>问题是，如何知道反转数字的位数已经达到原始数字位数的一半？</p><p>由于整个过程不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字<strong>小于或等于</strong>反转后的数字时，意味着已经处理了一半位数的数字了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    bool <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 特殊情况：</span>        <span class="token comment" spellcheck="true">// 如上所述，当 x &lt; 0 时，x 不是回文数。</span>        <span class="token comment" spellcheck="true">// 同样地，如果数字的最后一位是 0，为了使该数字为回文，</span>        <span class="token comment" spellcheck="true">// 则其第一位数字也应该是 0</span>        <span class="token comment" spellcheck="true">// 只有 0 满足这一属性</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>x <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> revertedNumber <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">></span> revertedNumber<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            revertedNumber <span class="token operator">=</span> revertedNumber <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span>        <span class="token comment" spellcheck="true">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，</span>        <span class="token comment" spellcheck="true">// 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。</span>        <span class="token keyword">return</span> x <span class="token operator">==</span> revertedNumber <span class="token operator">||</span> x <span class="token operator">==</span> revertedNumber <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span></code></pre><p>复杂度分析</p><p>时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)。<br>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</p><p>Java 中，可以使用 <code>Integer.toString(int i)</code> 方法将 <code>int</code> 类型的变量转换为 <code>String</code> 类型</p><p>Java中，可以使用 <code>String.valueOf(int i)</code> 方法将 <code>int</code> 类型的变量转换为 <code>String</code> 类型</p><p>Java 中，可以通过 <code>charAt(int index)</code> 方法获取字符串中某个位置上的字符</p><p> Java 中，<code>equal</code> 方法用于判断两个字符串的内容是否相同，而 <code>==</code> 运算符用于判断两个字符串对象的引用是否相同。</p><p> Java 中，可以使用 <code>StringBuilder</code> 和 <code>StringBuffer</code> 类的 <code>reverse()</code> 方法将字符串进行反转（即转置）。具体用法如下：</p><pre class=" language-java"><code class="language-java">String str <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>sb<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String reversedStr <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="罗马数字-gt-整数"><a href="#罗马数字-gt-整数" class="headerlink" title="罗马数字-&gt;整数"></a>罗马数字-&gt;整数</h2><p>方法一：从左往右，小数在大数左边，减法，否则加法</p><p>方法二：从右往左，记录当前遇到的最大的数字，遇到更大的就加，并且更新最大数，遇到小的就减</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(n)，其中 n 是字符串 s的长度。</li><li>空间复杂度：O(1)</li></ul><h2 id="老鼠和奶酪"><a href="#老鼠和奶酪" class="headerlink" title="老鼠和奶酪"></a>老鼠和奶酪</h2><p><a href="https://leetcode.cn/problems/mice-and-cheese/">https://leetcode.cn/problems/mice-and-cheese/</a></p><p>方法一：贪心 + 排序</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230608095852151.png" alt="image-20230608095852151" style="zoom:80%;" /><p>时间复杂度：O(nlog⁡n)，其中 n 是数组 reward1 和 reward2 的长度。创建数组 diffs 需要 O(n) 的时间，将数组 diffs 排序需要 O(nlog⁡n) 的时间，排序后计算 diffs 的 k 个最大值之和需要 O(k) 的时间，其中 k≤n，因此时间复杂度是 O(nlog⁡n)O(nlogn)。</p><p>空间复杂度：O(n)，其中 n 是数组 reward1 和 reward2 的长度。需要创建长度为 n 的数组 diffs 并排序，数组需要 O(n) 的空间，排序需要 O(log⁡n) 的递归调用栈空间，因此空间复杂度是 O(n)</p><p>：</p><p>数组排序Arrays.sort()需要时间为O(nlog⁡n) </p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> java </tag>
            
            <tag> 力扣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/c-sin7/lhsin.cn/2023/03/23/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
      <url>/c-sin7/lhsin.cn/2023/03/23/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/%E5%AE%9E%E9%AA%8C1_00.jpg" alt="实验一" style="zoom: 67%;" /><p>前言<br>当我们从Windows系统上传文件到Linux/Unix系统上时，有时候会由于文件格式导致可执行文件无法使用。</p><p>Windows系统的文件格式为DOS，而Linx/Unix系统的文件格式为UNIX。</p><p>而在CentOS系统上有个很方便的工具dos2unix/unix2dos可以解决这个问题。<br>Ubuntu上则可以使用tofrodos/fromdos</p><p>简介<br>dos2unix（tofrodos）指令可以将DOS格式文件转换为UNIX格式文件。</p><p>而unix2dos（fromdos）指令可以将UNIX格式文件转换为DOS格式文件。</p><p>安装<br>CentOS下可以直接使用yum安装：sudo yum -y install dos2unix（同时安装了dos2unix/unix2dos）<br>Ubuntu可以使用apt安装：sudo apt-get install tofrodos（同时安装了tofrodos/fromdos）<br>基本使用<br>dos2unix/unix2dos只需要直接执行：dos2unix file就可以将DOS格式的文件转成UNIX格式的文件<br>tofrodos/fromdos则可以执行：tofrodos file就可以将DOS格式的文件转成UNIX格式的文件</p><p><a href="https://blog.csdn.net/Nicolas12/article/details/80890811">CentOS7 复制、删除、移动、压缩、解压等常用命令整理_centos7命令行复制文件到移动硬盘_爱新觉罗1的博客-CSDN博客</a></p><pre class=" language-bash"><code class="language-bash">4. yum -y <span class="token function">install</span> lrzsz5. rz6. <span class="token function">mv</span> 实验一.txt /tmp/exam1.txt7. <span class="token function">sudo</span> yum -y <span class="token function">install</span> dos2unix8. dos2unix /tmp/exam1.txt9. <span class="token function">vi</span> /tmp/exam1.txt10. <span class="token function">tail</span> -5 /etc/passwd <span class="token operator">>></span> /tmp/exam1.txt11. <span class="token function">find</span> /usr -type f -name <span class="token string">"*.xml"</span>-path<span class="token string">"*mysql*"</span><span class="token operator">>></span>/tmp/exam1.txt12. <span class="token function">date</span> +<span class="token string">"%Y-%m-%d %H:%M:%S"</span><span class="token operator">>></span>/tmp/exam1.txt13. <span class="token function">tar</span> -zcvf log.tar.gz /var/log14. <span class="token function">ls</span> -alh log.tar.gz <span class="token operator">>></span> /tmp/exam1.txt15. <span class="token function">ls</span> -alh log.tar.gz <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&amp;#123;print <span class="token variable">$1</span>, <span class="token variable">$9</span>&amp;#125;'</span> <span class="token operator">>></span> /tmp/exam1.txt16. dos2unix /tmp/exam1.txt</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Nginx了解</title>
      <link href="/c-sin7/lhsin.cn/2023/03/02/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/Nginx%E4%BA%86%E8%A7%A3/"/>
      <url>/c-sin7/lhsin.cn/2023/03/02/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/Nginx%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx了解"><a href="#Nginx了解" class="headerlink" title="Nginx了解"></a>Nginx了解</h1><h2 id="1-什么是Nginx"><a href="#1-什么是Nginx" class="headerlink" title="1. 什么是Nginx?"></a>1. 什么是Nginx?</h2><p>​        <em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>web服务器，同时也提供了IMAP/POP3/SMTP服务。</p><p>​        Nginx的特点是占有内存少，<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91/11024806">并发</a>能力强，能够支持高达 50,000 个并发连接数的响应，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、<a href="https://baike.baidu.com/item/%E4%BA%AC%E4%B8%9C/210931">京东</a>、<a href="https://baike.baidu.com/item/%E6%96%B0%E6%B5%AA/125692">新浪</a>、<a href="https://baike.baidu.com/item/%E7%BD%91%E6%98%93/185754">网易</a>、<a href="https://baike.baidu.com/item/%E8%85%BE%E8%AE%AF/112204">腾讯</a>、<a href="https://baike.baidu.com/item/%E6%B7%98%E5%AE%9D/145661">淘宝</a>等。</p><p>​        Nginx支持正向代理、反向代理、负载均衡和动静分离。接下来一一介绍。</p><h2 id="1-1-正向代理"><a href="#1-1-正向代理" class="headerlink" title="1.1 正向代理"></a>1.1 正向代理</h2><p>​        在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的，此时大家可能都会用一个**代理(vpn)**进行访问，代理的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p><p>​        Nginx支持正向代理，”它代理的是客户端”，是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230302110036503.png" alt="image-20230302110036503"  /><p>客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。如图。</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/1614601035172-eea2a1ad-7f1b-4b53-8dd8-a6f8578d95b8.png" alt="img"></p><p><strong>正向代理的用途：</strong></p><p>（1）访问原来无法访问的资源，如Google</p><p>（2） 可以做缓存，加速访问资源</p><p>（3）对客户端访问授权，上网进行认证</p><p>（4）代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p><h2 id="1-2-反向代理"><a href="#1-2-反向代理" class="headerlink" title="1.2 反向代理"></a>1.2 反向代理</h2><p>​        关于反向代理的处理方式，举例淘宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了，此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题；淘宝网站中大部分功能也是直接使用Nginx进行反向代理实现的，并且通过封装Nginx和其他的组件之后起了个高大上的名字：Tengine，有兴趣的童鞋可以访问Tengine的官网查看具体的信息：<a href="http://tengine.taobao.org/%E3%80%82">http://tengine.taobao.org/。</a></p><blockquote><p>Tengine是一个由淘宝网发起的Web服务器开源项目，其核心成员来自于<a href="http://www.taobao.com/">淘宝</a> 、<a href="http://www.sogou.com/">搜狗</a> 等互联网企业。它在<a href="http://nginx.org/">Nginx</a> 的基础上，针对大访问量网站的需求，添加了很多高级功能和特性。Tengine的性能和稳定性已经在大型的网站如<a href="http://www.taobao.com/">淘宝网</a> ，<a href="http://www.tmall.com/">天猫商城</a> 等得到了很好的检验。它的最终目标是打造一个高效、稳定、安全、易用的Web平台。</p></blockquote><p>​        Nginx支持反向代理，”它代理的是服务端，代服务端接收请求”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。多个客户端给服务器发送的请求，<strong>Nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理</strong>了。请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx扮演的就是一个反向代理角色。</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/1614601035335-708a9d56-29ed-4ed8-9fa3-8604758f20e0.png" alt="img"></p><p><strong>反向代理的作用：</strong></p><p>（1）保证内网的安全，通常将反向代理作为公网访问地址，Web服务器是内网。</p><p>（2）负载均衡，通过反向代理服务器来优化网站的负载</p><h2 id="1-3-正向代理与反向代理的应用场景"><a href="#1-3-正向代理与反向代理的应用场景" class="headerlink" title="1.3 正向代理与反向代理的应用场景"></a>1.3 正向代理与反向代理的应用场景</h2><p>通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在在一个应用场景中，<strong>正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向代理服务器，反向代理了多台真实的业务处理服务器。</strong>具体的拓扑图如下：</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/1614601035276-64a46660-e97c-4186-aba2-c9d533a28a87.png" alt="img"></p><h2 id="1-4-正向代理与反向代理的区别"><a href="#1-4-正向代理与反向代理的区别" class="headerlink" title="1.4 正向代理与反向代理的区别"></a>1.4 正向代理与反向代理的区别</h2><p>通过一张图来说明正向代理和反向代理二者之间的区别：</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/1614601035284-7676d4e1-1895-4435-b3a2-3ab1c9195c7d.png" alt="img"></p><p><strong>图解：</strong></p><p>在正向代理中，Proxy和Client 同属于一个LAN（图中方框内），隐藏了客户端信息；</p><p>在反向代理中，Proxy和Server同属于一个LAN（图中方框内），隐藏了服务端信息；</p><p>实际上，Proxy在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代理方式称为反向代理了。</p><h2 id="1-5-负载均衡"><a href="#1-5-负载均衡" class="headerlink" title="1.5 负载均衡"></a>1.5 负载均衡</h2><p>当<strong>Nginx扮演了反向代理服务器的角色</strong>，它是以依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？</p><p>我们把客户端发送的、Nginx反向代理服务器接收到的请求数量，就是我们说的负载量。</p><p>请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种均衡规则。</p><p>将服务器接收到的请求按照规则分发的过程，称为负载均衡。</p><p>负载均衡在实际项目操作过程中，有<strong>硬件负载均衡和软件负载均衡</strong>两种，硬件负载均衡也称为硬负载，如F5负载均衡，相对造价昂贵成本较高，但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作；更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/1614601035715-45ff166b-1cd0-497c-92f2-43fc237fed5f.png" alt="img"></p><p><strong>Nginx支持的负载均衡调度算法方式如下：</strong></p><ol><li><strong>weight轮询</strong>（默认，常用，具有HA功效！）：接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。 这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</li><li><strong>ip_hash</strong>（常用）：每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，这也在一定程度上解决了集群部署环境下<strong>session共享</strong>的问题。</li><li><strong>fair</strong>：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。</li><li><strong>url_hash</strong>：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。</li></ol><h2 id="1-6-动静分离"><a href="#1-6-动静分离" class="headerlink" title="1.6 动静分离"></a>1.6 动静分离</h2><p>​        为了提高网站的响应速度，减轻程序服务器（Tomcat，Jboss等）的负载，<strong>对于静态资源比如图片，js，css等文件，我们可以在Nginx反向代理服务器中进行缓存，这样浏览器在请求一个静态资源时，Nginx代理服务器就可以直接处理，而不用将请求转发给后端服务器。</strong>用户请求的动态文件比如servlet，jsp则转发给Tomcat，Jboss服务器处理，这就是动静分离。</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/1614601035199-3b5a8b4d-d447-4de8-a9f8-5ad24efd64be.png" alt="img"></p><h2 id="1-7-几种常用web服务器对比"><a href="#1-7-几种常用web服务器对比" class="headerlink" title="1.7 几种常用web服务器对比"></a>1.7 几种常用web服务器对比</h2><table><thead><tr><th><strong>对比项\服务器</strong></th><th><strong>Apache</strong></th><th><strong>Nginx</strong></th><th><strong>Lighttpd</strong></th></tr></thead><tbody><tr><td>Proxy代理</td><td>非常好</td><td>非常好</td><td>一般</td></tr><tr><td>Rewriter</td><td>好</td><td>非常好</td><td>一般</td></tr><tr><td>Fcgi</td><td>不好</td><td>好</td><td>非常好</td></tr><tr><td>热部署</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>系统压力</td><td>很大</td><td>很小</td><td>比较小</td></tr><tr><td>稳定性</td><td>好</td><td>非常好</td><td>不好</td></tr><tr><td>安全性</td><td>好</td><td>一般</td><td>一般</td></tr><tr><td>静态文件处理</td><td>一般</td><td>非常好</td><td>好</td></tr><tr><td>反向代理</td><td>一般</td><td>非常好</td><td>一般</td></tr></tbody></table><h2 id="2-Linux安装Nginx"><a href="#2-Linux安装Nginx" class="headerlink" title="2. Linux安装Nginx"></a>2. Linux安装Nginx</h2><blockquote><p>关于Nginx的依赖说明：<a href="https://www.jianshu.com/p/14c81fbcb401">https://www.jianshu.com/p/14c81fbcb401</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/c-sin7/lhsin.cn/2023/02/24/CentOS%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/c-sin7/lhsin.cn/2023/02/24/CentOS%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>一、下载安装包</p><p>  cd /usr/local/software  (software可能没有，用<a href="https://so.csdn.net/so/search?q=mkdir&spm=1001.2101.3001.7020">mkdir</a>创建或者只到local目录下也行)</p><p>  <a href="https://so.csdn.net/so/search?q=wget&spm=1001.2101.3001.7020">wget</a> <a href="http://nginx.org/download/nginx-1.6.2.tar.gz">http://nginx.org/download/nginx-1.6.2.tar.gz</a>   (选择一个比较稳定的版本下载即可，或者手动下载后，用xshell传到该目录下也行)</p><p>二、解压安装</p><p>  tar -zxvf <a href="https://so.csdn.net/so/search?q=nginx&spm=1001.2101.3001.7020">nginx</a>-1.6.2.tar.gz -C /usr/local   (local这个目录类似于Windows的program目录，所以一些软件可以都安装在这里)</p><p>三、下载依赖的库文件</p><p>  1  yum install pcre</p><p>  2  yum install pcre-devel</p><p>  3  yum install zlib</p><p>  4 yum install zlib-devel</p><p>四、进行configure配置</p><p>  cd /usr/local/nginx-1.6.2  &amp;&amp; ./configure –prefix=/usr/local/nginx</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20180403165135209" alt="img"></p><p>五、编译安装（  cd 到解压好的nginx-1.6.2，这个目录下安装编译）</p><p>make &amp;&amp; make install</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20180403165259201" alt="img"></p><p>六、启动Nginx</p><p>  执行完5步骤后，cd 到/usr/local/nginx目录下。执行ls，可以看到四个目录</p><p> conf—-配置文件 html—-网页文件 logs—–日志文件 sbin——主要二进制程序</p><p> 启动命令：  /usr/local/nginx/sbin/nginx   (无参数) 启动   （-s  stop）关闭   （-s reload）重启</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20180403165435137" alt="img"></p><p>七、查看</p><p>查看是否成功   ps -ef | grep nginx (如果能看到两个相邻ID的进程，说明启动成功)</p><p>失败的可能    80端口被占用了。   netstat -ano | grep 80</p><p>如果成功的话，浏览器访问能看到欢迎页面：（http://服务器的IP:80）</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20180403165545204" alt="img"></p><p> nginx的结构目录（四个conf、html、logs、sbin，其他的都是运行后生成的或者自己添加的）</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20180920150536576" alt="img"></p><p> Nginx的作用都是靠着conf/nginx.conf 配置文件发挥的作用。只要能读懂它，会简单的编写，基本算是入门级别了。</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20180920151421670" alt="img"></p><p><a href="https://blog.csdn.net/jrgdspuwij/article/details/104060880#:~:text=%E6%A6%82%E8%A7%88">(95条消息) Centos 下 Nginx 安装、启动 、关闭、重启 教程_福尔摩千的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/lzl18918615216/article/details/80049471?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-80049471-blog-102780363.pc_relevant_vip_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-80049471-blog-102780363.pc_relevant_vip_default&utm_relevant_index=2">(95条消息) CentOS7 安装nginx 无法访问的问题_李振磊的博客-CSDN博客</a></p><h5 id="centos下解决-bash-nginx-command-not-found添加环境变量：ln-s-usr-local-nginx-sbin-nginx-usr-local-bin"><a href="#centos下解决-bash-nginx-command-not-found添加环境变量：ln-s-usr-local-nginx-sbin-nginx-usr-local-bin" class="headerlink" title="centos下解决-bash: nginx: command not found添加环境变量：ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/"></a>centos下解决-bash: nginx: command not found添加环境变量：ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/</h5>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/c-sin7/lhsin.cn/2023/02/14/git/"/>
      <url>/c-sin7/lhsin.cn/2023/02/14/git/</url>
      
        <content type="html"><![CDATA[<p>git语句：</p><pre class=" language-bash"><code class="language-bash">//操作分支语句：//初始化<span class="token function">git</span> init//添加<span class="token function">git</span> add <span class="token string">"所需提交的文件名（包括后缀）"</span>//提交<span class="token function">git</span> commit -m <span class="token string">"提交文件的说明信息"</span>//新建分支但不切换<span class="token function">git</span> branch <span class="token string">"branchName"</span>//新建分支并切换到新分支<span class="token function">git</span> checkout -b <span class="token string">"branchName"</span>//执行checkout命令切换到branchName分支<span class="token function">git</span> checkout <span class="token string">"branchName"</span>//合并分支<span class="token function">git</span> merge <span class="token string">"branchName"</span>//在branch命令指定-d选项执行，以删除分支<span class="token function">git</span> branch -d <span class="token string">"branchName"</span>//rebase合并<span class="token function">git</span> reset --hard HEAD~标签操作语句：//tag命令可添加标签<span class="token function">git</span> tag <span class="token string">"tagName"</span>//没有使用参数而执行tag，可以显示标签列表<span class="token function">git</span> tag//在log命令添加 --decorate选项执行，可以显示包含标签资料的历史记录<span class="token function">git</span> log --decorate</code></pre><h2 id="一、操作分支"><a href="#一、操作分支" class="headerlink" title="一、操作分支"></a>一、操作分支</h2><h3 id="1-事先预备"><a href="#1-事先预备" class="headerlink" title="1. 事先预备"></a>1. 事先预备</h3><p>新建文件夹当作git项目，此处命名gitStudy，右建点击Git Bash</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214204334201.png" alt="image-20230214204334201" style="zoom:80%;" /><p>在 gitStudy 文件夹中新建文本文件，此处命名test1，将其初始化并提交</p><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//初始化<span class="token function">git</span> init//添加test1.txt<span class="token function">git</span> add test1.txt//提交<span class="token function">git</span> commit -m <span class="token string">"first commit"</span></code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214204450771.png" alt="初始化并提交" style="zoom:80%;" /><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214205149648.png" alt="image-20230214205149648" style="zoom:80%;" /><h3 id="2-建立分支"><a href="#2-建立分支" class="headerlink" title="2. 建立分支"></a>2. 建立分支</h3><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//新建分支issue1<span class="token function">git</span> branch issue1//不指定参数直接执行branch命令可以显示分支列表，前面有*的就是现在的分支<span class="token function">git</span> branch</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214203349134.png" alt="image-20230214203349134" style="zoom:80%;" /><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214205444527.png" alt="image-20230214205444527" style="zoom:80%;" /><h3 id="3-切换分支"><a href="#3-切换分支" class="headerlink" title="3. 切换分支"></a>3. 切换分支</h3><p>在test1.txt添加新内容，此时test1.txt文件内容：</p><hr><p>git是好抓手</p><p>add 把变更录入到索引中</p><hr><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//切换为issue1分支<span class="token function">git</span> checkout issue1//在issue1的状态下提交，历史记录会被记录到issue1分支<span class="token function">git</span> add test1.txt//在test1.txt添加add命令的说明后再提交<span class="token function">git</span> commit -m <span class="token string">"添加add操作 second commit"</span></code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214215138352.png" alt="image-20230214215138352" style="zoom:80%;" /><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214210607455.png" alt="image-20230214210607455" style="zoom:80%;" /><h3 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4. 合并分支"></a>4. 合并分支</h3><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//切换为主分支<span class="token function">git</span> checkout master//合并issue1<span class="token function">git</span> merge issue1</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214215300561.png" alt="image-20230214215300561" style="zoom:80%;" /><p>此时test1.txt文件内容：</p><hr><p>git是好抓手</p><p>add 把变更录入到索引中</p><hr><p>说明：master分支指向的提交移动到和issue1同样的位置，此处是fast-forward（快进）合并。</p><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214211642501.png" alt="image-20230214211642501" style="zoom:80%;" /><h3 id="5-删除分支"><a href="#5-删除分支" class="headerlink" title="5. 删除分支"></a>5. 删除分支</h3><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//删除分支issue1<span class="token function">git</span> branch -d issue1</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214211917856.png" alt="image-20230214211917856" style="zoom:80%;" /><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214211928498.png" alt="image-20230214211928498" style="zoom:80%;" /><h3 id="6-并行操作"><a href="#6-并行操作" class="headerlink" title="6. 并行操作"></a>6. 并行操作</h3><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//创建issue2分支<span class="token function">git</span> branch issue2//创建issue3分支<span class="token function">git</span> branch issue3//切换到issue2分支<span class="token function">git</span> checkout issue2//查看分支<span class="token function">git</span> branch</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214212351447.png" alt="image-20230214212351447" style="zoom:80%;" /><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214212418748.png" alt="image-20230214212418748" style="zoom:80%;" /><p>在issue2分支的test1.txt添加新语句后提交</p><p>此时test1.txt文件内容：</p><hr><p>git是好抓手</p><p>add 把变更录入到索引中</p><p>commit 记录索引的状态</p><hr><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//添加test1.txt<span class="token function">git</span> add test1.txt//提交<span class="token function">git</span> commit -m <span class="token string">"添加commit操作 third commit"</span></code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214215656043.png" alt="image-20230214215656043" style="zoom:80%;" /><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214212721879.png" alt="image-20230214212721879" style="zoom:80%;" /><p>在issue3分支的test1.txt添加新语句后提交添加新语句</p><p>此时test1.txt文件内容：</p><hr><p>git是好抓手</p><p>add 把变更录入到索引中</p><p>pull 取得远端数据库的内容</p><hr><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//切换到issue3分支<span class="token function">git</span> checkout issue3//添加test1.txt<span class="token function">git</span> add test1.txt//提交<span class="token function">git</span> commit -m <span class="token string">"添加pull操作 fourth commit"</span></code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215121900025.png" alt="image-20230215121900025" style="zoom:80%;" /><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214213210899.png" alt="image-20230214213210899" style="zoom:80%;" /><p>这样，第三次操作和第四次操作就并行进行了。</p><h3 id="7-解决合并冲突"><a href="#7-解决合并冲突" class="headerlink" title="7. 解决合并冲突"></a>7. 解决合并冲突</h3><p>把issue2分支和issue3分支的修改合并到master</p><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//切换master分支<span class="token function">git</span> checkout master//与issue2分支合并<span class="token function">git</span> merge issue2</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214215929556.png" alt="image-20230214215929556" style="zoom:80%;" /><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214213436613.png" alt="image-20230214213436613" style="zoom:80%;" /><p>合并issue3分支</p><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//合并issue3<span class="token function">git</span> merge issue3</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214213702756.png" alt="image-20230214213702756" style="zoom:80%;" /><p>此时test1.txt文件内容：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214220028270.png" alt="image-20230214220028270" style="zoom:80%;" /><p>在发生冲突的地方，git生成了内容的差异。</p><p>将text1.txt修改如下：</p><hr><p>git是好抓手</p><p>add 把变更录入到索引中</p><p>commit 记录索引的状态</p><p>pull 取得远端数据库的内容</p><hr><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//重新添加<span class="token function">git</span> add test1.txt//重新提交<span class="token function">git</span> commit -m <span class="token string">"合并issue3分支 fifth commit"</span></code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214220448230.png" alt="image-20230214220448230" style="zoom:80%;" /><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214220531599.png" alt="image-20230214220531599" style="zoom:80%;" /><p>因为在这次合并中修改了冲突部分，所以会重新创建合并修改的提交记录。</p><p>这样，master的HEAD就移动到这里了。这种合并不是fast-forward合并，而是non fast-forward合并。</p><h3 id="8-用rebase合并"><a href="#8-用rebase合并" class="headerlink" title="8. 用rebase合并"></a>8. 用rebase合并</h3><p>合并issue3分支的时候，使用rebase可以使提交的历史记录显得更简洁</p><p>现在暂时取消刚才的合并</p><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//用rebase合并<span class="token function">git</span> reset --hard HEAD~</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214221128272.png" alt="image-20230214221128272" style="zoom:80%;" /><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214221143793.png" alt="image-20230214221143793" style="zoom:80%;" /><p>执行rebase</p><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//切换到issue3分支<span class="token function">git</span> checkout issue3//对master执行rebase<span class="token function">git</span> rebase master</code></pre><p>效果：</p><p>和merge时的操作相同，修改在test1.txt发生冲突的部分</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214221353826.png" alt="image-20230214221353826" style="zoom:80%;" /><p>此时test1.txt文件内容：</p><p>在发生冲突的地方，git生成了内容的差异</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214221605562.png" alt="image-20230214221605562" style="zoom:80%;" /><p>和merge时的操作相同，修改在text1.txt发生冲突的部分。</p><hr><p>git是好抓手</p><p>add 把变更录入到索引中</p><p>commit 记录索引的状态</p><p>pull 取得远端数据库的内容</p><hr><p>rebase的时候，修改冲突后的提交不是使用commit命令，而是执行rebase命令指定 –continue选项。</p><p>若要取消rebase，指定 –abort选项</p><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//添加test1.txt<span class="token function">git</span> add test1.txt//rebase，启动编辑区<span class="token function">git</span> rebase --continue</code></pre><p>编辑区：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215122205553.png" alt="image-20230215122205553" style="zoom:80%;" /><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215122240171.png" alt="image-20230215122240171" style="zoom: 80%;" /><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214221938388.png" alt="image-20230214221938388" style="zoom:80%;" /><p>这样，在master分支的issue3分支就可以fast-forward合并。</p><pre class=" language-bash"><code class="language-bash">//切换到master分支<span class="token function">git</span> checkout master//合并<span class="token function">git</span> merge issue3</code></pre><p>text1.txt的最终内容和merge是一样的</p><p>目前的历史记录：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214222248099.png" alt="image-20230214222248099" style="zoom:80%;" /><h2 id="二、远端数据库操作"><a href="#二、远端数据库操作" class="headerlink" title="二、远端数据库操作"></a>二、远端数据库操作</h2><h3 id="1-pull"><a href="#1-pull" class="headerlink" title="1. pull"></a>1. pull</h3><p>执行pull可以取得远程数据库的历史记录</p><p>首先确认更新的本地数据库分支没有任何的更改。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/capture_stepup3_1_1.png" alt="分支没有任何修改的情况" style="zoom:80%;" /><p>这时只执行fast-forward合并。图中的master是本地数据库的master分支，origin/master是远程数据库的origin的master分支。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/capture_stepup3_1_2.png" alt="fast-forward合并" style="zoom:80%;" /><p>如果本地数据库的master分支有新的历史记录，就需要合并双方的修改。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/capture_stepup3_1_3.png" alt="本地端数据库的master分支有新的历史记录" style="zoom:80%;" /><p>执行pull就可以进行合并。这时，如果没有冲突的修改，就会自动创建合并提交。如果发生冲突的话，要先解决冲突，再手动提交。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/capture_stepup3_1_4.png" alt="解决冲突" style="zoom:80%;" /><h3 id="2-fetch"><a href="#2-fetch" class="headerlink" title="2. fetch"></a>2. fetch</h3><p>执行pull，远程数据库的内容就会自动合并。</p><p>但是，有时只是想<strong>确认本地数据库的内容而不想合并</strong>。这种情况下，请使用fetch。</p><p>执行fetch就可以取得远程数据库的最新历史记录。取得的提交会导入到没有名字的分支，这个分支可以从名为FETCH_HEAD的退出。</p><p>例如，在本地数据库和远程数据库的origin，如果在从B进行提交的状态下执行fetch，就会形成如下图所示的历史记录。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/capture_stepup3_2_1.png" alt="在本地端数据库和远端数据库的origin，在从B进行提交的状态下执行fetch" style="zoom:80%;" /><p>在这个状态下，若要把远程数据库的内容合并到本地数据库，可以合并FETCH_HEAD，或者重新执行pull。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/capture_stepup3_2_2.png" alt="合并FETCH_HEAD" style="zoom:80%;" /><p>合并后，历史记录会和pull相同。实际上pull的内容是fetch + merge组成的。</p><h3 id="3-push"><a href="#3-push" class="headerlink" title="3. push"></a>3. push</h3><p>从本地数据库push到远程数据库时，要fast-forward合并push的分支。如果发生冲突，push会被拒绝的。</p><p>若要共享在本地数据库创建的分支，需要明确的push。</p><p>因此，没有执行push就不会给远程数据库带来影响，因而可以自由的创建自己的分支。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/capture_stepup3_3_1.png" alt="Push" style="zoom:80%;" /><p>基本上，远程数据库共享的提交是不能修改的。如果修改的话，跟远程数据库同步的其他数据库的历史记录会变得很奇怪的。</p><h2 id="三、标签"><a href="#三、标签" class="headerlink" title="三、标签"></a>三、标签</h2><h3 id="1-标签介绍"><a href="#1-标签介绍" class="headerlink" title="1. 标签介绍"></a>1. 标签介绍</h3><p>标签是为了更方便地参考提交而给它标上易懂的名称。</p><p>Git可以使用2种标签：轻标签和注解标签。</p><p>打上的标签是固定的，不能像分支那样可以移动位置。</p><ul><li>轻标签<ul><li>添加名称</li></ul></li><li>注解标签<ul><li>添加名称</li><li>添加注解</li><li>添加签名</li></ul></li></ul><p>一般情况下，发布标签是采用注解标签来添加注解或签名的。轻标签是为了在本地暂时使用或一次性使用。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/capture_stepup4_1_1.png" alt="注解标签，轻标签" style="zoom:80%;" /><p>可以指定标签名称以退出，或reset在「修改提交」的讲解，还可以简单的恢复过去特定的状态。</p><h3 id="2-添加轻标签"><a href="#2-添加轻标签" class="headerlink" title="2. 添加轻标签"></a>2. 添加轻标签</h3><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//新建轻标签masterTag1<span class="token function">git</span> tag masterTag1//显示当前分支的标签列表<span class="token function">git</span> tag//查看显示包含标签资料的历史记录<span class="token function">git</span> log --decorate</code></pre><p>效果：</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215122416609.png" alt="image-20230215122416609"></p><h3 id="3-添加注解标签"><a href="#3-添加注解标签" class="headerlink" title="3. 添加注解标签"></a>3. 添加注解标签</h3><p>git tag -a会启动编辑区：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214231023083.png" alt="image-20230214231023083" style="zoom:80%;" /><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//添加masterTag2注解标签，启动编辑区<span class="token function">git</span> tag -a masterTag2//添加标签，指定-m选项来添加注解<span class="token function">git</span> tag -am <span class="token string">"这是masterTag3的一个注解标签"</span> masterTag3//显示标签的列表和注解<span class="token function">git</span> tag -n</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214231340399.png" alt="image-20230214231340399" style="zoom:80%;" /><h3 id="4-删除标签"><a href="#4-删除标签" class="headerlink" title="4. 删除标签"></a>4. 删除标签</h3><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//删除标签<span class="token function">git</span> tag -d masterTag3</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230214231722256.png" alt="image-20230214231722256" style="zoom:80%;" /><h2 id="四、改写提交"><a href="#四、改写提交" class="headerlink" title="四、改写提交"></a>四、改写提交</h2><h3 id="1-修改最近的提交"><a href="#1-修改最近的提交" class="headerlink" title="1. 修改最近的提交"></a>1. 修改最近的提交</h3><p>此时test1.txt文件内容：</p><hr><p>git是好抓手</p><p>add 把变更录入到索引中</p><p>commit 记录索引的状态</p><p>pull 取得远端数据库的内容</p><p>amend 改写提交</p><hr><p>启用编辑：</p><p>编辑工具会显示最近一次提交的提交消息</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215010936094.png" alt="image-20230215010936094" style="zoom:80%;" /><p>把消息修改为「<strong>amend 改写提交</strong>」并进行保存</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215010804119.png" alt="image-20230215010804119" style="zoom:80%;" /><p>现在已经修改了提交的内容，然后用log命令确认历史记录和提交消息。</p><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//查看显示包含标签资料的历史记录<span class="token function">git</span> log//添加text1.txt文件<span class="token function">git</span> add test1.txt//改写提交，启动编辑区<span class="token function">git</span> commit --amend//查看显示包含标签资料的历史记录<span class="token function">git</span> log</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215124219116.png" alt="image-20230215124219116" style="zoom:150%;" /><h3 id="2-改写提交"><a href="#2-改写提交" class="headerlink" title="2. 改写提交"></a>2. <strong>改写提交</strong></h3><p>revert</p><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//用log命令确认历史记录<span class="token function">git</span> log</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215111548289.png" alt="image-20230215111548289" style="zoom:80%;" /><p>此时test1.txt文件内容：</p><hr><p>git是好抓手<br>add 把变更录入到索引中<br>commit 记录索引的状态<br>pull 取得远端数据库的内容<br>amend 改写提交</p><hr><p>具体操作：</p><pre class=" language-bash"><code class="language-bash">//用revert取消「添加pull操作 fourth commit」提交<span class="token function">git</span> revert HEAD</code></pre><p>启动编辑区：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215124527527.png" alt="image-20230215124527527" style="zoom:80%;" /><p>编辑之后：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215124847339.png" alt="image-20230215124847339" style="zoom:80%;" /><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215124915906.png" alt="image-20230215124915906" style="zoom:80%;" /><p>此时test1.txt文件内容：</p><hr><p>git是好抓手<br>add 把变更录入到索引中<br>commit 记录索引的状态<br>amend 改写提交</p><hr><h2 id="Git-提示Your-branch-is-up-to-date-with-‘origin-master’"><a href="#Git-提示Your-branch-is-up-to-date-with-‘origin-master’" class="headerlink" title="Git 提示Your branch is up-to-date with ‘origin/master’"></a>Git 提示Your branch is up-to-date with ‘origin/master’</h2><p>今天提交代码到Github的时候，提示<code>Your branch is up-to-date with &#39;origin/master&#39;</code>，如下图所示：</p><pre class=" language-bash"><code class="language-bash">Your branch is up to <span class="token function">date</span> with <span class="token string">'origin/master'</span><span class="token keyword">.</span>Changes not staged <span class="token keyword">for</span> commit:<span class="token punctuation">..</span>.</code></pre><p>发现是<strong>版本分支</strong>的问题，按照如下步骤操作即可解决</p><ol><li>新建分支</li><li>检查分支是否创建成功</li><li>切换到新分支</li><li>将改动提交到新分支</li><li>检查是否提交成功</li><li>切回主分支</li><li>将新分支提交的改动合并到主分支</li><li>push代码到远端仓库</li><li>删除新分支</li></ol><p>具体操作：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> branch newB<span class="token function">git</span> branch<span class="token function">git</span> checkout newB<span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit -m <span class="token string">"the new files"</span><span class="token function">git</span> status<span class="token function">git</span> checkout master<span class="token function">git</span> merge newB<span class="token function">git</span> push -u origin master<span class="token function">git</span> branch -d newB</code></pre><p>效果：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230215155626878.png" alt="image-20230215155626878" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git使用</title>
      <link href="/c-sin7/lhsin.cn/2023/02/14/git%E4%BD%BF%E7%94%A8/"/>
      <url>/c-sin7/lhsin.cn/2023/02/14/git%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Git基本概念"><a href="#1-Git基本概念" class="headerlink" title="1. Git基本概念"></a>1. Git基本概念</h2><ul><li><code>repository</code></li><li><code>config</code></li><li><code>init</code></li><li><code>clone</code></li><li><code>fetch</code></li><li><code>pull</code></li><li><code>commit</code></li><li><code>push</code></li><li><code>branch</code></li><li><code>head</code></li><li><code>tag</code></li><li><code>merge</code></li><li><code>conflict</code></li><li><code>diff</code></li><li><code>log</code></li><li><code>show</code></li><li><code>status</code></li></ul><h2 id="2-Git工作空间和文件状态"><a href="#2-Git工作空间和文件状态" class="headerlink" title="2. Git工作空间和文件状态"></a>2. Git工作空间和文件状态</h2><h3 id="1-工作空间"><a href="#1-工作空间" class="headerlink" title="(1).工作空间"></a>(1).工作空间</h3><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/10415985_139279770639pM.jpg" alt="Git工作空间"></p><p><strong>Git工作空间</strong></p><p>左侧为工作区，右侧为版本库。</p><ul><li>工作区（<code>Working Directory</code>） 就是在电脑里能看到的目录，比如learngit文件夹就是一个工作区。</li><li>版本库（<code>Repository</code>）工作区有一个隐藏目录<code>.git</code>，是Git的版本库。</li></ul><p>在版本库中标记为<code>index</code>的区域为暂存区，标记为<code>master</code>的是Git为我们自动创建的第一个分支，代表的是目录树。此时<code>HEAD</code>实际是指向<code>master</code>分支的一个“游标”，所以图示的命令中出现HEAD的地方可以用<code>master</code>来替换。图中的objects标识的区域为git的对象库，实际位于<code>.git/objects</code>目录下。</p><ul><li>当对工作区修改（或新增）的文件执行<code>git add</code>命令时，暂存区的目录树会被更新，同时工作区修改（或新增）的文件内容会被写入到对象库中的一个新的对象中，而该对象的id被记录在暂存区的文件索引中。</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树会写到版本库（对象库）中，master分支会做相应的更新，即master最新指向的目录树就是提交时原暂存区的目录树。</li><li>当执行<code>git reset HEAD</code>命令时，暂存区的目录树会被重写，会被master分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行<code>git rm --cached</code>命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行<code>git checkout .</code>或<code>git checkout --</code> 命令时，会用暂存区全部的文件或指定的文件替换工作区的文件。这个操作很危险，会清楚工作区中未添加到暂存区的改动。</li><li>当执行<code>git checkout HEAD .</code>或<code>git checkout HEAD</code>命令时，会用HEAD指向的master分支中的全部或部分文件替换暂存区和工作区中的文件。这个命令也是极度危险的。因为不但会清楚工作区中未提交的改动，也会清楚暂存区中未提交的改动。</li></ul><h3 id="2-文件状态"><a href="#2-文件状态" class="headerlink" title="(2).文件状态"></a>(2).文件状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p><p><strong>已提交(<code>committed</code>)<strong>、</strong>已修改(<code>modified</code>)<strong>、</strong>已暂存(<code>staged</code>)</strong></p><h2 id="3-Git配置系统级、全局、当前仓库用户名、邮箱的命令"><a href="#3-Git配置系统级、全局、当前仓库用户名、邮箱的命令" class="headerlink" title="3. Git配置系统级、全局、当前仓库用户名、邮箱的命令"></a>3. Git配置系统级、全局、当前仓库用户名、邮箱的命令</h2><p>系统级、全局、当前仓库选项分别是:仓库-system、-global、-local(或默认不填)</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --global user.name <span class="token string">"Jerry Mouse"</span><span class="token function">git</span> config --global user.email <span class="token string">"jerry@yiibai.com"</span></code></pre><p>列出Git设置</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> config --list<span class="token function">git</span> config -l</code></pre><h2 id="4-Git-fetch和pull的区别"><a href="#4-Git-fetch和pull的区别" class="headerlink" title="4. Git fetch和pull的区别"></a>4. Git fetch和pull的区别</h2><ul><li><code>git fetch</code>：相当于是从远程获取最新版本到本地，不会自动merge.</li><li><code>git pull</code>：相当于是从远程获取最新版本并merge到本地.</li></ul><h3 id="1-git-fetch示例："><a href="#1-git-fetch示例：" class="headerlink" title="(1). git fetch示例："></a>(1). git fetch示例：</h3><pre class=" language-bash"><code class="language-bash">Git fetch origin master<span class="token function">git</span> log -p master<span class="token punctuation">..</span>origin/master<span class="token function">git</span> merge origin/master</code></pre><p>以上命令的含义：</p><ul><li>首先从远程的<code>origin</code>的<code>master</code>主分支下载最新的版本到<code>origin/master</code>分支上</li><li>然后比较本地的<code>master</code>分支和<code>origin/master</code>分支的差别</li><li>最后进行合并</li><li>上述过程其实可以用以下更清晰的方式来进行：</li></ul><h3 id="2-git-pull示例："><a href="#2-git-pull示例：" class="headerlink" title="(2). git pull示例："></a>(2). git pull示例：</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin master</code></pre><p>上述命令其实相当于<code>git fetch</code>和<code>git merge</code>。在实际使用中，<code>git fetch</code>更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。</p><h2 id="5-Git-reset和revert的却别"><a href="#5-Git-reset和revert的却别" class="headerlink" title="5. Git reset和revert的却别"></a>5. Git reset和revert的却别</h2><ul><li><code>git revert</code>是用一次新的commit来回滚之前的commit，<code>git reset</code>是直接删除指定的commit。</li><li>在回滚这一操作上看，效果差不多。但是在日后继续merge以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，导致这部分改变不会再次出现，但是<code>git reset</code>是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入。</li><li><code>git reset</code>是把HEAD向后移动了一下，而<code>git revert</code>是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</li><li>git revert与git reset最大的不同是，git revert 仅仅是撤销某次提交。</li></ul><p>另外，说一下<code>git revert</code>， <code>git reset –hard</code>和 <code>–soft</code>的区别</p><ul><li><code>git reset –mixed id</code>: 是将git的HEAD变了（也就是提交记录变了），但文件并没有改变，（也就是working tree并没有改变）。</li><li><code>git reset –soft id</code>: 实际上，是<code>git reset –mixed id</code>后，又做了一次<code>git add</code>。</li><li><code>git reset –herd id</code>: 是将git的HEAD变了，文件也变了。</li></ul><h2 id="6-Git-merge和reabse的相同点和不同点"><a href="#6-Git-merge和reabse的相同点和不同点" class="headerlink" title="6. Git merge和reabse的相同点和不同点"></a>6. Git merge和reabse的相同点和不同点</h2><p><code>merge</code>是合并的意思，<code>rebase</code>是复位基底的意思，相同点都是用来合并分支的。</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/759200-20160806092734215-279978821.png" alt="merge和rebase"></p><p><strong>merge和rebase</strong></p><p>不同点:</p><ul><li><code>merge</code>操作会生成一个新的节点，之前的提交分开显示。而<code>rebase</code>操作不会生成新的节点，是将两个分支融合成一个线性的提交。</li><li>解决冲突时。merge操作遇到冲突的时候，当前merge不能继续进行下去。手动修改冲突内容后，add 修改，commit就可以了。而<code>rebase</code>操作的话，会中断rebase,同时会提示去解决冲突。解决冲突后,将修改add后执行<code>git rebase –continue</code>继续操作，或者<code>git rebase –skip</code>忽略冲突。</li><li><code>git pull</code>和<code>git pull --rebase</code>区别：<code>git pull</code>做了两个操作分别是”获取”和”合并”。所以加了rebase就是以rebase的方式进行合并分支，默认为merge。</li></ul><p><strong>总结</strong>：选择 merge 还是 rebase？</p><ul><li>merge 是一个合并操作，会将两个分支的修改合并在一起，默认操作的情况下会提交合并中修改的内容</li><li>merge 的提交历史忠实地记录了实际发生过什么，关注点在真实的提交历史上面</li><li>rebase 并没有进行合并操作，只是提取了当前分支的修改，将其复制在了目标分支的最新提交后面</li><li>rebase 的提交历史反映了项目过程中发生了什么，关注点在开发过程上面</li><li>merge 与 rebase 都是非常强大的分支整合命令，没有优劣之分，使用哪一个应由项目和团队的开发需求决定</li><li>merge 和 rebase 还有很多强大的选项，可以使用 git help 查看</li></ul><h2 id="7-Git-stash是什么？它的相关使用方式命令"><a href="#7-Git-stash是什么？它的相关使用方式命令" class="headerlink" title="7. Git stash是什么？它的相关使用方式命令"></a>7. Git stash是什么？它的相关使用方式命令</h2><ul><li>git stash: 备份当前的工作区的内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前的工作区内容保存到Git栈中。</li><li>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</li><li>git stash pop –index stash@{0}: 恢复编号为0的进度的工作区和暂存区。</li><li>git stash apply stash@{1} 以将你指定版本号为stash@{1}的工作取出来</li><li>git stash drop[] 删除某一个进度，默认删除最新进度</li><li>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</li><li>git stash clear: 清空Git栈。此时使用gitg等图形化工具会发现，原来stash的哪些节点都消失了</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 恢复工作进度</span><span class="token function">git</span> stash pop <span class="token punctuation">[</span>--index<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>stash<span class="token operator">></span><span class="token punctuation">]</span>--index 参数：不仅恢复工作区，还恢复暂存区<span class="token operator">&lt;</span>stash<span class="token operator">></span> 指定恢复某一个具体进度。如果没有这个参数，默认恢复最新进度<span class="token comment" spellcheck="true"># 这是git stash保存进度的完整命令形式</span><span class="token function">git</span> stash <span class="token punctuation">[</span>save message<span class="token punctuation">]</span> <span class="token punctuation">[</span>-k<span class="token operator">|</span>--no-keep-index<span class="token punctuation">]</span> <span class="token punctuation">[</span>--patch<span class="token punctuation">]</span>-k和--no-keep-index指定保存进度后，是否重置暂存区--patch 会显示工作区和HEAD的差异,通过编辑差异文件，排除不需要保存的内容。和git add -p命令类似使用save可以对进度添加备注<span class="token comment" spellcheck="true"># git stash save "这是保存的进度"</span></code></pre><h2 id="8-Git只从暂存区删除，从工作空间删除的命令分别是什么"><a href="#8-Git只从暂存区删除，从工作空间删除的命令分别是什么" class="headerlink" title="8. Git只从暂存区删除，从工作空间删除的命令分别是什么?"></a>8. Git只从暂存区删除，从工作空间删除的命令分别是什么?</h2><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> <span class="token function">rm</span> --cached<span class="token function">git</span> <span class="token function">rm</span><span class="token function">git</span> commit</code></pre><h2 id="9-Git标签的使用"><a href="#9-Git标签的使用" class="headerlink" title="9. Git标签的使用"></a>9. Git标签的使用</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出现有的标签</span><span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 打标签</span><span class="token function">git</span> tag -a v1.01 -m <span class="token string">"Relase version 1.01"</span><span class="token comment" spellcheck="true"># 查看相应标签的版本信息</span><span class="token function">git</span> show v1.4</code></pre><ul><li>-a 选项,创建一个含附注类型的标签</li><li>-m 选项,指定了对应的标签说明</li></ul><h2 id="9-Git分支的使用"><a href="#9-Git分支的使用" class="headerlink" title="9. Git分支的使用"></a>9. Git分支的使用</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看本地分支</span><span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 查看远程分支</span><span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 创建本地分支(注意新分支创建后不会自动切换为当前分支)</span><span class="token function">git</span> branch <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换分支</span><span class="token function">git</span> checkout <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 创建新分支并立即切换到新分支</span><span class="token function">git</span> checkout -b <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 强制删除一个分支</span><span class="token function">git</span> branch -D <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并分支(将名称为[name]的分支与当前分支合并)</span><span class="token function">git</span> merge <span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 查看各个分支最后提交信息</span><span class="token function">git</span> br -v<span class="token comment" spellcheck="true"># 查看已经被合并到当前分支的分支</span><span class="token function">git</span> br --merged<span class="token comment" spellcheck="true"># 查看尚未被合并到当前分支的分支</span><span class="token function">git</span> br --no-merged</code></pre><h2 id="10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"><a href="#10-介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。" class="headerlink" title="10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。"></a>10. 介绍Git冲突处理经验，以及merge和rebase中的ours和theirs的差别。</h2><p>merge和rebase对于ours和theirs的定义是完全相反的。在merge时，ours指代的是当前分支，theirs代表需要被合并的分支。而在rebase过程中，ours指向了修改参考分支，theirs却是当前分支。因为rebase 隐含了一个<code>git checkout upstream</code>的过程，将<code>HEAD</code>从local分支变成了upstream分支。git会在rebase结束后撤销这个改变，但它已经不可避免地影响了冲突的状态，使rebase中ours和theirs的定义与merge 截然相反。因此，在使用ours与theirs时请格外小心。</p><h2 id="11-Git远程操作相关"><a href="#11-Git远程操作相关" class="headerlink" title="11. Git远程操作相关"></a>11. Git远程操作相关</h2><h3 id="1-clone"><a href="#1-clone" class="headerlink" title="(1). clone"></a>(1). clone</h3><blockquote><p>git clone &lt;版本库的网址&gt;<br>git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 克隆jQuery的版本库</span> <span class="token function">git</span> clone https://github.com/jquery/jquery.git  <span class="token function">git</span> clone -o jQuery https://github.com/jquery/jquery.git</code></pre><h3 id="2-remote"><a href="#2-remote" class="headerlink" title="(2). remote"></a>(2). remote</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有远程主机</span><span class="token function">git</span> remote<span class="token comment" spellcheck="true"># 使用-v选项，可以参看远程主机的网址</span><span class="token function">git</span> remote -v <span class="token comment" spellcheck="true"># 可以查看该主机的详细信息</span><span class="token function">git</span> remote show <span class="token operator">&lt;</span>主机名<span class="token operator">></span> <span class="token comment" spellcheck="true"># 添加远程主机</span><span class="token function">git</span> remote add <span class="token operator">&lt;</span>主机名<span class="token operator">></span> <span class="token operator">&lt;</span>网址<span class="token operator">></span><span class="token comment" spellcheck="true"># 删除远程主机</span><span class="token function">git</span> remote <span class="token function">rm</span> <span class="token operator">&lt;</span>主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 修改远程主机名称</span><span class="token function">git</span> remote <span class="token function">rename</span> <span class="token operator">&lt;</span>原主机名<span class="token operator">></span> <span class="token operator">&lt;</span>新主机名<span class="token operator">></span></code></pre><h3 id="3-fetch"><a href="#3-fetch" class="headerlink" title="(3). fetch"></a>(3). fetch</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回所有分支(branch)的更新到本地</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回某的特定分支的更新</span><span class="token function">git</span> fetch <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>分支名<span class="token operator">></span><span class="token comment" spellcheck="true"># 取回origin主机的master分支的更新</span><span class="token function">git</span> fetch origin master<span class="token comment" spellcheck="true"># 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支</span><span class="token function">git</span> merge origin/master<span class="token function">git</span> rebase origin/master</code></pre><h3 id="4-pull"><a href="#4-pull" class="headerlink" title="(4). pull"></a>(4). pull</h3><blockquote><p>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 取回origin主机的next分支，与本地的master分支合并</span><span class="token function">git</span> pull origin next:master<span class="token comment" spellcheck="true"># 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</span><span class="token function">git</span> pull origin next<span class="token comment" spellcheck="true"># 上面的命令实质上等同于先做git fetch，再做git merge。</span><span class="token function">git</span> fetch origin<span class="token function">git</span> merge origin/next<span class="token comment" spellcheck="true"># 合并需要采用rebase模式</span><span class="token function">git</span> pull --rebase <span class="token operator">&lt;</span>远程主机名<span class="token operator">></span> <span class="token operator">&lt;</span>远程分支名<span class="token operator">></span>:<span class="token operator">&lt;</span>本地分支名<span class="token operator">></span></code></pre><h3 id="5-push"><a href="#5-push" class="headerlink" title="(5). push"></a>(5). push</h3><blockquote><p>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</p></blockquote><p><strong>注意</strong>:分支推送顺序的写法是”&lt;来源地&gt;:&lt;目的地&gt;”，所以git pull是”&lt;远程分支&gt;:&lt;本地分支&gt;”，而git push是”&lt;本地分支&gt;:&lt;远程分支&gt;”。</p><ul><li>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。</li><li>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</li></ul><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建</span><span class="token function">git</span> push origin master<span class="token comment" spellcheck="true"># 省略了本地分支，以下等同，删除origin主机的master分支</span><span class="token function">git</span> push origin :master<span class="token function">git</span> push origin --delete master<span class="token comment" spellcheck="true"># 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略</span><span class="token function">git</span> push origin<span class="token comment" spellcheck="true"># 如果当前分支只有一个追踪分支，那么主机名都可以省略。</span><span class="token function">git</span> push<span class="token comment" spellcheck="true"># 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push</span><span class="token function">git</span> push -u origin master<span class="token comment" spellcheck="true"># 不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机</span><span class="token function">git</span> push --all origin<span class="token comment" spellcheck="true"># 强制推送</span><span class="token function">git</span> push --force origin<span class="token comment" spellcheck="true"># git push不会推送标签(tag)，除非使用–tags选项</span><span class="token function">git</span> push origin --tags</code></pre><h2 id="12-Git-Flow使用简介"><a href="#12-Git-Flow使用简介" class="headerlink" title="12. Git Flow使用简介"></a>12. Git Flow使用简介</h2><p>就像代码需要代码规范一样，代码管理同样需要一个清晰的流程和规范。三种广泛使用的工作流程：</p><ul><li>Git flow</li><li>Github flow</li><li>Gitlab flow</li></ul><p>三种工作流程，有一个共同点：都采用”功能驱动式开发”（Feature-driven development，简称FDD）。它指的是，需求是开发的起点，先有需求再有功能分支（feature branch）或者补丁分支（hotfix branch）。完成开发后，该分支就合并到主分支，然后被删除。最早诞生、并得到广泛采用的一种工作流程，就是<a href="http://nvie.com/posts/a-successful-git-branching-model/">Git flow</a>。</p><p>它最主要的特点有两个。首先，项目存在两个长期分支，分别是：主分支master、开发分支develop。其次，项目存在三种短期分支，分别是：功能分支（feature branch）、补丁分支（hotfix branch）、预发分支（release branch），一旦完成开发，它们就会被合并进develop或master，然后被删除。</p><h3 id="1-Git-Flow流程图"><a href="#1-Git-Flow流程图" class="headerlink" title="(1). Git Flow流程图"></a>(1). Git Flow流程图</h3><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/imagegit-flow.png" alt="Git Flow流程图" style="zoom:67%;" /><p><strong>Git Flow流程图</strong></p><h3 id="2-Git-Flow常用的分支"><a href="#2-Git-Flow常用的分支" class="headerlink" title="(2). Git Flow常用的分支"></a>(2). Git Flow常用的分支</h3><ul><li><code>Production</code>分支。也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改。</li><li><code>Develop</code>分支。这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支。</li><li><code>Feature</code>分支。这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release。</li><li><code>Release</code>分支。当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支。</li><li><code>Hotfix</code>分支。当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release。</li></ul><h3 id="3-Git-Flow代码示例"><a href="#3-Git-Flow代码示例" class="headerlink" title="(3). Git Flow代码示例"></a>(3). Git Flow代码示例</h3><h4 id="a-创建develop分支"><a href="#a-创建develop分支" class="headerlink" title="a. 创建develop分支"></a>a. 创建develop分支</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> branch develop<span class="token function">git</span> push -u origin develop</code></pre><h4 id="b-开始新Feature开发"><a href="#b-开始新Feature开发" class="headerlink" title="b. 开始新Feature开发"></a>b. 开始新Feature开发</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b some-feature develop<span class="token comment" spellcheck="true"># Optionally, push branch to origin:</span><span class="token function">git</span> push -u origin some-feature<span class="token comment" spellcheck="true"># 做一些改动</span><span class="token function">git</span> status<span class="token function">git</span> add some-file<span class="token function">git</span> commit</code></pre><h4 id="c-完成Feature"><a href="#c-完成Feature" class="headerlink" title="c. 完成Feature"></a>c. 完成Feature</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> pull origin develop<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff some-feature<span class="token function">git</span> push origin develop<span class="token function">git</span> branch -d some-feature<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete some-feature</code></pre><h4 id="d-开始Relase"><a href="#d-开始Relase" class="headerlink" title="d. 开始Relase"></a>d. 开始Relase</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b release-0.1.0 develop<span class="token comment" spellcheck="true"># Optional: Bump version number, commit</span><span class="token comment" spellcheck="true"># Prepare release, commit</span></code></pre><h4 id="e-完成Release"><a href="#e-完成Release" class="headerlink" title="e. 完成Release"></a>e. 完成Release</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff release-0.1.0<span class="token function">git</span> push<span class="token function">git</span> branch -d release-0.1.0<span class="token comment" spellcheck="true"># If you pushed branch to origin:</span><span class="token function">git</span> push origin --delete release-0.1.0   <span class="token function">git</span> tag -a v0.1.0 master<span class="token function">git</span> push --tags</code></pre><h4 id="f-开始Hotfix"><a href="#f-开始Hotfix" class="headerlink" title="f. 开始Hotfix"></a>f. 开始Hotfix</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout -b hotfix-0.1.1 master</code></pre><h4 id="g-完成Hotfix"><a href="#g-完成Hotfix" class="headerlink" title="g. 完成Hotfix"></a>g. 完成Hotfix</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> checkout master<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> checkout develop<span class="token function">git</span> merge --no-ff hotfix-0.1.1<span class="token function">git</span> push<span class="token function">git</span> branch -d hotfix-0.1.1<span class="token function">git</span> tag -a v0.1.1 master<span class="token function">git</span> push --tags</code></pre>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程</title>
      <link href="/c-sin7/lhsin.cn/2023/02/12/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/c-sin7/lhsin.cn/2023/02/12/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a><strong>多线程</strong></h1><h3 id="1-synchronized的实现原理"><a href="#1-synchronized的实现原理" class="headerlink" title="1. synchronized的实现原理"></a><strong>1. synchronized的实现原理</strong></h3><p>​        在 Java 中，每个对象都隐式包含一个 monitor（监视器）对象，加锁的过程其实就是==<strong>竞争 monitor</strong>== 的过程</p><p>​        当线程进入字节码 monitorenter 指令之后，线程将持有 monitor 对象，执行 monitorexit 时释放 monitor 对象，当其他线程没有拿到 monitor 对象时，则需要阻塞等待获取该对象。</p><h3 id="2-ReentrantLock与Synchronized的区别"><a href="#2-ReentrantLock与Synchronized的区别" class="headerlink" title="2.ReentrantLock与Synchronized的区别"></a><strong>2.ReentrantLock与Synchronized的区别</strong></h3><p>ReentrantLock 有如下特点：</p><ul><li><h5 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h5><p>ReentrantLock 和 syncronized 关键字一样，都是可重入锁，不过两者实现原理稍有差别。</p><p>RetrantLock ==利用 AQS 的的 state 状态来判断资源是否已锁==</p><ul><li>同一线程重入加锁，state 的状态+1 ; </li><li>同一线程重入解锁，state 状态 -1 (解锁必须为当前独占线程，否则异常); </li><li>当 state 为 0 时解锁成功。</li></ul></li><li><h5 id="需要手动加锁、解锁"><a href="#需要手动加锁、解锁" class="headerlink" title="需要手动加锁、解锁"></a>需要手动加锁、解锁</h5><ul><li>synchronized 关键字是自动进行加锁、解锁的。</li><li>ReentrantLock ==需要 <strong>lock() 和 unlock() 方法</strong>配合 try/finally 语句块==来完成，来手动加锁、解锁。</li></ul></li><li><h5 id="支持设置锁的超时时间"><a href="#支持设置锁的超时时间" class="headerlink" title="支持设置锁的超时时间"></a>支持设置锁的超时时间</h5><ul><li>synchronized 关键字无法设置锁的超时时间，如果一个获得锁的线程内部发生死锁，那么其他线程就会一直进入阻塞状态。</li><li>ReentrantLock 提供==<strong>tryLock</strong>==方法，允许设置线程获取锁的超时时间，如果超时，则跳过，不进行任何操作，避免死锁的发生。</li></ul></li><li><h5 id="支持公平-非公平锁"><a href="#支持公平-非公平锁" class="headerlink" title="支持公平/非公平锁"></a>支持公平/非公平锁</h5><ul><li>synchronized 关键字是一种非公平锁，先抢到锁的线程先执行。</li><li>ReentrantLock 的构造方法中允许设置 true/false 来实现公平、非公平锁，如果设置为 true ，则线程获取锁要遵循**”先来后到”**的</li></ul></li></ul><p>规则，每次都会构造一个线程 Node ，然后到双向链表的”尾巴”后面排队，等待前面的 Node 释放锁资源。</p><ul><li><h5 id="可中断锁"><a href="#可中断锁" class="headerlink" title="可中断锁"></a>可中断锁</h5><ul><li>ReentrantLock 中的==<strong>lockInterruptibly()</strong>==方法使得线程可以在被阻塞时响应中断<ul><li>比如一个线程 t1通过 lockInterruptibly() 方法获取到一个可重入锁，并执行一个长时间的任务，另一个线程通过nterrupt() 方法就可以立刻打断 t1 线程的执行，来获取t1持有的那个可重入锁。</li></ul></li><li>通过ReentrantLock 的 lock() 方法或者 Synchronized 持有锁的线程是不会响应其他线程的 interrupt()方法的，直到该方法主动释放锁之后才会响应 interrupt() 方法。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小知识 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/c-sin7/lhsin.cn/2023/02/12/Pandoc%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/c-sin7/lhsin.cn/2023/02/12/Pandoc%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>书籍分享01</title>
      <link href="/c-sin7/lhsin.cn/2023/02/12/%E4%B9%A6%E7%B1%8D/%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB01/"/>
      <url>/c-sin7/lhsin.cn/2023/02/12/%E4%B9%A6%E7%B1%8D/%E4%B9%A6%E7%B1%8D%E5%88%86%E4%BA%AB01/</url>
      
        <content type="html"><![CDATA[<p><strong>一次性全部打包</strong>：</p><p><a href="https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661241464234353860.rar">https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661241464234353860.rar</a></p><p><strong>一、产业发展趋势：</strong> </p><p><a href="https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661160521866366793.rar">https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661160521866366793.rar</a></p><p><strong>二、常见通用技术：</strong> </p><p><a href="https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661307931361244051.rar">https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661307931361244051.rar</a></p><p><strong>三、华为云应用构建：</strong> </p><p><a href="https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661160989764444250.rar">https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661160989764444250.rar</a></p><p><strong>四、数据技术：</strong> </p><p><a href="https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661161199370696904.rar">https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661161199370696904.rar</a></p><p><strong>五、云原生技术：</strong> </p><p><a href="https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661161397803421981.rar">https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661161397803421981.rar</a></p><p><strong>六、智能前沿技术：</strong> </p><p><a href="https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661161498248688105.rar">https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661161498248688105.rar</a></p><p><strong>七、通讯技术：</strong> </p><p><a href="https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661161261944318646.rar">https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661161261944318646.rar</a></p><p><strong>八、其他：</strong> </p><p><a href="https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661161090139794115.rar">https://res-static.hc-cdn.cn/cloudbu-site/china/zh-cn/CloudBook/TOP50/1661161090139794115.rar</a></p>]]></content>
      
      
      <categories>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发书籍 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ASM</title>
      <link href="/c-sin7/lhsin.cn/2023/02/10/ASM/"/>
      <url>/c-sin7/lhsin.cn/2023/02/10/ASM/</url>
      
        <content type="html"><![CDATA[<h3 id="2-2-INT-21H的1号功能，输入一个字符串”Hello-world”-存放在内存，然后倒序输出"><a href="#2-2-INT-21H的1号功能，输入一个字符串”Hello-world”-存放在内存，然后倒序输出" class="headerlink" title="2.2 INT 21H的1号功能，输入一个字符串”Hello,world”,存放在内存，然后倒序输出"></a>2.2 INT 21H的1号功能，输入一个字符串”Hello,world”,存放在内存，然后倒序输出</h3><pre class=" language-ASM"><code class="language-ASM">;2.2 INT 21H的1号功能，输入一个字符串"Hello,world",存放在内存，然后倒序输出S1 SEGMENTS1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    ;输入 cx作计数器    SUB CX,CXL1:     MOV AH,1    INT 21H    CMP AL,0DH    JE  L2    XOR AH,AH    PUSH AX    INC CX    JMP L1        ;输出L2:     POP DX    MOV AH,2    INT 21H    LOOP L2    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="2-3-INT-21H的A号功能，输入一个字符串”Hello-world”-存放在内存，然后倒序输出"><a href="#2-3-INT-21H的A号功能，输入一个字符串”Hello-world”-存放在内存，然后倒序输出" class="headerlink" title="2.3 INT 21H的A号功能，输入一个字符串”Hello,world”,存放在内存，然后倒序输出"></a>2.3 INT 21H的A号功能，输入一个字符串”Hello,world”,存放在内存，然后倒序输出</h3><pre class=" language-ASM"><code class="language-ASM">;2.3 INT 21H的A号功能，输入一个字符串"Hello,world",存放在内存，然后倒序输出S1 SEGMENT    BUFF DB 250,?,250 DUP(?)    SHOW DB 0DH,0AH,'THE REVERSE STRING IS:$'S1 ENDSS2 SEGMENT STACK    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    ;输入    MOV AH,0AH    INT 21H        MOV SI,DX    INC SI    MOV AL,DS:[SI]    ;真实数据总个数    CBW     MOV CX,AX        ;计数器    ADD SI,AX        ;串尾 不包括ODH        ;输出    LEA DX,SHOW    MOV AH,09H    INT 21HL0:        MOV DL,DS:[SI]    MOV AH,2    INT 21H    DEC SI    LOOP L0EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="3-1-将-BX-中的无符号数以二进制的形式输出"><a href="#3-1-将-BX-中的无符号数以二进制的形式输出" class="headerlink" title="3.1 将 BX 中的无符号数以二进制的形式输出"></a>3.1 将 BX 中的无符号数以二进制的形式输出</h3><pre class=" language-ASM"><code class="language-ASM">;3.1将 BX 中的无符号数以二进制的形式输出S1 SEGMENT    A DW 6C3BH  S1 ENDSS2 SEGMENT    DB 30 DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV CX,10H    MOV BX,AL0:     ROL BX,1    MOV DL,30H    ADC DL,0    MOV AH,2    INT 21H    LOOP L0EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="3-4-将BX的无符号数以十进制数形式输出"><a href="#3-4-将BX的无符号数以十进制数形式输出" class="headerlink" title="3.4 将BX的无符号数以十进制数形式输出"></a>3.4 将BX的无符号数以十进制数形式输出</h3><pre class=" language-ASM"><code class="language-ASM">;3.4 将 BX 中的无符号数以十进制的形式输出S1 SEGMENT    A DW 2A3BH    CNT DW 0S1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV BX,A    MOV AX,BX    MOV CX,0AH        ;转化并入栈    ;DX余数 AX商L0:    XOR DX,DX    DIV CX    PUSH DX        ;余数进栈    INC CNT    CMP AX,0    JNE L0        ;输出    MOV CX,CNTL1:        POP DX    ADD DX,30H    MOV AH,2    INT 21H    LOOP L1EXIT:       MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="3-5-将BX的有符号数以十进制数形式输出"><a href="#3-5-将BX的有符号数以十进制数形式输出" class="headerlink" title="3.5 将BX的有符号数以十进制数形式输出"></a>3.5 将BX的有符号数以十进制数形式输出</h3><pre class=" language-ASM"><code class="language-ASM">;3.5 将BX的有符号数以十进制数形式输出S1 SEGMENT    A DW 8000HS1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV BX,A    MOV AX,BX    MOV DI,10    MOV CX,0        ;判断正负数    CMP AX,0    JGE L1        NEG AX    PUSH AX    MOV DL,'-'    MOV AH,2    INT 21H    POP AX    L0:    XOR DX,DX    IDIV DI    ;/10    PUSH DX    ;压余数    INC CX     ;记录除了几次    CMP AX,0   ;比较除完了没    JNE L0    L1:    POP DX    ADD DX,30H    MOV AH,2    INT 21H    LOOP L1EXIT:    MOV AH,4CH    INT 21H    MAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="4-2-输入两个字X-Y，计算Z-X-Y-并把Z的结果显示出来，X-Y的输入可以是任何进制"><a href="#4-2-输入两个字X-Y，计算Z-X-Y-并把Z的结果显示出来，X-Y的输入可以是任何进制" class="headerlink" title="4.2 输入两个字X,Y，计算Z=X+Y,并把Z的结果显示出来，X,Y的输入可以是任何进制"></a>4.2 输入两个字X,Y，计算Z=X+Y,并把Z的结果显示出来，X,Y的输入可以是任何进制</h3><pre class=" language-ASM"><code class="language-ASM">;4.2 输入两个字X,Y，计算Z=X+Y,并把Z的结果显示出来，X,Y的输入可以是任何进制S1 SEGMENT    X DW 0    Y DW 0    Z DW 0S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV CX,16    XOR BX,BX        ;输入并放置在bxL0:     MOV AH,1    INT 21H    CMP AL,0DH    JE  L1    CMP AL,30H    JB L0    CMP AL,31H    JA L0    SHR AL,1    RCL BX,1    LOOP L0L1:    MOV X,BX    ;吸收回车    MOV AH,1    INT 21H          ;输入并放置在bxL2:     MOV AH,1    INT 21H    CMP AL,0DH    JE  L3    CMP AL,30H    JB L2    CMP AL,31H    JA L2    SHR AL,1    RCL BX,1    LOOP L2L3:    MOV Y,BX            ;两数相加    MOV DX,X    MOV BX,Y    ADD BX,DX    MOV CX,16L4:    ROL BX,1    MOV DX,30H    ADC DX,0    MOV AH,2    INT 21H    LOOP L4    EXIT:    MOV AH,4CH    INT 21H    MAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="4-3-输入一个有符号的十进制数，并以十六进制输出"><a href="#4-3-输入一个有符号的十进制数，并以十六进制输出" class="headerlink" title="4.3 输入一个有符号的十进制数，并以十六进制输出"></a>4.3 输入一个有符号的十进制数，并以十六进制输出</h3><pre class=" language-ASM"><code class="language-ASM">;4.3 输入一个有符号的十进制数，并以十六进制输出S1 SEGMENT    NUM DW 8000    F    DW 0S1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    XOR BX,BX    CALL READIN    CMP F,0    JNE    L3L3:    NEG BX    CALL CHANGE    EXIT:        MOV AH,4CH    INT 21HMAIN ENDPREADIN PROC NEAR    ;输入 判断正负L0:    MOV AH,1    INT 21H    CMP AL,0DH    JE  EXIT1    CMP AL,'-'    JNE L1    INC F    L1:    SUB AL,30H    JL  L0    CMP AL,9D    JG    L0    ;->10    CBW    XCHG AX,BX    MOV CX,10D    MUL CX    XCHG BX,AX    ADD BX,AX    JMP L0    EXIT1:    RET    READIN ENDPCHANGE PROC NEAR    ;10->16    MOV CX,4L2:    PUSH CX    MOV CL,4    ROL BX,CL    MOV DL,BL    AND DL,0FH    ADD DL,30H    CMP DL,39H    JBE DISP    ADD DL,7DISP:    MOV AH,2    INT 21H    POP CX    LOOP L2        RETCHANGE ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-1-试编写一个汇编语言程序，要求对键盘输入的小写字母用大写字母显示出来"><a href="#5-1-试编写一个汇编语言程序，要求对键盘输入的小写字母用大写字母显示出来" class="headerlink" title="5.1 试编写一个汇编语言程序，要求对键盘输入的小写字母用大写字母显示出来"></a>5.1 试编写一个汇编语言程序，要求对键盘输入的小写字母用大写字母显示出来</h3><pre class=" language-ASM"><code class="language-ASM">;5.1对键盘输入的小写字母用大写字母显示出来S1 SEGMENTS1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP     ;输入小写L1:    MOV AH,1    INT 21H    CMP AL,'a'    JB L1    CMP AL,'z'    JA L1    MOV BL,AL        MOV DL,0DH    MOV AH,2    INT 21H    MOV DL,0AH    MOV AH,2    INT 21H        ;变大写输出    MOV DL,BL    SUB DL,20H    MOV AH,2    INT 21HEXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-2编写程序，从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符"><a href="#5-2编写程序，从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符" class="headerlink" title="5.2编写程序，从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符"></a>5.2编写程序，从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符</h3><pre class=" language-ASM"><code class="language-ASM">;5.2接收一个小写字母，然后找出前导字符和后续字符，按顺序输出S1 SEGMENTS1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP     ;输入L0:    MOV AH,1    INT 21H    CMP AL,'a'    JB L0    CMP AL,'z'    JA L0    MOV BL,AL    DEC BL        ;输出    MOV DL,0DH    MOV AH,2    INT 21H    MOV DL,0AH    MOV AH,2    INT 21H            MOV CX,2    MOV DL,BLL1:    MOV AH,2    INT 21H    ADD DL,2    LOOP L1EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-3将-AX-寄存器中的-16-位数分成-4-组，每组-4-位，然后把这四组数分别放在-AL、BL、CL-和-DL-中"><a href="#5-3将-AX-寄存器中的-16-位数分成-4-组，每组-4-位，然后把这四组数分别放在-AL、BL、CL-和-DL-中" class="headerlink" title="5.3将 AX 寄存器中的 16 位数分成 4 组，每组 4 位，然后把这四组数分别放在 AL、BL、CL 和 DL 中"></a>5.3将 AX 寄存器中的 16 位数分成 4 组，每组 4 位，然后把这四组数分别放在 AL、BL、CL 和 DL 中</h3><pre class=" language-ASM"><code class="language-ASM">;5.3将AX寄存器的16位数分为四组，每组四位，分别放在AL，BL，CL，DL中S1 SEGMENT    A1    DW    0    B1    DW    0    C1    DW    0    D1    DW    0S1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV AX,0ABCDH    MOV CL,4        ROL AX,CL    MOV BX,AX    AND BX,000FH    MOV SI,BX    ROL AX,CL    MOV BX,AX    AND BX,000FH    MOV DI,BX    ROL AX,CL    MOV BX,AX    AND BX,000FH    MOV BP,BX    ROL AX,CL    MOV BX,AX    AND BX,000FH    MOV DX,BX        MOV AX,SI    MOV BX,DI    MOV CX,BP        EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><pre class=" language-ASM"><code class="language-ASM">;5.3将AX寄存器的16位数分为四组，每组四位，分别放在AL，BL，CL，DL中S1 SEGMENTS1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV AX,0ABCDH    PUSH AX        MOV CL,4    ROL AX,CL    PUSH AX    AND AX,000FH    POP BX    ROL BX,CL    PUSH BX    AND BX,000FH    POP CX    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    PUSH CX    AND CX,00F0H    POP DX    AND DX,000FH    SHR CX,1    SHR CX,1    SHR CX,1    SHR CX,1    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-4比较string1和string2所含字符是否相同，相同’MATCH’-不同’NOTMATCH’"><a href="#5-4比较string1和string2所含字符是否相同，相同’MATCH’-不同’NOTMATCH’" class="headerlink" title="5.4比较string1和string2所含字符是否相同，相同’MATCH’,不同’NOTMATCH’"></a>5.4比较string1和string2所含字符是否相同，相同’MATCH’,不同’NOTMATCH’</h3><pre class=" language-ASM"><code class="language-ASM">;5.4比较string1和string2所含字符是否相同，相同'MATCH',不同'NOTMATCH'S1 SEGMENT    STRING1 DB 'ABCDEFGH$'    STRING2 DB 'QQQQQQQQ$'    MATCH    DB 'MATCH$'    NOTMATCH    DB 'NOTMATCH$'S1 ENDSS2 SEGMENT    DW 30H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S2    MOV SS,AX    MOV AX,S1    MOV DS,AX    MOV ES,AX        LEA SI,STRING1    LEA DI,STRING2    MOV CX,8        CLD        REPNE CMPSB    JNE NO    YES:    LEA DX,MATCH    MOV AH,09H    INT 21H    JMP EXITNO:    LEA DX,NOTMATCH    MOV AH,09H    INT 21H    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-6将一个含有20个数据的数组M分成两个数组，"><a href="#5-6将一个含有20个数据的数组M分成两个数组，" class="headerlink" title="5.6将一个含有20个数据的数组M分成两个数组，"></a>5.6将一个含有20个数据的数组M分成两个数组，</h3><p>正数组P和负数组N,并分别把两个数组的数据的个数显示出来</p><pre class=" language-ASM"><code class="language-ASM">;5.6 将一个含有20个数据的数组M分成两个数组，;正数组P和负数组N,并分别把两个数组的数据的个数显示出来S1 SEGMENT    COUNT DB 20    M DW 1,-2,3,-4,5,-6,7,-8,9,-10,11,-12,13,-14,15,-16,17,-18,19,20    CNTP DW 0    P DW 20 DUP(?)    CNTN DW 0    N DW 20 DUP(?)    POST DB 0DH,0AH,'Positive:$'    NEGE DB 0DH,0AH,'Negative:$'    ENT DB 0DH,0AH,'$'S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV SI,0    MOV DI,0    MOV BP,0    MOV CX,20L0:     MOV BX,M[SI]    ADD SI,2    CMP BX,0    JS    L2        ;正数L1:     MOV P[DI],BX    INC CNTP    ADD DI,2    JMP L3        ;负数L2:     MOV N[BP],BX    INC CNTN    ADD BP,2    JMP L3L3:     LOOP L0            ;AH余数 AL商    MOV AX,CNTP    MOV BL,10    DIV BL    MOV BX,AX    LEA DX,POST    MOV AH,9    INT 21H    ADD BL,30H    MOV DL,BL    MOV AH,2    INT 21H    ADD BH,30H    MOV DL,BH    MOV AH,2    INT 21H        LEA DX,ENT    MOV AH,9    INT 21H        MOV AX,CNTN    MOV BL,10    DIV BL    MOV BX,AX    LEA DX,NEGE    MOV AH,9    INT 21H        ADD BL,30H    MOV DL,BL    MOV AH,2    INT 21H    ADD BH,30H    MOV DL,BH    MOV AH,2    INT 21H    EXIT:        MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-7-求出首地址为-DATA-的-100D-字数组中的最小偶数，并存放在-AX-中"><a href="#5-7-求出首地址为-DATA-的-100D-字数组中的最小偶数，并存放在-AX-中" class="headerlink" title="5.7 求出首地址为 DATA 的 100D 字数组中的最小偶数，并存放在 AX 中"></a>5.7 求出首地址为 DATA 的 100D 字数组中的最小偶数，并存放在 AX 中</h3><p>两次循环 前指针找出偶数放在ax 后指针找出偶数放在dx，假设ax是最小偶数，ax和dx进行比较</p><pre class=" language-ASM"><code class="language-ASM">;5.7 求出首地址为 DATA 的 100D 字数组中的最小偶数，并存放在 AX 中S1 SEGMENT    DATA DW 100D DUP(?)S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    MOV BX,0    MOV CX,100    L0:    MOV AX,DATA[BX]    TEST AX,1    ADD BX,2    LOOPNZ L0    ;ZF=0和CF>0，继续循环    JNZ EXIT    ;循环结束且没有偶数    JCXZ EXIT    ;循环结束且最后一个是偶数，在BX    JZ    L1        ;循环未结束，找到偶数 进行比较L1:    MOV DX,DATA[BX]    TEST DX,1    ADD BX,2    JNZ    L0    CMP DX,AX        JGE    L2        ;继续向下找更小的偶数    MOV AX,DX    ;更新最小偶数值    LOOP L0L2:    LOOP L1EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-8-把-AX-中存放的-16-位二进制数-K-看作是-8-个二进制的“四分之一字节”"><a href="#5-8-把-AX-中存放的-16-位二进制数-K-看作是-8-个二进制的“四分之一字节”" class="headerlink" title="5.8 把 AX 中存放的 16 位二进制数 K 看作是 8 个二进制的“四分之一字节”"></a>5.8 把 AX 中存放的 16 位二进制数 K 看作是 8 个二进制的“四分之一字节”</h3><h3 id="数一下值为-3-即-11B-的四分之一的字节数，并将该数在终端上显示出来。"><a href="#数一下值为-3-即-11B-的四分之一的字节数，并将该数在终端上显示出来。" class="headerlink" title="数一下值为 3(即 11B)的四分之一的字节数，并将该数在终端上显示出来。"></a>数一下值为 3(即 11B)的四分之一的字节数，并将该数在终端上显示出来。</h3><pre class=" language-ASM"><code class="language-ASM">;5.8 把 AX 中存放的 16 位二进制数 K 看作是 8 个二进制的“四分之一字节”。;数一下值为 3(即 11B)的四分之一字节数，并将该数在终端上显示出来。S1 SEGMENT    K DW 6C3BHS1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV AX,K    MOV BP,8        ;循环次数    MOV CL,2        ;循环位数    XOR DX,DX        ;11B的个数    L0:    CMP BP,0    JE    EXIT    DEC BP        ROL AX,CL    MOV BX,AX    AND BX,3    CMP BX,3        JE    L1    JNE L0    L1:    INC DX    JMP L0    EXIT:    ADD DL,30H    MOV AH,2    INT 21H        MOV AH,4CH    INT 21H    MAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-9输入一个四位的-16-进制数，并在终端上显示等值的二进制数"><a href="#5-9输入一个四位的-16-进制数，并在终端上显示等值的二进制数" class="headerlink" title="5.9输入一个四位的 16 进制数，并在终端上显示等值的二进制数"></a>5.9输入一个四位的 16 进制数，并在终端上显示等值的二进制数</h3><pre class=" language-ASM"><code class="language-ASM">;5.9 输入一个四位的 16 进制数，并在终端上显示等值的二进制数。S1 SEGMENTS1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        ;输入    MOV BX,0    MOV CX,4L0:    PUSH CX    MOV CL,4    ROL BX,CL    MOV AH,1    INT 21H        ;NUMBER    CMP AL,30H    JB    L0    CMP AL,39H    JA    L1    SUB AL,30H    JMP L3    L1:    ;APHAL    CMP AL,41H    JB    L0    CMP AL,46H    JA    L2    SUB AL,37H    JMP L3    L2:    ;SMALL A    CMP AL,61H    JB    L0    CMP AL,66H    JA    L0    SUB AL,57H    JMP L3L3:    ADD BL,AL    POP CX    LOOP L0        MOV DL,0DH    MOV AH,2    INT 21H    MOV DL,0AH    MOV AH,2    INT 21H        MOV CX,16L4:    MOV DL,30H    ROL BX,1    ADC DL,0    MOV AH,2    INT 21H    LOOP L4        MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-10设有一段英文，其字符变量名为-ENG，并以-字符结束。试编写一程序，查对单词-SUN在该文中的出现次数，并以格式“SUN：xxxx”显示出次数。"><a href="#5-10设有一段英文，其字符变量名为-ENG，并以-字符结束。试编写一程序，查对单词-SUN在该文中的出现次数，并以格式“SUN：xxxx”显示出次数。" class="headerlink" title="5.10设有一段英文，其字符变量名为 ENG，并以$字符结束。试编写一程序，查对单词 SUN在该文中的出现次数，并以格式“SUN：xxxx”显示出次数。"></a>5.10设有一段英文，其字符变量名为 ENG，并以$字符结束。试编写一程序，查对单词 SUN在该文中的出现次数，并以格式“SUN：xxxx”显示出次数。</h3><pre class=" language-ASM"><code class="language-ASM">;5.10 一段英文 名ENG，以$结束,计算SUN在该文中出现的字数，格式SUNXXXX显示出次数S1 SEGMENT    ENG DB 'SUNSSUN;;SUN S,,,SUN$'    PUT DB 'SUN'    COUNT DB '0000',0DH,0AH,'$'    SUN DB 'SUN'S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV ES,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        XOR AX,AX    MOV DX,PUT-ENG-2    CALL CMPSTR    CALL CHANGE    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPCMPSTR PROC NEARL1:    MOV DI,BX    LEA SI,SUN        MOV CX,3    REPE CMPSB    JNZ L2    INC AX    ADD BX,2 ;匹配成功    SUB DX,2L2:    INC BX ;匹配下一个    DEC DX    CMP DX,0    JG L1CMPSTR ENDPCHANGE PROC NEARL3:    MOV CH,4     MOV CL,4    LEA BX,COUNT L4:     ROL AX,CL    MOV DX,AX    AND DL,0FH ;取一位16进制数    ADD DL,30H    CMP DL,39H    JLE L5    ADD DL,07HL5:     MOV [BX],DL    INC BX    DEC CH    JNZ L4         LEA DX,PUT     MOV AH,09H    INT 21HCHANGE ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-11从键盘输入一系列以-为结束符的字符串，对其中非数字字符计数，并显示计数结果。"><a href="#5-11从键盘输入一系列以-为结束符的字符串，对其中非数字字符计数，并显示计数结果。" class="headerlink" title="5.11从键盘输入一系列以$为结束符的字符串，对其中非数字字符计数，并显示计数结果。"></a>5.11从键盘输入一系列以$为结束符的字符串，对其中<u>非数字字符</u>计数，并显示计数结果。</h3><pre class=" language-ASM"><code class="language-ASM">;从键盘输入一系列以$为结束符的字符串，;对其中的非数字字符计数，并显示出计数结果。S1 SEGMENT    STRING DB 100 DUP(?)    CNT DW 0    DISPLAY DB 0DH,0AH,'THE COUNT:$'S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP       LEA BX,STRINGL1:    MOV AH,1        ;输入    INT 21H    MOV [BX],AL    INC BX    CMP AL,'$'        ;结束?    JE    L3                CMP AL,30H        ;0-9    JB    L2    CMP AL,39H    JA    L2    JMP L1    L2:    INC CNT    JMP L1    L3:    ;转成十进制    MOV AX,CNT    MOV BL,10    DIV BL    MOV BX,AX        LEA DX,DISPLAY    MOV AH,9    INT 21H        ;BX放到DX    MOV DL,30H    ADD DL,BL    MOV AH,2    INT 21H        MOV DL,30H    ADD DL,BH    MOV AH,2    INT 21H        MOV DL,0DH    MOV AH,2    INT 21H    MOV DL,0AH    MOV AH,2    INT 21H    EXIT:       MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-12-首地址为-MEM-的-100D-字数组，删除数组中所有为-0-的项，并将后续项向前压缩，最后将数组的剩余部分补上-0"><a href="#5-12-首地址为-MEM-的-100D-字数组，删除数组中所有为-0-的项，并将后续项向前压缩，最后将数组的剩余部分补上-0" class="headerlink" title="5.12 首地址为 MEM 的 100D 字数组，删除数组中所有为 0 的项，并将后续项向前压缩，最后将数组的剩余部分补上 0"></a>5.12 首地址为 MEM 的 100D 字数组，删除数组中所有为 0 的项，并将后续项向前压缩，最后将数组的剩余部分补上 0</h3><pre class=" language-ASM"><code class="language-ASM">;5.12 首地址为 MEM 的 100D 字数组，删除数组中所有为 0 的项，;并将后续项向前压缩，最后将数组的剩余部分补上 0。S1 SEGMENT    MEM DW 1,0,0,0,0,0,0,0,0,0        DW 2,1,0,3,4,5,6,7,8,9        DW 3,0,0,0,0,0,0,0,0,0        DW 4,1,2,0,4,5,6,7,8,9        DW 5,0,0,0,0,0,0,0,0,0        DW 6,1,2,3,4,5,0,7,8,9        DW 7,0,0,0,0,0,0,0,0,0        DW 8,1,2,3,4,5,6,7,0,9        DW 9,0,0,0,0,0,0,0,0,0        DW 0,1,2,3,4,5,6,7,8,0    CNT DW 0S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV CX,100    MOV SI,0L0:    CMP CX,0    JE    L3        MOV AX,MEM[SI]    MOV DI,SI    ADD SI,2    DEC CX    CMP AX,0    JNE    L0        ;把后面的前移L1:    INC CNT            ;记录数组中0的个数    MOV DX,MEM[SI]    MOV MEM[DI],DX    ;DX是中间量    JMP L0        ;剩余部分补零    MOV CX,CNTL3:    MOV SI,198    MOV MEM[SI],0    SUB SI,2    LOOP L3    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-13在-STRING-到-STRING-99-单元中存放着一个字符串"><a href="#5-13在-STRING-到-STRING-99-单元中存放着一个字符串" class="headerlink" title="5.13在 STRING 到 STRING+99 单元中存放着一个字符串"></a>5.13在 STRING 到 STRING+99 单元中存放着一个字符串</h3><p>测试该字符串中是否存在数字，如有则把 CL 的第 5 位置 1，否则将该位置 0。</p><pre class=" language-ASM"><code class="language-ASM">;在 STRING 到 STRING+99 单元中存放着一个字符串;测试该字符串中是否存在数字，如有则把 CL 的第 5 位置 1，否则将该位置 0。S1 SEGMENT    STRING DB 'HELLOABCDE1',90 DUP('A') S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP       MOV CX,100    LEA BX,STRING L0:    MOV AL,[BX]    INC BX    CMP AL,30H    JB    L1    CMP AL,39H    JNA    L2L1:    LOOP L0        ;存在数字L2:    MOV CL,00010000b    JMP EXIT  EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-14"><a href="#5-14" class="headerlink" title="5.14"></a>5.14</h3><pre class=" language-ASM"><code class="language-ASM">;5.14 在首地址为 TABLE 的数组中按递增次序存放着 100H 个 16 位补码数;把出现次数最多的数及其出现次数分别存放于 AX 和 CX 中S1 SEGMENT    TABEL    DW    6 DUP(-1),10 DUP(1),25 DUP(2),15 DUP(3),200 DUP(4)    TEMP    DW    ?S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME CS:S3,DS:S1,SS:S2MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        MOV CX,128    MOV SI,0    ;第二组的个数    MOV DI,0    ;第一组的个数    MOV DX,0    ;出现次数最大的值    LEA BX,TABEL    MOV DX,[BX]    ;一段一段记录个数，相等增加个数，大于则记录下一组，比较存储两组个数，再进行下一轮L1:    CMP CX,0    JE    EXIT    DEC CX        ;后边组的个数是DI   后指针    MOV AX,[BX]    ADD BX,2    INC DI    CMP    AX,[BX]    JNE L2        CMP CX,0    JNE    L1    L2:    CMP DI,SI    JB    L3        ;不用变动    ;后边组的次数更多，需要更新    MOV DX,AX    ;DX保存数值较大值    MOV SI,DI    ;SI保存次数较大值L3:    XOR    DI,DI    JMP L1            EXIT:    MOV CX,SI        MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-15-数据段中已定义了一个有-n-个字数据的数组-M-求出-M-中绝对值最大的数，放在数据段的-M-2n-单元中-最后一个单元-并将该数的偏移地址存放在-M-2-n-1-单元中"><a href="#5-15-数据段中已定义了一个有-n-个字数据的数组-M-求出-M-中绝对值最大的数，放在数据段的-M-2n-单元中-最后一个单元-并将该数的偏移地址存放在-M-2-n-1-单元中" class="headerlink" title="5.15 数据段中已定义了一个有 n 个字数据的数组 M,求出 M 中绝对值最大的数，放在数据段的 M+2n 单元中(最后一个单元),并将该数的偏移地址存放在 M+2(n+1)单元中"></a>5.15 数据段中已定义了一个有 n 个<u>字</u>数据的数组 M,求出 M 中绝对值最大的数，放在数据段的 M+2n 单元中(最后一个单元),并将该数的偏移地址存放在 M+2(n+1)单元中</h3><pre class=" language-ASM"><code class="language-ASM">;5.15 数据段中已定义了一个有 n 个字数据的数组 M，;求出 M 中绝对值最大的数，放在数据段的 M+2n 单元中;并将该数的偏移地址存放在 M+2(n+1)单元中S1 SEGMENT    M DW 10 DUP(5),10 DUP(2),5 DUP(-10)    CNT    DW    ($-M)/2    MAX    DW    ?    ADDRESS DW ?S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP        ;第一次    MOV SI,0    MOV AX,M[SI]    ADD SI,2    CMP AX,0    JGE    L0    NEG AXL0:        MOV MAX,AX    MOV BX,SI        ;N-1次循环比较    MOV CX,CNT    DEC CX L1:    CMP CX,0    JE    L3    MOV AX,M[SI]    ADD SI,2    DEC CX    CMP AX,0    JGE    L2    NEG AX    L2:    CMP MAX,AX    JAE L1    ;出现绝对值更大的数，需更新    MOV MAX,AX    MOV BX,SI    JMP L1        ;存放数据L3:    ADD SI,2    MOV DX,M[BX]    MOV M[SI],DX    ADD SI,2    MOV M[SI],BX    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-16在首地址为-DATA-的字数组中存放着-100H-个-16-位补码数"><a href="#5-16在首地址为-DATA-的字数组中存放着-100H-个-16-位补码数" class="headerlink" title="5.16在首地址为 DATA 的字数组中存放着 100H 个 16 位补码数"></a>5.16在首地址为 DATA 的字数组中存放着 100H 个 16 位补码数</h3><p>求出它们的平均值放在 AX 寄存器中,并求出数组中有多少个数小于此平均值，将结果放在 BX 寄存 器中。 </p><pre class=" language-ASM"><code class="language-ASM">;5.16 在首地址为 DATA 的字数组中存放着 100H 个 16 位补码数;求出它们的平均值放在 AX 寄存器中；;并求出数组中有多少个数小于此平均值，将结果放在 BX 寄存 器中。 S1 SEGMENT    DATA DW    3 DUP(-1),4 DUP(1),25 DUP(2),15 DUP(3),200 DUP(4)    AVER DW ?    CNT    DW    0S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    MOV CX,128    MOV AX,0    MOV SI,0L0:    MOV DX,DATA[SI]    ADD SI,2    ADD AX,DX    ;AX作SUM    LOOP L0        MOV BP,100H    DIV BP    MOV AH,0    MOV AVER,AX    ;遍历比较    MOV SI,0    MOV CX,128L1:     MOV DX,DATA[SI]    ADD SI,2    CMP DX,AVER    JAE L2    INC CNTL2:    LOOP L1        MOV BX,CNTEXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-17把-AX-中的-16-进制数转换为-ASCII-码-并将对应的-ASCII-码依次存放到-MEM-数组中的四个字节中"><a href="#5-17把-AX-中的-16-进制数转换为-ASCII-码-并将对应的-ASCII-码依次存放到-MEM-数组中的四个字节中" class="headerlink" title="5.17把 AX 中的 16 进制数转换为 ASCII 码,并将对应的 ASCII 码依次存放到 MEM 数组中的四个字节中"></a>5.17把 AX 中的 16 进制数转换为 ASCII 码,并将对应的 ASCII 码依次存放到 MEM 数组中的四个字节中</h3><p>例如，当(AX)=2A49H 时，MEM 中的 4 个字节为39H，34H，41H，32H</p><pre class=" language-asm"><code class="language-asm">;5.17 试编制一个程序把 AX 中的 16 进制数转换为 ASCII 码;并将对应的 ASCII 码依次存放到 MEM 数组中的四个字节中;例如，当(AX)=2A49H 时，MEM 中的 4 个字节为39H，34H，41H，32HS1 SEGMENT    MEM DB 4 DUP(?)S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    MOV AX,2A49H    MOV CX,4    MOV SI,3L0:    PUSH CX    MOV CL,4    ROL AX,CL    MOV DX,AX    AND DX,0FH    ADD DX,30H    CMP DX,3AH    JB    L1    ADD DX,7        ;存放数据    L1:    MOV MEM[SI],DL    DEC SI    POP CX    LOOP L0        EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-18把-0-100D-之间的-30-个数存入以-GRADE-为首地址的-30-字数组中"><a href="#5-18把-0-100D-之间的-30-个数存入以-GRADE-为首地址的-30-字数组中" class="headerlink" title="5.18把 0~100D 之间的 30 个数存入以 GRADE 为首地址的 30 字数组中"></a>5.18把 0~100D 之间的 30 个数存入以 GRADE 为首地址的 30 字数组中</h3><p>GRADE+i 表示学号为 i+1 的学生的成绩<br>数组 RANK 为 30 个学生的名次表<br>RANK+i 的内容是学号为 i+1 的学生的名次<br>根据 GRADE 中的学生成绩，将学生名次填入 RANK数组中<br>(提示：一个学生的名次等于成绩高于这个学生的人数加 1)</p><pre class=" language-asm"><code class="language-asm">;5.18 把 0~100D 之间的 30 个数存入以 GRADE 为首地址的 30 字数组中;GRADE+i 表示学号为 i+1 的学生的成绩;数组 RANK 为 30 个学生的名次表;RANK+i 的内容是学号为 i+1 的学生的名次;根据 GRADE 中的学生成绩，将学生名次填入 RANK数组中;(提示：一个学生的名次等于成绩高于这个学生的人数加 1。S1 SEGMENT    GRADE DW 13 DUP(90),4 DUP(80),5 DUP(70),2 DUP(60),0064H,6 DUP(95)    NUM DW 0    RANK DW 30 DUP(?)S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    MOV SI,0    MOV DI,0    MOV CX,30L0:    MOV AX,GRADE[SI]    ADD SI,2    MOV DI,0    MOV NUM,0    L1:    CMP DI,30    JE    L3    MOV BX,GRADE[DI]    ADD DI,2    CMP AX,BX    JA    L2    JMP L1    L2:    INC NUM    JMP L1    L3:    MOV DX,NUM    MOV RANK[SI],DX    LOOP L0    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-19-已知数组-A-包含-15-个互不相等的整数，数组-B-包含-20-个互不相等的整数"><a href="#5-19-已知数组-A-包含-15-个互不相等的整数，数组-B-包含-20-个互不相等的整数" class="headerlink" title="5.19 已知数组 A 包含 15 个互不相等的整数，数组 B 包含 20 个互不相等的整数"></a>5.19 已知数组 A 包含 15 个互不相等的整数，数组 B 包含 20 个互不相等的整数</h3><h3 id="把既在-A-中又在-B-中出现的整数存放于数组-C-中"><a href="#把既在-A-中又在-B-中出现的整数存放于数组-C-中" class="headerlink" title="把既在 A 中又在 B 中出现的整数存放于数组 C 中"></a>把既在 A 中又在 B 中出现的整数存放于数组 C 中</h3><pre class=" language-asm"><code class="language-asm">;5.19 已知数组 A 包含 15 个互不相等的整数，数组 B 包含 20 个互不相等的整数;把既在 A 中又在 B 中出现的整数存放于数组 C 中S1 SEGMENT    ARRYA    DB    0,1,2,3,4,5,6,7,8,9,10,11,12,13,14    ARRYB    DB    5,6,7,8,9,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29    ARRYC    DB    15 DUP(?)S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    MOV SI,0    MOV BX,0    MOV CX,15    ;外循环L0:    PUSH CX    MOV CX,20        MOV AL,ARRYA[SI]    INC SI        ;内循环    MOV DI,0L1:    CMP ARRYB[DI],AL    INC DI    JE L2            LOOP L1        ;接着比较    L2:    MOV ARRYC[BX],AL    INC BX        POP CX        LOOP L0        EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-20-设在-A、B-和-C-单元中分别存放着三个数。"><a href="#5-20-设在-A、B-和-C-单元中分别存放着三个数。" class="headerlink" title="5.20 设在 A、B 和 C 单元中分别存放着三个数。"></a>5.20 设在 A、B 和 C 单元中分别存放着三个数。</h3><h3 id="若三个数都不是-0，则求出三数之和存放在D-单元中"><a href="#若三个数都不是-0，则求出三数之和存放在D-单元中" class="headerlink" title="若三个数都不是 0，则求出三数之和存放在D 单元中"></a>若三个数都不是 0，则求出三数之和存放在D 单元中</h3><h3 id="若其中有一个数为-0，则把其它两单元也清-0"><a href="#若其中有一个数为-0，则把其它两单元也清-0" class="headerlink" title="若其中有一个数为 0，则把其它两单元也清 0"></a>若其中有一个数为 0，则把其它两单元也清 0</h3><pre class=" language-asm"><code class="language-asm">;5.20 设在 A、B 和 C 单元中分别存放着三个数。;若三个数都不是 0，则求出三数之和存放在D 单元中;若其中有一个数为 0，则把其它两单元也清 0S1 SEGMENT    NUMA    DW    10    NUMB    DW    0    NUMC    DW    0    NUMD    DW    0S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    XOR DX,DX    MOV AX,NUMA    CMP AX,0    JE  L1    ADD DX,AX        MOV AX,NUMB    CMP AX,0    JE  L1    ADD DX,AX        MOV AX,NUMC    CMP AX,0    JE  L1    ADD DX,AX    JMP L2        ;清零L1:    MOV BX,0    LEA SI,NUMA    MOV [SI],BX    LEA SI,NUMB    MOV [SI],BX    LEA SI,NUMC    MOV [SI],BX    JMP EXIT    L2:    LEA DI,NUMD    MOV DX,[DI]EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-21比较数组-ARRAY-中的三个-16-位补码数，并根据比较结果在终端上显示如下信息："><a href="#5-21比较数组-ARRAY-中的三个-16-位补码数，并根据比较结果在终端上显示如下信息：" class="headerlink" title="5.21比较数组 ARRAY 中的三个 16 位补码数，并根据比较结果在终端上显示如下信息："></a>5.21比较数组 ARRAY 中的三个 16 位补码数，并根据比较结果在终端上显示如下信息：</h3><h3 id="1-如果三个数都不相等则显示-0；"><a href="#1-如果三个数都不相等则显示-0；" class="headerlink" title="(1) 如果三个数都不相等则显示 0；"></a>(1) 如果三个数都不相等则显示 0；</h3><h3 id="2-如果三个数有二个数相等则显示-1；"><a href="#2-如果三个数有二个数相等则显示-1；" class="headerlink" title="(2) 如果三个数有二个数相等则显示 1；"></a>(2) 如果三个数有二个数相等则显示 1；</h3><h3 id="3-如果三个数都相等则显示-2"><a href="#3-如果三个数都相等则显示-2" class="headerlink" title="(3) 如果三个数都相等则显示 2"></a>(3) 如果三个数都相等则显示 2</h3><pre class=" language-ASM"><code class="language-ASM">;5.21比较数组 ARRAY 中的三个 16 位补码数，并根据比较结果在终端上显示如下信息：;(1) 如果三个数都不相等则显示 0；;(2) 如果三个数有二个数相等则显示 1；;(3) 如果三个数都相等则显示 2S1 SEGMENT    ARRAY    DW    1,2,1S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    LEA SI,ARRAY    MOV AX,[SI]    ADD SI,2    MOV BX,[SI]    ADD SI,2    MOV DX,[SI]    CMP AX,BX    JE  L1    JNE L2        ;A=BL1:    CMP BX,DX    JE    L3    JNE L4        ;A≠BL2:    CMP BX,DX    JE    L4    CMP AX,DX    JE    L4    JNE L5        ;ALL OKL3:    MOV DL,32H    MOV AH,2    INT 21H    JMP EXIT        ;JUST ONEL4:    MOV DL,31H    MOV AH,2    INT 21H    JMP EXIT        ;ALL NOTL5:    MOV DL,30H    MOV AH,2    INT 21H    JMP EXITEXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-22-从键盘输入一系列字符-以回车符结束-，并按字母、数字、及其它字符分类计数，最后显示出这三类的计数结果-OK"><a href="#5-22-从键盘输入一系列字符-以回车符结束-，并按字母、数字、及其它字符分类计数，最后显示出这三类的计数结果-OK" class="headerlink" title="5.22 从键盘输入一系列字符(以回车符结束)，并按字母、数字、及其它字符分类计数，最后显示出这三类的计数结果 OK"></a>5.22 从键盘输入一系列字符(以回车符结束)，并按字母、数字、及其它字符分类计数，最后显示出这三类的计数结果 OK</h3><pre class=" language-ASM"><code class="language-ASM">;从键盘输入一系列字符(以回车符结束)，并按字母、数字、及其它字符分类计数，;最后显示出这三类的计数结果S1 SEGMENT    BUFF    DB 250,?,250 DUP(?)    CNTA    DW    0    CNTN    DW    0    CNTO    DW    0S1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOP    LEA DX,BUFF    MOV    AH,0AH    INT 21H        MOV    SI,1    XOR CH,CH    MOV CL,BUFF[SI]L0:    INC SI    MOV AL,BUFF[SI]    CMP AL,30H    JB    L3    CMP AL,3AH    JB    L2    CMP AL,41H    JB    L3    CMP AL,5AH    JB    L1    CMP AL,61H    JB    L3    CMP AL,7AH    JB    L1L1:    INC CNTA    MOV BX,CNTA    LOOP L0L2:    INC CNTN    MOV DX,CNTN    LOOP L0L3:    INC CNTO    MOV DI,CNTO    LOOP L0        MOV DX,0DH    MOV AH,2    INT 21H    MOV DX,0AH    MOV AH,2    INT 21H    MOV DX,CNTA    MOV AH,2    ADD DX,30H    INT 21H        MOV DX,CNTN    ADD DX,30H    MOV AH,2    INT 21H    MOV DX,0DH    MOV AH,2    INT 21H    MOV DX,0AH    MOV AH,2    INT 21H        MOV DX,CNTO    ADD DX,30H    MOV AH,2    INT 21H    MOV DX,0DH    MOV AH,2    INT 21H    MOV DX,0AH    MOV AH,2    INT 21HEXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre><h3 id="5-23-已定义了两个整数变量-A-和-B，试编写程序完成下列功能："><a href="#5-23-已定义了两个整数变量-A-和-B，试编写程序完成下列功能：" class="headerlink" title="5.23 已定义了两个整数变量 A 和 B，试编写程序完成下列功能："></a>5.23 已定义了两个整数变量 A 和 B，试编写程序完成下列功能：</h3><p>(1) 若两个数中有一个是奇数，则将奇数存入 A 中，偶数存入 B 中；</p><p>(2) 若两个数中均为奇数，则将两数加 1 后存回原变量；</p><p>(3) 若两个数中均为偶数，则两个变量均不改变。</p><pre class=" language-ASM"><code class="language-ASM">;5.23 已定义了两个整数变量 A 和 B;(1) 若两个数中有一个是奇数，则将奇数存入 A 中，偶数存入 B 中；;(2) 若两个数中均为奇数，则将两数加 1 后存回原变量；;(3) 若两个数中均为偶数，则两个变量均不改变。S1 SEGMENT    NUMA    DW    2A32H    NUMB    DW    2A31HS1 ENDSS2 SEGMENT    DW 100H DUP(?)TOP LABEL WORDS2 ENDSS3 SEGMENT    ASSUME DS:S1,SS:S2,CS:S3MAIN PROC FAR    MOV AX,S1    MOV DS,AX    MOV AX,S2    MOV SS,AX    LEA SP,TOPL0:    MOV AX,NUMA    TEST AX,1    JE    L2        ;奇数L1:    MOV BX,NUMB    TEST BX,1    JNE    L4    JMP EXIT            ;偶数L2:        MOV BX,NUMB    TEST BX,1    JNE    L3    JMP EXIT        ;A奇B偶L3:    XCHG AX,BX    JMP EXIT    ;都是奇数，都+1L4:    INC AX    LEA SI,NUMA    MOV [SI],AX    INC BX    LEA SI,NUMB    MOV [SI],BX    EXIT:    MOV AH,4CH    INT 21HMAIN ENDPS3 ENDS    END MAIN</code></pre>]]></content>
      
      
      <categories>
          
          <category> ASM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ASM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/c-sin7/lhsin.cn/2023/02/10/MySQL%E7%AC%94%E8%AE%B0/"/>
      <url>/c-sin7/lhsin.cn/2023/02/10/MySQL%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL笔记"><a href="#MySQL笔记" class="headerlink" title="MySQL笔记"></a>MySQL笔记</h1><h2 id="登录和退出MySQL服务器"><a href="#登录和退出MySQL服务器" class="headerlink" title="登录和退出MySQL服务器"></a>登录和退出MySQL服务器</h2><pre class=" language-shell"><code class="language-shell"># 登录MySQL$ mysql -u root -p12345612# 退出MySQL数据库服务器exit;</code></pre><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><pre class=" language-mysql"><code class="language-mysql">-- 显示所有数据库show databases;-- 创建数据库CREATE DATABASE test;-- 切换数据库use test;-- 显示数据库中的所有表show tables;-- 创建数据表CREATE TABLE pet (    name VARCHAR(20),    owner VARCHAR(20),    species VARCHAR(20),    sex CHAR(1),    birth DATE,    death DATE);-- 查看数据表结构-- describe pet;desc pet;-- 查询表SELECT * from pet;-- 插入数据INSERT INTO pet VALUES ('puffball', 'Diane', 'hamster', 'f', '1990-03-30', NULL);-- 修改数据UPDATE pet SET name = 'squirrel' where owner = 'Diane';-- 删除数据DELETE FROM pet where name = 'squirrel';-- 删除表DROP TABLE myorder;</code></pre><h2 id="建表约束"><a href="#建表约束" class="headerlink" title="建表约束"></a>建表约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><pre class=" language-mysql"><code class="language-mysql">-- 主键约束-- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。CREATE TABLE user (    id INT PRIMARY KEY,    name VARCHAR(20));-- 联合主键-- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。CREATE TABLE user (    id INT,    name VARCHAR(20),    password VARCHAR(20),    PRIMARY KEY(id, name));-- 自增约束-- 自增约束的主键由系统自动递增分配。CREATE TABLE user (    id INT PRIMARY KEY AUTO_INCREMENT,    name VARCHAR(20));-- 添加主键约束-- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD PRIMARY KEY(id);ALTER TABLE user MODIFY id INT PRIMARY KEY;-- 删除主键ALTER TABLE user drop PRIMARY KEY;</code></pre><h3 id="唯一主键"><a href="#唯一主键" class="headerlink" title="唯一主键"></a>唯一主键</h3><pre class=" language-mysql"><code class="language-mysql">-- 建表时创建唯一主键CREATE TABLE user (    id INT,    name VARCHAR(20),    UNIQUE(name));-- 添加唯一主键-- 如果建表时没有设置唯一建，还可以通过SQL语句设置（两种方式）：ALTER TABLE user ADD UNIQUE(name);ALTER TABLE user MODIFY name VARCHAR(20) UNIQUE;-- 删除唯一主键ALTER TABLE user DROP INDEX name;</code></pre><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><pre class=" language-mysql"><code class="language-mysql">-- 建表时添加非空约束-- 约束某个字段不能为空CREATE TABLE user (    id INT,    name VARCHAR(20) NOT NULL);-- 移除非空约束ALTER TABLE user MODIFY name VARCHAR(20);</code></pre><h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><pre class=" language-mysql"><code class="language-mysql">-- 建表时添加默认约束-- 约束某个字段的默认值CREATE TABLE user2 (    id INT,    name VARCHAR(20),    age INT DEFAULT 10);-- 移除非空约束ALTER TABLE user MODIFY age INT;</code></pre><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><pre class=" language-mysql"><code class="language-mysql">-- 班级CREATE TABLE classes (    id INT PRIMARY KEY,    name VARCHAR(20));-- 学生表CREATE TABLE students (    id INT PRIMARY KEY,    name VARCHAR(20),    -- 这里的 class_id 要和 classes 中的 id 字段相关联    class_id INT,    -- 表示 class_id 的值必须来自于 classes 中的 id 字段值    FOREIGN KEY(class_id) REFERENCES classes(id));-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的；-- 2. 主表中的记录被副表引用时，主表不可以被删除。</code></pre><h2 id="数据库的三大设计范式"><a href="#数据库的三大设计范式" class="headerlink" title="数据库的三大设计范式"></a>数据库的三大设计范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>只要字段值还可以继续拆分，就不满足第一范式。</p><p>范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下：</p><pre class=" language-mysql"><code class="language-mysql">-- 订单表CREATE TABLE myorder (    product_id INT,    customer_id INT,    product_name VARCHAR(20),    customer_name VARCHAR(20),    PRIMARY KEY (product_id, customer_id));</code></pre><p>实际上，在这张订单表中，<code>product_name</code> 只依赖于 <code>product_id</code> ，<code>customer_name</code> 只依赖于 <code>customer_id</code> 。也就是说，<code>product_name</code> 和 <code>customer_id</code> 是没用关系的，<code>customer_name</code> 和 <code>product_id</code> 也是没有关系的。</p><p>这就不满足第二范式：其他列都必须完全依赖于主键列！</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT);CREATE TABLE product (    id INT PRIMARY KEY,    name VARCHAR(20));CREATE TABLE customer (    id INT PRIMARY KEY,    name VARCHAR(20));</code></pre><p>拆分之后，<code>myorder</code> 表中的 <code>product_id</code> 和 <code>customer_id</code> 完全依赖于 <code>order_id</code> 主键，而 <code>product</code> 和 <code>customer</code> 表中的其他字段又完全依赖于主键。满足了第二范式的设计！</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT,    customer_phone VARCHAR(15));</code></pre><p>表中的 <code>customer_phone</code> 有可能依赖于 <code>order_id</code> 、 <code>customer_id</code> 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE myorder (    order_id INT PRIMARY KEY,    product_id INT,    customer_id INT);CREATE TABLE customer (    id INT PRIMARY KEY,    name VARCHAR(20),    phone VARCHAR(15));</code></pre><p>修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！</p><h2 id="查询练习"><a href="#查询练习" class="headerlink" title="查询练习"></a>查询练习</h2><h3 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h3><pre class=" language-mysql"><code class="language-mysql">-- 创建数据库CREATE DATABASE select_test;-- 切换数据库USE select_test;-- 创建学生表CREATE TABLE student (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    sex VARCHAR(10) NOT NULL,    birthday DATE, -- 生日    class VARCHAR(20) -- 所在班级);-- 创建教师表CREATE TABLE teacher (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    sex VARCHAR(10) NOT NULL,    birthday DATE,    profession VARCHAR(20) NOT NULL, -- 职称    department VARCHAR(20) NOT NULL -- 部门);-- 创建课程表CREATE TABLE course (    no VARCHAR(20) PRIMARY KEY,    name VARCHAR(20) NOT NULL,    t_no VARCHAR(20) NOT NULL, -- 教师编号    -- 表示该 tno 来自于 teacher 表中的 no 字段值    FOREIGN KEY(t_no) REFERENCES teacher(no) );-- 成绩表CREATE TABLE score (    s_no VARCHAR(20) NOT NULL, -- 学生编号    c_no VARCHAR(20) NOT NULL, -- 课程号    degree DECIMAL,    -- 成绩    -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值    FOREIGN KEY(s_no) REFERENCES student(no),        FOREIGN KEY(c_no) REFERENCES course(no),    -- 设置 s_no, c_no 为联合主键    PRIMARY KEY(s_no, c_no));-- 查看所有表SHOW TABLES;-- 添加学生表数据INSERT INTO student VALUES('101', '曾华', '男', '1977-09-01', '95033');INSERT INTO student VALUES('102', '匡明', '男', '1975-10-02', '95031');INSERT INTO student VALUES('103', '王丽', '女', '1976-01-23', '95033');INSERT INTO student VALUES('104', '李军', '男', '1976-02-20', '95033');INSERT INTO student VALUES('105', '王芳', '女', '1975-02-10', '95031');INSERT INTO student VALUES('106', '陆军', '男', '1974-06-03', '95031');INSERT INTO student VALUES('107', '王尼玛', '男', '1976-02-20', '95033');INSERT INTO student VALUES('108', '张全蛋', '男', '1975-02-10', '95031');INSERT INTO student VALUES('109', '赵铁柱', '男', '1974-06-03', '95031');-- 添加教师表数据INSERT INTO teacher VALUES('804', '李诚', '男', '1958-12-02', '副教授', '计算机系');INSERT INTO teacher VALUES('856', '张旭', '男', '1969-03-12', '讲师', '电子工程系');INSERT INTO teacher VALUES('825', '王萍', '女', '1972-05-05', '助教', '计算机系');INSERT INTO teacher VALUES('831', '刘冰', '女', '1977-08-14', '助教', '电子工程系');-- 添加课程表数据INSERT INTO course VALUES('3-105', '计算机导论', '825');INSERT INTO course VALUES('3-245', '操作系统', '804');INSERT INTO course VALUES('6-166', '数字电路', '856');INSERT INTO course VALUES('9-888', '高等数学', '831');-- 添加添加成绩表数据INSERT INTO score VALUES('103', '3-105', '92');INSERT INTO score VALUES('103', '3-245', '86');INSERT INTO score VALUES('103', '6-166', '85');INSERT INTO score VALUES('105', '3-105', '88');INSERT INTO score VALUES('105', '3-245', '75');INSERT INTO score VALUES('105', '6-166', '79');INSERT INTO score VALUES('109', '3-105', '76');INSERT INTO score VALUES('109', '3-245', '68');INSERT INTO score VALUES('109', '6-166', '81');-- 查看表结构SELECT * FROM course;SELECT * FROM score;SELECT * FROM student;SELECT * FROM teacher;</code></pre><h3 id="1-到-10"><a href="#1-到-10" class="headerlink" title="1 到 10"></a>1 到 10</h3><pre class=" language-mysql"><code class="language-mysql">-- 查询 student 表的所有行SELECT * FROM student;-- 查询 student 表中的 name、sex 和 class 字段的所有行SELECT name, sex, class FROM student;-- 查询 teacher 表中不重复的 department 列-- department: 去重查询SELECT DISTINCT department FROM teacher;-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询）-- BETWEEN xx AND xx: 查询区间, AND 表示 "并且"SELECT * FROM score WHERE degree BETWEEN 60 AND 80;SELECT * FROM score WHERE degree > 60 AND degree < 80;-- 查询 score 表中成绩为 85, 86 或 88 的行-- IN: 查询规定中的多个值SELECT * FROM score WHERE degree IN (85, 86, 88);-- 查询 student 表中 '95031' 班或性别为 '女' 的所有行-- or: 表示或者关系SELECT * FROM student WHERE class = '95031' or sex = '女';-- 以 class 降序的方式查询 student 表的所有行-- DESC: 降序，从高到低-- ASC（默认）: 升序，从低到高SELECT * FROM student ORDER BY class DESC;SELECT * FROM student ORDER BY class ASC;-- 以 c_no 升序、degree 降序查询 score 表的所有行SELECT * FROM score ORDER BY c_no ASC, degree DESC;-- 查询 "95031" 班的学生人数-- COUNT: 统计SELECT COUNT(*) FROM student WHERE class = '95031';-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。-- (SELECT MAX(degree) FROM score): 子查询，算出最高分SELECT s_no, c_no FROM score WHERE degree = (SELECT MAX(degree) FROM score);--  排序查询-- LIMIT r, n: 表示从第r行开始，查询n条数据SELECT s_no, c_no, degree FROM score ORDER BY degree DESC LIMIT 0, 1;</code></pre><h3 id="分组计算平均成绩"><a href="#分组计算平均成绩" class="headerlink" title="分组计算平均成绩"></a>分组计算平均成绩</h3><p><strong>查询每门课的平均成绩。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- AVG: 平均值SELECT AVG(degree) FROM score WHERE c_no = '3-105';SELECT AVG(degree) FROM score WHERE c_no = '3-245';SELECT AVG(degree) FROM score WHERE c_no = '6-166';-- GROUP BY: 分组查询SELECT c_no, AVG(degree) FROM score GROUP BY c_no;</code></pre><h3 id="分组条件与模糊查询"><a href="#分组条件与模糊查询" class="headerlink" title="分组条件与模糊查询"></a>分组条件与模糊查询</h3><p><strong>查询 <code>score</code> 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score;-- c_no 课程编号+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>分析表发现，至少有 2 名学生选修的课程是 <code>3-105</code> 、<code>3-245</code> 、<code>6-166</code> ，以 3 开头的课程是 <code>3-105</code> 、<code>3-245</code> 。也就是说，我们要查询所有 <code>3-105</code> 和 <code>3-245</code> 的 <code>degree</code> 平均分。</p><pre class=" language-mysql"><code class="language-mysql">-- 首先把 c_no, AVG(degree) 通过分组查询出来SELECT c_no, AVG(degree) FROM score GROUP BY c_no+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     85.3333 || 3-245 |     76.3333 || 6-166 |     81.6667 |+-------+-------------+-- 再查询出至少有 2 名学生选修的课程-- HAVING: 表示持有HAVING COUNT(c_no) >= 2-- 并且是以 3 开头的课程-- LIKE 表示模糊查询，"%" 是一个通配符，匹配 "3" 后面的任意字符。AND c_no LIKE '3%';-- 把前面的SQL语句拼接起来，-- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。SELECT c_no, AVG(degree), COUNT(*) FROM score GROUP BY c_noHAVING COUNT(c_no) >= 2 AND c_no LIKE '3%';+-------+-------------+----------+| c_no  | AVG(degree) | COUNT(*) |+-------+-------------+----------+| 3-105 |     85.3333 |        3 || 3-245 |     76.3333 |        3 |+-------+-------------+----------+</code></pre><h3 id="多表查询-1"><a href="#多表查询-1" class="headerlink" title="多表查询 - 1"></a>多表查询 - 1</h3><p><strong>查询所有学生的 <code>name</code>，以及该学生在 <code>score</code> 表中对应的 <code>c_no</code> 和 <code>degree</code> 。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT no, name FROM student;+-----+-----------+| no  | name      |+-----+-----------+| 101 | 曾华      || 102 | 匡明      || 103 | 王丽      || 104 | 李军      || 105 | 王芳      || 106 | 陆军      || 107 | 王尼玛    || 108 | 张全蛋    || 109 | 赵铁柱    |+-----+-----------+SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>通过分析可以发现，只要把 <code>score</code> 表中的 <code>s_no</code> 字段值替换成 <code>student</code> 表中对应的 <code>name</code> 字段值就可以了，如何做呢？</p><pre class=" language-mysql"><code class="language-mysql">-- FROM...: 表示从 student, score 表中查询-- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no;+-----------+-------+--------+| name      | c_no  | degree |+-----------+-------+--------+| 王丽      | 3-105 |     92 || 王丽      | 3-245 |     86 || 王丽      | 6-166 |     85 || 王芳      | 3-105 |     88 || 王芳      | 3-245 |     75 || 王芳      | 6-166 |     79 || 赵铁柱    | 3-105 |     76 || 赵铁柱    | 3-245 |     68 || 赵铁柱    | 6-166 |     81 |+-----------+-------+--------+</code></pre><h3 id="多表查询-2"><a href="#多表查询-2" class="headerlink" title="多表查询 - 2"></a>多表查询 - 2</h3><p><strong>查询所有学生的 <code>no</code> 、课程名称 ( <code>course</code> 表中的 <code>name</code> ) 和成绩 ( <code>score</code> 表中的 <code>degree</code> ) 列。</strong></p><p>只有 <code>score</code> 关联学生的 <code>no</code> ，因此只要查询 <code>score</code> 表，就能找出所有和学生相关的 <code>no</code> 和 <code>degree</code> ：</p><pre class=" language-mysql"><code class="language-mysql">SELECT s_no, c_no, degree FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>然后查询 <code>course</code> 表：</p><pre class=" language-mysql"><code class="language-mysql">+-------+-----------------+| no    | name            |+-------+-----------------+| 3-105 | 计算机导论      || 3-245 | 操作系统        || 6-166 | 数字电路        || 9-888 | 高等数学        |+-------+-----------------+</code></pre><p>只要把 <code>score</code> 表中的 <code>c_no</code> 替换成 <code>course</code> 表中对应的 <code>name</code> 字段值就可以了。</p><pre class=" language-mysql"><code class="language-mysql">-- 增加一个查询字段 name，分别从 score、course 这两个表中查询。-- as 表示取一个该字段的别名。SELECT s_no, name as c_name, degree FROM score, courseWHERE score.c_no = course.no;+------+-----------------+--------+| s_no | c_name          | degree |+------+-----------------+--------+| 103  | 计算机导论      |     92 || 105  | 计算机导论      |     88 || 109  | 计算机导论      |     76 || 103  | 操作系统        |     86 || 105  | 操作系统        |     75 || 109  | 操作系统        |     68 || 103  | 数字电路        |     85 || 105  | 数字电路        |     79 || 109  | 数字电路        |     81 |+------+-----------------+--------+</code></pre><h3 id="三表关联查询"><a href="#三表关联查询" class="headerlink" title="三表关联查询"></a>三表关联查询</h3><p><strong>查询所有学生的 <code>name</code> 、课程名 ( <code>course</code> 表中的 <code>name</code> ) 和 <code>degree</code> 。</strong></p><p>只有 <code>score</code> 表中关联学生的学号和课堂号，我们只要围绕着 <code>score</code> 这张表查询就好了。</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>只要把 <code>s_no</code> 和 <code>c_no</code> 替换成 <code>student</code> 和 <code>srouse</code> 表中对应的 <code>name</code> 字段值就好了。</p><p>首先把 <code>s_no</code> 替换成 <code>student</code> 表中的 <code>name</code> 字段：</p><pre class=" language-mysql"><code class="language-mysql">SELECT name, c_no, degree FROM student, score WHERE student.no = score.s_no;+-----------+-------+--------+| name      | c_no  | degree |+-----------+-------+--------+| 王丽      | 3-105 |     92 || 王丽      | 3-245 |     86 || 王丽      | 6-166 |     85 || 王芳      | 3-105 |     88 || 王芳      | 3-245 |     75 || 王芳      | 6-166 |     79 || 赵铁柱    | 3-105 |     76 || 赵铁柱    | 3-245 |     68 || 赵铁柱    | 6-166 |     81 |+-----------+-------+--------+</code></pre><p>再把 <code>c_no</code> 替换成 <code>course</code> 表中的 <code>name</code> 字段：</p><pre class=" language-mysql"><code class="language-mysql">-- 课程表SELECT no, name FROM course;+-------+-----------------+| no    | name            |+-------+-----------------+| 3-105 | 计算机导论      || 3-245 | 操作系统        || 6-166 | 数字电路        || 9-888 | 高等数学        |+-------+-----------------+-- 由于字段名存在重复，使用 "表名.字段名 as 别名" 代替。SELECT student.name as s_name, course.name as c_name, degree FROM student, score, courseWHERE student.NO = score.s_noAND score.c_no = course.no;</code></pre><h3 id="子查询加分组求平均分"><a href="#子查询加分组求平均分" class="headerlink" title="子查询加分组求平均分"></a>子查询加分组求平均分</h3><p><strong>查询 <code>95031</code> 班学生每门课程的平均成绩。</strong></p><p>在 <code>score</code> 表中根据 <code>student</code>  表的学生编号筛选出学生的课堂号和成绩：</p><pre class=" language-mysql"><code class="language-mysql">-- IN (..): 将筛选出的学生号当做 s_no 的条件查询SELECT s_no, c_no, degree FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class = '95031');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><p>这时只要将 <code>c_no</code> 分组一下就能得出 <code>95031</code> 班学生每门课的平均成绩：</p><pre class=" language-mysql"><code class="language-mysql">SELECT c_no, AVG(degree) FROM scoreWHERE s_no IN (SELECT no FROM student WHERE class = '95031')GROUP BY c_no;+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     82.0000 || 3-245 |     71.5000 || 6-166 |     80.0000 |+-------+-------------+</code></pre><h3 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询 - 1"></a>子查询 - 1</h3><p><strong>查询在 <code>3-105</code> 课程中，所有成绩高于 <code>109</code> 号同学的记录。</strong></p><p>首先筛选出课堂号为 <code>3-105</code> ，在找出所有成绩高于 <code>109</code> 号同学的的行。</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = '3-105'AND degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105');</code></pre><h3 id="子查询-2"><a href="#子查询-2" class="headerlink" title="子查询 - 2"></a>子查询 - 2</h3><p><strong>查询所有成绩高于 <code>109</code> 号同学的 <code>3-105</code> 课程成绩记录。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。SELECT * FROM scoreWHERE degree > (SELECT degree FROM score WHERE s_no = '109' AND c_no = '3-105');</code></pre><h3 id="YEAR-函数与带-IN-关键字查询"><a href="#YEAR-函数与带-IN-关键字查询" class="headerlink" title="YEAR 函数与带 IN 关键字查询"></a>YEAR 函数与带 IN 关键字查询</h3><p><strong>查询所有和 <code>101</code> 、<code>108</code> 号学生同年出生的 <code>no</code> 、<code>name</code> 、<code>birthday</code> 列。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- YEAR(..): 取出日期中的年份SELECT no, name, birthday FROM studentWHERE YEAR(birthday) IN (SELECT YEAR(birthday) FROM student WHERE no IN (101, 108));</code></pre><h3 id="多层嵌套子查询"><a href="#多层嵌套子查询" class="headerlink" title="多层嵌套子查询"></a>多层嵌套子查询</h3><p><strong>查询 <code>&#39;张旭&#39;</code> 教师任课的学生成绩表。</strong></p><p>首先找到教师编号：</p><pre class=" language-mysql"><code class="language-mysql">SELECT NO FROM teacher WHERE NAME = '张旭'</code></pre><p>通过 <code>sourse</code> 表找到该教师课程号：</p><pre class=" language-mysql"><code class="language-mysql">SELECT NO FROM course WHERE t_no = ( SELECT NO FROM teacher WHERE NAME = '张旭' );</code></pre><p>通过筛选出的课程号查询成绩表：</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = (    SELECT no FROM course WHERE t_no = (         SELECT no FROM teacher WHERE NAME = '张旭'     ));</code></pre><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>查询某选修课程多于5个同学的教师姓名。</strong></p><p>首先在 <code>teacher</code> 表中，根据 <code>no</code> 字段来判断该教师的同一门课程是否有至少5名学员选修：</p><pre class=" language-mysql"><code class="language-mysql">-- 查询 teacher 表SELECT no, name FROM teacher;+-----+--------+| no  | name   |+-----+--------+| 804 | 李诚   || 825 | 王萍   || 831 | 刘冰   || 856 | 张旭   |+-----+--------+SELECT name FROM teacher WHERE no IN (    -- 在这里找到对应的条件);</code></pre><p>查看和教师编号有有关的表的信息：</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM course;-- t_no: 教师编号+-------+-----------------+------+| no    | name            | t_no |+-------+-----------------+------+| 3-105 | 计算机导论      | 825  || 3-245 | 操作系统        | 804  || 6-166 | 数字电路        | 856  || 9-888 | 高等数学        | 831  |+-------+-----------------+------+</code></pre><p>我们已经找到和教师编号有关的字段就在 <code>course</code> 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 <code>score</code> 表来查询：</p><pre class=" language-mysql"><code class="language-mysql">-- 在此之前向 score 插入一些数据，以便丰富查询条件。INSERT INTO score VALUES ('101', '3-105', '90');INSERT INTO score VALUES ('102', '3-105', '91');INSERT INTO score VALUES ('104', '3-105', '89');-- 查询 score 表SELECT * FROM score;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 103  | 3-245 |     86 || 103  | 6-166 |     85 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5;+-------+| c_no  |+-------+| 3-105 |+-------+</code></pre><p>根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号：</p><pre class=" language-mysql"><code class="language-mysql">SELECT t_no FROM course WHERE no IN (    SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5);+------+| t_no |+------+| 825  |+------+</code></pre><p>在 <code>teacher</code> 表中，根据筛选出来的教师编号找到教师姓名：</p><pre class=" language-mysql"><code class="language-mysql">SELECT name FROM teacher WHERE no IN (    -- 最终条件    SELECT t_no FROM course WHERE no IN (        SELECT c_no FROM score GROUP BY c_no HAVING COUNT(*) > 5    ));</code></pre><h3 id="子查询-3"><a href="#子查询-3" class="headerlink" title="子查询 - 3"></a>子查询 - 3</h3><p><strong>查询 “计算机系” 课程的成绩表。</strong></p><p>思路是，先找出 <code>course</code> 表中所有 <code>计算机系</code> 课程的编号，然后根据这个编号查询 <code>score</code> 表。</p><pre class=" language-mysql"><code class="language-mysql">-- 通过 teacher 表查询所有 `计算机系` 的教师编号SELECT no, name, department FROM teacher WHERE department = '计算机系'+-----+--------+--------------+| no  | name   | department   |+-----+--------+--------------+| 804 | 李诚   | 计算机系     || 825 | 王萍   | 计算机系     |+-----+--------+--------------+-- 通过 course 表查询该教师的课程编号SELECT no FROM course WHERE t_no IN (    SELECT no FROM teacher WHERE department = '计算机系');+-------+| no    |+-------+| 3-245 || 3-105 |+-------+-- 根据筛选出来的课程号查询成绩表SELECT * FROM score WHERE c_no IN (    SELECT no FROM course WHERE t_no IN (        SELECT no FROM teacher WHERE department = '计算机系'    ));+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-245 |     86 || 105  | 3-245 |     75 || 109  | 3-245 |     68 || 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+</code></pre><h3 id="UNION-和-NOTIN-的使用"><a href="#UNION-和-NOTIN-的使用" class="headerlink" title="UNION 和 NOTIN 的使用"></a>UNION 和 NOTIN 的使用</h3><p><strong>查询 <code>计算机系</code> 与 <code>电子工程系</code> 中的不同职称的教师。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- NOT: 代表逻辑非SELECT * FROM teacher WHERE department = '计算机系' AND profession NOT IN (    SELECT profession FROM teacher WHERE department = '电子工程系')-- 合并两个集UNIONSELECT * FROM teacher WHERE department = '电子工程系' AND profession NOT IN (    SELECT profession FROM teacher WHERE department = '计算机系');</code></pre><h3 id="ANY-表示至少一个-DESC-降序"><a href="#ANY-表示至少一个-DESC-降序" class="headerlink" title="ANY 表示至少一个 - DESC ( 降序 )"></a>ANY 表示至少一个 - DESC ( 降序 )</h3><p><strong>查询课程 <code>3-105</code> 且成绩 <u>至少</u> 高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = '3-105';+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+SELECT * FROM score WHERE c_no = '3-245';+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-245 |     86 || 105  | 3-245 |     75 || 109  | 3-245 |     68 |+------+-------+--------+-- ANY: 符合SQL语句中的任意条件。-- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件，-- 最后根据降序查询结果。SELECT * FROM score WHERE c_no = '3-105' AND degree > ANY(    SELECT degree FROM score WHERE c_no = '3-245') ORDER BY degree DESC;+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 || 102  | 3-105 |     91 || 101  | 3-105 |     90 || 104  | 3-105 |     89 || 105  | 3-105 |     88 || 109  | 3-105 |     76 |+------+-------+--------+</code></pre><h3 id="表示所有的-ALL"><a href="#表示所有的-ALL" class="headerlink" title="表示所有的 ALL"></a>表示所有的 ALL</h3><p><strong>查询课程 <code>3-105</code> 且成绩高于 <code>3-245</code> 的 <code>score</code> 表。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 只需对上一道题稍作修改。-- ALL: 符合SQL语句中的所有条件。-- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。SELECT * FROM score WHERE c_no = '3-105' AND degree > ALL(    SELECT degree FROM score WHERE c_no = '3-245');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 103  | 3-105 |     92 || 104  | 3-105 |     89 || 105  | 3-105 |     88 |+------+-------+--------+</code></pre><h3 id="复制表的数据作为条件查询"><a href="#复制表的数据作为条件查询" class="headerlink" title="复制表的数据作为条件查询"></a>复制表的数据作为条件查询</h3><p><strong>查询某课程成绩比该课程平均成绩低的 <code>score</code> 表。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 查询平均分SELECT c_no, AVG(degree) FROM score GROUP BY c_no;+-------+-------------+| c_no  | AVG(degree) |+-------+-------------+| 3-105 |     87.6667 || 3-245 |     76.3333 || 6-166 |     81.6667 |+-------+-------------+-- 查询 score 表SELECT degree FROM score;+--------+| degree |+--------+|     90 ||     91 ||     92 ||     86 ||     85 ||     89 ||     88 ||     75 ||     79 ||     76 ||     68 ||     81 |+--------+-- 将表 b 作用于表 a 中查询数据-- score a (b): 将表声明为 a (b)，-- 如此就能用 a.c_no = b.c_no 作为条件执行查询了。SELECT * FROM score a WHERE degree < (    (SELECT AVG(degree) FROM score b WHERE a.c_no = b.c_no));+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 105  | 3-245 |     75 || 105  | 6-166 |     79 || 109  | 3-105 |     76 || 109  | 3-245 |     68 || 109  | 6-166 |     81 |+------+-------+--------+</code></pre><h3 id="子查询-4"><a href="#子查询-4" class="headerlink" title="子查询 - 4"></a>子查询 - 4</h3><p><strong>查询所有任课 ( 在 <code>course</code> 表里有课程 ) 教师的 <code>name</code> 和 <code>department</code></strong> 。</p><pre class=" language-mysql"><code class="language-mysql">SELECT name, department FROM teacher WHERE no IN (SELECT t_no FROM course);+--------+-----------------+| name   | department      |+--------+-----------------+| 李诚   | 计算机系        || 王萍   | 计算机系        || 刘冰   | 电子工程系      || 张旭   | 电子工程系      |+--------+-----------------+</code></pre><h3 id="条件加组筛选"><a href="#条件加组筛选" class="headerlink" title="条件加组筛选"></a>条件加组筛选</h3><p><strong>查询 <code>student</code> 表中至少有 2 名男生的 <code>class</code> 。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 查看学生表信息SELECT * FROM student;+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 101 | 曾华      | 男  | 1977-09-01 | 95033 || 102 | 匡明      | 男  | 1975-10-02 | 95031 || 103 | 王丽      | 女  | 1976-01-23 | 95033 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 105 | 王芳      | 女  | 1975-02-10 | 95031 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 107 | 王尼玛    | 男  | 1976-02-20 | 95033 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 110 | 张飞      | 男  | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。SELECT class FROM student WHERE sex = '男' GROUP BY class HAVING COUNT(*) > 1;+-------+| class |+-------+| 95033 || 95031 |+-------+</code></pre><h3 id="NOTLIKE-模糊查询取反"><a href="#NOTLIKE-模糊查询取反" class="headerlink" title="NOTLIKE 模糊查询取反"></a>NOTLIKE 模糊查询取反</h3><p><strong>查询 <code>student</code> 表中不姓 “王” 的同学记录。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- NOT: 取反-- LIKE: 模糊查询mysql> SELECT * FROM student WHERE name NOT LIKE '王%';+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 101 | 曾华      | 男  | 1977-09-01 | 95033 || 102 | 匡明      | 男  | 1975-10-02 | 95031 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 110 | 张飞      | 男  | 1974-06-03 | 95038 |+-----+-----------+-----+------------+-------+</code></pre><h3 id="YEAR-与-NOW-函数"><a href="#YEAR-与-NOW-函数" class="headerlink" title="YEAR 与 NOW 函数"></a>YEAR 与 NOW 函数</h3><p><strong>查询 <code>student</code> 表中每个学生的姓名和年龄。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。SELECT name, YEAR(NOW()) - YEAR(birthday) as age FROM student;+-----------+------+| name      | age  |+-----------+------+| 曾华      |   42 || 匡明      |   44 || 王丽      |   43 || 李军      |   43 || 王芳      |   44 || 陆军      |   45 || 王尼玛    |   43 || 张全蛋    |   44 || 赵铁柱    |   45 || 张飞      |   45 |+-----------+------+</code></pre><h3 id="MAX-与-MIN-函数"><a href="#MAX-与-MIN-函数" class="headerlink" title="MAX 与 MIN 函数"></a>MAX 与 MIN 函数</h3><p><strong>查询 <code>student</code> 表中最大和最小的 <code>birthday</code> 值。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT MAX(birthday), MIN(birthday) FROM student;+---------------+---------------+| MAX(birthday) | MIN(birthday) |+---------------+---------------+| 1977-09-01    | 1974-06-03    |+---------------+---------------+</code></pre><h3 id="多段排序"><a href="#多段排序" class="headerlink" title="多段排序"></a>多段排序</h3><p><strong>以 <code>class</code> 和 <code>birthday</code> 从大到小的顺序查询 <code>student</code> 表。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM student ORDER BY class DESC, birthday;+-----+-----------+-----+------------+-------+| no  | name      | sex | birthday   | class |+-----+-----------+-----+------------+-------+| 110 | 张飞      | 男  | 1974-06-03 | 95038 || 103 | 王丽      | 女  | 1976-01-23 | 95033 || 104 | 李军      | 男  | 1976-02-20 | 95033 || 107 | 王尼玛    | 男  | 1976-02-20 | 95033 || 101 | 曾华      | 男  | 1977-09-01 | 95033 || 106 | 陆军      | 男  | 1974-06-03 | 95031 || 109 | 赵铁柱    | 男  | 1974-06-03 | 95031 || 105 | 王芳      | 女  | 1975-02-10 | 95031 || 108 | 张全蛋    | 男  | 1975-02-10 | 95031 || 102 | 匡明      | 男  | 1975-10-02 | 95031 |+-----+-----------+-----+------------+-------+</code></pre><h3 id="子查询-5"><a href="#子查询-5" class="headerlink" title="子查询 - 5"></a>子查询 - 5</h3><p><strong>查询 “男” 教师及其所上的课程。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM course WHERE t_no in (SELECT no FROM teacher WHERE sex = '男');+-------+--------------+------+| no    | name         | t_no |+-------+--------------+------+| 3-245 | 操作系统     | 804  || 6-166 | 数字电路     | 856  |+-------+--------------+------+</code></pre><h3 id="MAX-函数与子查询"><a href="#MAX-函数与子查询" class="headerlink" title="MAX 函数与子查询"></a>MAX 函数与子查询</h3><p><strong>查询最高分同学的 <code>score</code> 表。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 找出最高成绩（该查询只能有一个结果）SELECT MAX(degree) FROM score;-- 根据上面的条件筛选出所有最高成绩表，-- 该查询可能有多个结果，假设 degree 值多次符合条件。SELECT * FROM score WHERE degree = (SELECT MAX(degree) FROM score);+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 103  | 3-105 |     92 |+------+-------+--------+</code></pre><h3 id="子查询-6"><a href="#子查询-6" class="headerlink" title="子查询 - 6"></a>子查询 - 6</h3><p><strong>查询和 “李军” 同性别的所有同学 <code>name</code> 。</strong></p><pre class=" language-mysql"><code class="language-mysql">-- 首先将李军的性别作为条件取出来SELECT sex FROM student WHERE name = '李军';+-----+| sex |+-----+| 男  |+-----+-- 根据性别查询 name 和 sexSELECT name, sex FROM student WHERE sex = (    SELECT sex FROM student WHERE name = '李军');+-----------+-----+| name      | sex |+-----------+-----+| 曾华      | 男  || 匡明      | 男  || 李军      | 男  || 陆军      | 男  || 王尼玛    | 男  || 张全蛋    | 男  || 赵铁柱    | 男  || 张飞      | 男  |+-----------+-----+</code></pre><h3 id="子查询-7"><a href="#子查询-7" class="headerlink" title="子查询 - 7"></a>子查询 - 7</h3><p><strong>查询和 “李军” 同性别且同班的同学 <code>name</code> 。</strong></p><pre class=" language-mysql"><code class="language-mysql">SELECT name, sex, class FROM student WHERE sex = (    SELECT sex FROM student WHERE name = '李军') AND class = (    SELECT class FROM student WHERE name = '李军');+-----------+-----+-------+| name      | sex | class |+-----------+-----+-------+| 曾华      | 男  | 95033 || 李军      | 男  | 95033 || 王尼玛    | 男  | 95033 |+-----------+-----+-------+</code></pre><h3 id="子查询-8"><a href="#子查询-8" class="headerlink" title="子查询 - 8"></a>子查询 - 8</h3><p><strong>查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。</strong></p><p>需要的 “计算机导论” 和性别为 “男” 的编号可以在 <code>course</code> 和 <code>student</code> 表中找到。</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM score WHERE c_no = (    SELECT no FROM course WHERE name = '计算机导论') AND s_no IN (    SELECT no FROM student WHERE sex = '男');+------+-------+--------+| s_no | c_no  | degree |+------+-------+--------+| 101  | 3-105 |     90 || 102  | 3-105 |     91 || 104  | 3-105 |     89 || 109  | 3-105 |     76 |+------+-------+--------+</code></pre><h3 id="按等级查询"><a href="#按等级查询" class="headerlink" title="按等级查询"></a>按等级查询</h3><p>建立一个 <code>grade</code> 表代表学生的成绩等级，并插入数据：</p><pre class=" language-mysql"><code class="language-mysql">CREATE TABLE grade (    low INT(3),    upp INT(3),    grade char(1));INSERT INTO grade VALUES (90, 100, 'A');INSERT INTO grade VALUES (80, 89, 'B');INSERT INTO grade VALUES (70, 79, 'C');INSERT INTO grade VALUES (60, 69, 'D');INSERT INTO grade VALUES (0, 59, 'E');SELECT * FROM grade;+------+------+-------+| low  | upp  | grade |+------+------+-------+|   90 |  100 | A     ||   80 |   89 | B     ||   70 |   79 | C     ||   60 |   69 | D     ||    0 |   59 | E     |+------+------+-------+</code></pre><p><strong>查询所有学生的 <code>s_no</code> 、<code>c_no</code> 和 <code>grade</code> 列。</strong></p><p>思路是，使用区间 ( <code>BETWEEN</code> ) 查询，判断学生的成绩 ( <code>degree</code> )  在 <code>grade</code> 表的 <code>low</code> 和 <code>upp</code> 之间。</p><pre class=" language-mysql"><code class="language-mysql">SELECT s_no, c_no, grade FROM score, grade WHERE degree BETWEEN low AND upp;+------+-------+-------+| s_no | c_no  | grade |+------+-------+-------+| 101  | 3-105 | A     || 102  | 3-105 | A     || 103  | 3-105 | A     || 103  | 3-245 | B     || 103  | 6-166 | B     || 104  | 3-105 | B     || 105  | 3-105 | B     || 105  | 3-245 | C     || 105  | 6-166 | C     || 109  | 3-105 | C     || 109  | 3-245 | D     || 109  | 6-166 | B     |+------+-------+-------+</code></pre><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>准备用于测试连接查询的数据：</p><pre class=" language-mysql"><code class="language-mysql">CREATE DATABASE testJoin;CREATE TABLE person (    id INT,    name VARCHAR(20),    cardId INT);CREATE TABLE card (    id INT,    name VARCHAR(20));INSERT INTO card VALUES (1, '饭卡'), (2, '建行卡'), (3, '农行卡'), (4, '工商卡'), (5, '邮政卡');SELECT * FROM card;+------+-----------+| id   | name      |+------+-----------+|    1 | 饭卡      ||    2 | 建行卡    ||    3 | 农行卡    ||    4 | 工商卡    ||    5 | 邮政卡    |+------+-----------+INSERT INTO person VALUES (1, '张三', 1), (2, '李四', 3), (3, '王五', 6);SELECT * FROM person;+------+--------+--------+| id   | name   | cardId |+------+--------+--------+|    1 | 张三   |      1 ||    2 | 李四   |      3 ||    3 | 王五   |      6 |+------+--------+--------+</code></pre><p>分析两张表发现，<code>person</code> 表并没有为 <code>cardId</code> 字段设置一个在 <code>card</code> 表中对应的 <code>id</code> 外键。如果设置了的话，<code>person</code> 中 <code>cardId</code> 字段值为 <code>6</code> 的行就插不进去，因为该 <code>cardId</code> 值在 <code>card</code> 表中并没有。</p><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>要查询这两张表中有关系的数据，可以使用 <code>INNER JOIN</code> ( 内连接 ) 将它们连接在一起。</p><pre class=" language-mysql"><code class="language-mysql">-- INNER JOIN: 表示为内连接，将两张表拼接在一起。-- on: 表示要执行某个条件。SELECT * FROM person INNER JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    |+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的。-- SELECT * FROM person JOIN card on person.cardId = card.id;</code></pre><blockquote><p>注意：<code>card</code> 的整张表被连接到了右边。</p></blockquote><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>完整显示左边的表 ( <code>person</code> ) ，右边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p><pre class=" language-mysql"><code class="language-mysql">-- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。SELECT * FROM person LEFT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      |+------+--------+--------+------+-----------+</code></pre><h4 id="右外链接"><a href="#右外链接" class="headerlink" title="右外链接"></a>右外链接</h4><p>完整显示右边的表 ( <code>card</code> ) ，左边的表如果符合条件就显示，不符合则补 <code>NULL</code> 。</p><pre class=" language-mysql"><code class="language-mysql">SELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+</code></pre><h4 id="全外链接"><a href="#全外链接" class="headerlink" title="全外链接"></a>全外链接</h4><p>完整显示两张表的全部数据。</p><pre class=" language-mysql"><code class="language-mysql">-- MySQL 不支持这种语法的全外连接-- SELECT * FROM person FULL JOIN card on person.cardId = card.id;-- 出现错误：-- ERROR 1054 (42S22): Unknown column 'person.cardId' in 'on clause'-- MySQL全连接语法，使用 UNION 将两张表合并在一起。SELECT * FROM person LEFT JOIN card on person.cardId = card.idUNIONSELECT * FROM person RIGHT JOIN card on person.cardId = card.id;+------+--------+--------+------+-----------+| id   | name   | cardId | id   | name      |+------+--------+--------+------+-----------+|    1 | 张三   |      1 |    1 | 饭卡      ||    2 | 李四   |      3 |    3 | 农行卡    ||    3 | 王五   |      6 | NULL | NULL      || NULL | NULL   |   NULL |    2 | 建行卡    || NULL | NULL   |   NULL |    4 | 工商卡    || NULL | NULL   |   NULL |    5 | 邮政卡    |+------+--------+--------+------+-----------+</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够<strong>保证一个业务的完整性</strong>。</p><p>比如我们的银行转账：</p><pre class=" language-mysql"><code class="language-mysql">-- a -> -100UPDATE user set money = money - 100 WHERE name = 'a';-- b -> +100UPDATE user set money = money + 100 WHERE name = 'b';</code></pre><p>在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。</p><p>因此，在执行多条有关联 SQL 语句时，<strong>事务</strong>可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。</p><h3 id="如何控制事务-COMMIT-ROLLBACK"><a href="#如何控制事务-COMMIT-ROLLBACK" class="headerlink" title="如何控制事务 - COMMIT / ROLLBACK"></a>如何控制事务 - COMMIT / ROLLBACK</h3><p>在 MySQL 中，事务的<strong>自动提交</strong>状态默认是开启的。</p><pre class=" language-mysql"><code class="language-mysql">-- 查询事务的自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+|            1 |+--------------+</code></pre><p><strong>自动提交的作用</strong>：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能<strong>回滚</strong>。</p><p>什么是回滚？举个例子：</p><pre class=" language-mysql"><code class="language-mysql">CREATE DATABASE bank;USE bank;CREATE TABLE user (    id INT PRIMARY KEY,    name VARCHAR(20),    money INT);INSERT INTO user VALUES (1, 'a', 1000);SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+</code></pre><p>可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它<strong>提交</strong>到了数据库中。那么所谓<strong>回滚</strong>的意思就是，撤销执行过的所有 SQL 语句，使其回滚到<strong>最后一次提交</strong>数据时的状态。</p><p>在 MySQL 中使用 <code>ROLLBACK</code> 执行回滚：</p><pre class=" language-mysql"><code class="language-mysql">-- 回滚到最后一次提交ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+</code></pre><p>由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？</p><pre class=" language-mysql"><code class="language-mysql">-- 关闭自动提交SET AUTOCOMMIT = 0;-- 查询自动提交状态SELECT @@AUTOCOMMIT;+--------------+| @@AUTOCOMMIT |+--------------+|            0 |+--------------+</code></pre><p>将自动提交关闭后，测试数据回滚：</p><pre class=" language-mysql"><code class="language-mysql">INSERT INTO user VALUES (2, 'b', 1000);-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示，-- 发生变化的数据并没有真正插入到数据表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+-- 数据表中的真实数据其实还是：+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+-- 由于数据还没有真正提交，可以使用回滚ROLLBACK;-- 再次查询SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 |+----+------+-------+</code></pre><p>那如何将虚拟的数据真正提交到数据库中？使用 <code>COMMIT</code> : </p><pre class=" language-mysql"><code class="language-mysql">INSERT INTO user VALUES (2, 'b', 1000);-- 手动提交数据（持久性），-- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。COMMIT;-- 提交后测试回滚ROLLBACK;-- 再次查询（回滚无效了）SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+</code></pre><blockquote><p><strong>总结</strong></p><ol><li><p><strong>自动提交</strong></p><ul><li><p>查看自动提交状态：<code>SELECT @@AUTOCOMMIT</code> ；</p></li><li><p>设置自动提交状态：<code>SET AUTOCOMMIT = 0</code> 。</p></li></ul></li><li><p><strong>手动提交</strong></p><p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>COMMIT</code> 命令提交事务。</p></li><li><p><strong>事务回滚</strong></p><p><code>@@AUTOCOMMIT = 0</code> 时，使用 <code>ROLLBACK</code> 命令回滚事务。</p></li></ol></blockquote><p><strong>事务的实际应用</strong>，让我们再回到银行转账项目：</p><pre class=" language-mysql"><code class="language-mysql">-- 转账UPDATE user set money = money - 100 WHERE name = 'a';-- 到账UPDATE user set money = money + 100 WHERE name = 'b';SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+</code></pre><p>这时假设在转账时发生了意外，就可以使用 <code>ROLLBACK</code> 回滚到最后一次提交的状态：</p><pre class=" language-mysql"><code class="language-mysql">-- 假设转账发生了意外，需要回滚。ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+</code></pre><p>这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：<code>COMMIT</code> 。</p><h3 id="手动开启事务-BEGIN-START-TRANSACTION"><a href="#手动开启事务-BEGIN-START-TRANSACTION" class="headerlink" title="手动开启事务 - BEGIN / START TRANSACTION"></a>手动开启事务 - BEGIN / START TRANSACTION</h3><p>事务的默认提交被开启 ( <code>@@AUTOCOMMIT = 1</code> ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚：</p><pre class=" language-mysql"><code class="language-mysql">-- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务-- START TRANSACTION;BEGIN;UPDATE user set money = money - 100 WHERE name = 'a';UPDATE user set money = money + 100 WHERE name = 'b';-- 由于手动开启的事务没有开启自动提交，-- 此时发生变化的数据仍然是被保存在一张临时表中。SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+-- 测试回滚ROLLBACK;SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |  1000 ||  2 | b    |  1000 |+----+------+-------+</code></pre><p>仍然使用 <code>COMMIT</code> 提交数据，提交后无法再发生本次事务的回滚。</p><pre class=" language-mysql"><code class="language-mysql">BEGIN;UPDATE user set money = money - 100 WHERE name = 'a';UPDATE user set money = money + 100 WHERE name = 'b';SELECT * FROM user;+----+------+-------+| id | name | money |+----+------+-------+|  1 | a    |   900 ||  2 | b    |  1100 |+----+------+-------+-- 提交数据COMMIT;-- 测试回滚（无效，因为表的数据已经被提交）ROLLBACK;</code></pre><h3 id="事务的-ACID-特征与使用"><a href="#事务的-ACID-特征与使用" class="headerlink" title="事务的 ACID 特征与使用"></a>事务的 ACID 特征与使用</h3><p><strong>事务的四大特征：</strong></p><ul><li><strong>A 原子性</strong>：事务是最小的单位，不可以再分割；</li><li><strong>C 一致性</strong>：要求同一事务中的 SQL 语句，必须保证同时成功或者失败；</li><li><strong>I 隔离性</strong>：事务1 和 事务2 之间是具有隔离性的；</li><li><strong>D 持久性</strong>：事务一旦结束 ( <code>COMMIT</code> ) ，就不可以再返回了 ( <code>ROLLBACK</code> ) 。</li></ul><h3 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h3><p><strong>事务的隔离性可分为四种 ( 性能从低到高 )</strong> ：</p><ol><li><p><strong>READ UNCOMMITTED ( 读取未提交 )</strong></p><p>如果有多个事务，那么任意事务都可以看见其他事务的<strong>未提交数据</strong>。</p></li><li><p><strong>READ COMMITTED ( 读取已提交 )</strong></p><p>只能读取到其他事务<strong>已经提交的数据</strong>。</p></li><li><p><strong>REPEATABLE READ ( 可被重复读 )</strong></p><p>如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。</p></li><li><p><strong>SERIALIZABLE ( 串行化 )</strong></p><p>所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong>。</p></li></ol><p>查看当前数据库的默认隔离级别：</p><pre class=" language-mysql"><code class="language-mysql">-- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。SELECT @@GLOBAL.TRANSACTION_ISOLATION;SELECT @@TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ                | -- MySQL的默认隔离级别，可以重复读。+--------------------------------+-- MySQL 5.xSELECT @@GLOBAL.TX_ISOLATION;SELECT @@TX_ISOLATION;</code></pre><p>修改隔离级别：</p><pre class=" language-mysql"><code class="language-mysql">-- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;-- 查询系统隔离级别，发现已经被修改。SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-UNCOMMITTED               |+--------------------------------+</code></pre><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>测试 <strong>READ UNCOMMITTED ( 读取未提交 )</strong> 的隔离性：</p><pre class=" language-mysql"><code class="language-mysql">INSERT INTO user VALUES (3, '小明', 1000);INSERT INTO user VALUES (4, '淘宝店', 1000);SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+-- 开启一个事务操作数据-- 假设小明在淘宝店买了一双800块钱的鞋子：START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = '小明';UPDATE user SET money = money + 800 WHERE name = '淘宝店';-- 然后淘宝店在另一方查询结果，发现钱已到账。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+</code></pre><p>由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 <code>ROLLBACK</code> 命令，会发生什么？</p><pre class=" language-mysql"><code class="language-mysql">-- 小明所处的事务ROLLBACK;-- 此时无论对方是谁，如果再去查询结果就会发现：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+</code></pre><p>这就是所谓的<strong>脏读</strong>，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。</p><h4 id="读取已提交"><a href="#读取已提交" class="headerlink" title="读取已提交"></a>读取已提交</h4><p>把隔离级别设置为 <strong>READ COMMITTED</strong> ：</p><pre class=" language-mysql"><code class="language-mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| READ-COMMITTED                 |+--------------------------------+</code></pre><p>这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如：</p><pre class=" language-mysql"><code class="language-mysql">-- 正在操作数据事务（当前事务）START TRANSACTION;UPDATE user SET money = money - 800 WHERE name = '小明';UPDATE user SET money = money + 800 WHERE name = '淘宝店';-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中，-- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+-- 假设此时在远程开启了一个新事务，连接到数据库。$ mysql -u root -p12345612-- 此时远程连接查询到的数据只能是已经提交过的SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 |+----+-----------+-------+</code></pre><p>但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如：</p><pre class=" language-mysql"><code class="language-mysql">-- 小张在查询数据的时候发现：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |   200 ||  4 | 淘宝店    |  1800 |+----+-----------+-------+-- 在小张求表的 money 平均值之前，小王做了一个操作：START TRANSACTION;INSERT INTO user VALUES (5, 'c', 100);COMMIT;-- 此时表的真实数据是：SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 |+----+-----------+-------+-- 这时小张再求平均值的时候，就会出现计算不相符合的情况：SELECT AVG(money) FROM user;+------------+| AVG(money) |+------------+|  820.0000  |+------------+</code></pre><p>虽然 <strong>READ COMMITTED</strong> 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是<strong>在读取同一个表的数据时，可能会发生前后不一致的情况。</strong>这被称为<strong>不可重复读现象 ( READ COMMITTED )</strong> 。</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>将隔离级别设置为 <strong>REPEATABLE READ ( 可被重复读取 )</strong> :</p><pre class=" language-mysql"><code class="language-mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| REPEATABLE-READ                |+--------------------------------+</code></pre><p>测试 <strong>REPEATABLE READ</strong> ，假设在两个不同的连接上分别执行 <code>START TRANSACTION</code> :</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 小张 - 成都</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 小王 - 北京</span><span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- 小张 - 成都</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span></code></pre><p>当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。相当于开辟出一条单独的线程。</p><p>无论小张是否执行过 <code>COMMIT</code> ，在小王这边，都不会查询到小张的事务记录，而是只会查询到自己所处事务的记录：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token keyword">user</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-----------+-------+</span><span class="token operator">|</span> id <span class="token operator">|</span> name      <span class="token operator">|</span> money <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-----------+-------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">a</span>         <span class="token operator">|</span>   <span class="token number">900</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">b</span>         <span class="token operator">|</span>  <span class="token number">1100</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span> 小明      <span class="token operator">|</span>  <span class="token number">1000</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> 淘宝店    <span class="token operator">|</span>  <span class="token number">1000</span> <span class="token operator">|</span><span class="token operator">|</span>  <span class="token number">5</span> <span class="token operator">|</span> <span class="token number">c</span>         <span class="token operator">|</span>   <span class="token number">100</span> <span class="token operator">|</span><span class="token operator">+</span><span class="token comment" spellcheck="true">----+-----------+-------+</span></code></pre><p>这是<strong>因为小王在此之前开启了一个新的事务 ( <code>START TRANSACTION</code> ) <strong>，那么</strong>在他的这条新事务的线上，跟其他事务是没有联系的</strong>，也就是说，此时如果其他事务正在操作数据，它是不知道的。</p><p>然而事实是，在真实的数据表中，小张已经插入了一条数据。但是小王此时并不知道，也插入了同一条数据，会发生什么呢？</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token keyword">user</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">-- ERROR 1062 (23000): Duplicate entry '6' for key 'PRIMARY'</span></code></pre><p>报错了，操作被告知已存在主键为 <code>6</code> 的字段。这种现象也被称为<strong>幻读，一个事务提交的数据，不能被其他事务读取到</strong>。</p><h4 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h4><p>顾名思义，就是所有事务的<strong>写入操作</strong>全都是串行化的。什么意思？把隔离级别修改成 <strong>SERIALIZABLE</strong> :</p><pre class=" language-mysql"><code class="language-mysql">SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;SELECT @@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+| @@GLOBAL.TRANSACTION_ISOLATION |+--------------------------------+| SERIALIZABLE                   |+--------------------------------+</code></pre><p>还是拿小张和小王来举例：</p><pre class=" language-mysql"><code class="language-mysql">-- 小张 - 成都START TRANSACTION;-- 小王 - 北京START TRANSACTION;-- 开启事务之前先查询表，准备操作数据。SELECT * FROM user;+----+-----------+-------+| id | name      | money |+----+-----------+-------+|  1 | a         |   900 ||  2 | b         |  1100 ||  3 | 小明      |  1000 ||  4 | 淘宝店    |  1000 ||  5 | c         |   100 ||  6 | d         |  1000 |+----+-----------+-------+-- 发现没有 7 号王小花，于是插入一条数据：INSERT INTO user VALUES (7, '王小花', 1000);</code></pre><p>此时会发生什么呢？由于现在的隔离级别是 <strong>SERIALIZABLE ( 串行化 )</strong> ，串行化的意思就是：假设把所有的事务都放在一个串行的队列中，那么所有的事务都会按照<strong>固定顺序执行</strong>，执行完一个事务后再继续执行下一个事务的<strong>写入操作</strong> ( <strong>这意味着队列中同时只能执行一个事务的写入操作</strong> ) 。</p><p>根据这个解释，小王在插入数据时，会出现等待状态，直到小张执行 <code>COMMIT</code> 结束它所处的事务，或者出现等待超时。</p><p>除开null</p><p>select name from customer where ifnull(referee_id, 0)&lt;&gt; 2</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程</title>
      <link href="/c-sin7/lhsin.cn/2023/02/10/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BA%BF%E7%A8%8B/"/>
      <url>/c-sin7/lhsin.cn/2023/02/10/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程包括以下这几个状态：</p><p>创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、消亡（dead）</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/682616-20161115183635779-1231872003.jpg" alt="img" style="zoom: 67%;" /><p>注意点：</p><p>1、当线程进入就绪状态后，不代表立刻就能获取CPU执行时间</p><p>2、如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。</p><p>3、调用yield方法并不会让线程进入阻塞状态，而是让线程<strong>重回就绪</strong>状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。</p><p>4、wait方法会让线程进入阻塞状态，并且会释放线程占有的锁，并交出CPU执行权限。</p><p>5、调用join方法实际上是调用了Object的wait方法。由于wait方法会让线程释放对象锁，所以join方法同样会让线程释放对一个对象持有的锁。</p><h3 id="Thread类中常用的方法："><a href="#Thread类中常用的方法：" class="headerlink" title="Thread类中常用的方法："></a>Thread类中常用的方法：</h3><p>以下是关系到线程 <em>运行状态</em> 的几个方法：</p><p>1）start方法</p><p>start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。</p><p>2）run方法</p><p>run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意<strong>，继承Thread类必须重写run方法</strong>，在run方法中定义具体要执行的任务。</p><p>3）sleep方法</p><p>sleep方法有两个重载版本：</p><pre><code>sleep(long millis)     //参数为毫秒sleep(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒</code></pre><p>sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。</p><p>但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。</p><p>4）yield方法</p><p>调用yield方法会让<strong>当前线程交出CPU权限</strong>，让CPU去执行其他的线程。它跟sleep方法类似，同样<strong>不会释放锁</strong>。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让<u>拥有相同优先级的线程</u>有获取CPU执行时间的机会。</p><p>5）join方法</p><p>join方法有三个重载版本：</p><pre><code>join()join(long millis)     //参数为毫秒join(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒</code></pre><p>假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的事件。</p><p>6）interrupt方法</p><p>单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，可以用来中断一个正处于阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。</p><p>直接调用interrupt方法可以中断处于阻塞状态的线程，但不能中断正在运行中的线程。</p><p>如果配合isInterrupted()能够中断正在运行的线程，因为调用interrupt方法相当于将中断标志位置为true，那么可以通过调用isInterrupted()判断中断标志是否被置位来中断线程的执行。</p><p>7）stop方法</p><p>stop方法已经是一个废弃的方法，它是一个不安全的方法。因为调用stop方法会直接终止run方法的调用，并且会抛出一个ThreadDeath错误，如果线程持有某个对象锁的话，会完全释放锁，导致对象状态不一致。所以stop方法基本是不会被用到的。</p><p>8）destroy方法</p><p>destroy方法也是废弃的方法。基本不会被使用到。</p><h3 id="以下是关系到线程属性的几个方法"><a href="#以下是关系到线程属性的几个方法" class="headerlink" title="以下是关系到线程属性的几个方法:"></a>以下是关系到线程属性的几个方法:</h3><p>1）getId</p><p>用来得到线程ID</p><p>2）getName和setName</p><p>用来得到或者设置线程名称。</p><p>3）getPriority和setPriority</p><p>用来获取和设置线程优先级。</p><p>4）setDaemon和isDaemon</p><p>用来设置线程是否成为守护线程和判断线程是否是守护线程。</p><p>​    守护线程和用户线程的区别在于：</p><p>​    守护线程依赖于创建它的线程，而用户线程则不依赖。</p><p>​    举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。</p><p>5）public final boolean isAlive()<br>测试线程是否处于活动状态。</p><p>6）public static void yield()<br>暂停当前正在执行的线程对象，并执行其他线程</p><p>7）currentThread()</p><p>用来获取当前线程</p><h3 id="sleep-和-wait-方法解释"><a href="#sleep-和-wait-方法解释" class="headerlink" title="sleep 和 wait 方法解释"></a>sleep 和 wait 方法解释</h3><p>sleep()方法是Thread类里面的，主要的意义就是让当前线程停止执行，让出cpu给其他的线程，但是不会释放对象锁资源以及监控的状态，当指定的时间到了之后又会自动恢复运行状态。</p><p>wait()方法是Object类里面的，主要的意义就是让线程放弃当前的对象的锁，进入等待此对象的等待锁定池，只有针对此对象调动notify方法后本线程才能够进入对象锁定池准备获取对象锁进入运行状态。</p><h3 id="start-和-run-方法解释"><a href="#start-和-run-方法解释" class="headerlink" title="start 和 run 方法解释"></a><strong>start 和 run 方法解释</strong></h3><p>1、start：用start方法来启动线程，真正实现了多线程运行，这时<u>无需等待run方法体代码执行完毕而直接继续执行下面的代码</u>。</p><p>通过调用Thread类的start()方法来启动一个线程，这时此线程处于<strong>就绪（可运行）</strong>状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。<br>2、run： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然<strong>只有主线程</strong>这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。</p><p>总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/716271-20170320112245721-1831918220.jpg" alt="img" style="zoom:67%;" /><h2 id="创建一个线程"><a href="#创建一个线程" class="headerlink" title="创建一个线程"></a>创建一个线程</h2><p>Java 提供了三种创建线程的方法：</p><ul><li>通过实现 Runnable 接口；</li><li>通过继承 Thread 类本身；</li><li>通过 Callable 和 Future 创建线程。</li></ul><p><strong>实现并启动线程有两种方法</strong><br>1、写一个类继承自Thread类，重写run方法。用start方法启动线程<br>2、写一个类实现Runnable接口，实现run方法。用new Thread(Runnable target).start()方法来启动</p><p><strong>多线程原理：</strong></p><p><strong>多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发</strong></p><p>相当于玩游戏机，只有一个游戏机（cpu），可是有很多人要玩，于是，start是排队！等CPU选中你就是轮到你，你就run（），当CPU的运行的时间片执行完，这个线程就继续排队，等待下一次的run（）</p><h3 id="通过实现-Runnable-接口来创建线程"><a href="#通过实现-Runnable-接口来创建线程" class="headerlink" title="通过实现 Runnable 接口来创建线程"></a>通过实现 Runnable 接口来创建线程</h3><p>创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。</p><p>为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。</p><p>在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。</p><p>Thread 定义了几个构造方法，下面的这个是我们经常使用的：</p><pre class=" language-java"><code class="language-java"><span class="token function">Thread</span><span class="token punctuation">(</span>Runnable threadOb<span class="token punctuation">,</span>String threadName<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。</p><p>新线程创建之后，你调用它的 start() 方法它才会运行。</p><h3 id="通过继承Thread来创建线程"><a href="#通过继承Thread来创建线程" class="headerlink" title="通过继承Thread来创建线程"></a>通过继承Thread来创建线程</h3><p>创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。</p><p>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。</p><p>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p><h3 id="通过-Callable-和-Future-创建线程"><a href="#通过-Callable-和-Future-创建线程" class="headerlink" title="通过 Callable 和 Future 创建线程"></a>通过 Callable 和 Future 创建线程</h3><ul><li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</li><li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</li><li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</li><li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</li></ul><h2 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h2><ul><li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</li><li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/c-sin7/lhsin.cn/2023/02/10/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/c-sin7/lhsin.cn/2023/02/10/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h2><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left"><strong>[ABC]</strong></td><td align="left">匹配 <strong>[…]</strong> 中的所有字符<img src="https://www.runoob.com/wp-content/uploads/2014/03/E691DDE1-E5CB-4EA8-8D16-759BD0D2B09D.jpg" alt="img"></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp5">尝试一下 »</a></td></tr><tr><td align="left"><strong>[^ABC]</strong></td><td align="left">匹配除了 <strong>[…]</strong> 中字符的所有字符，<img src="https://www.runoob.com/wp-content/uploads/2014/03/ED971D92-30F4-4768-A2C7-02A84A3A9DEB.jpg" alt="img"></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp6">尝试一下 »</a></td></tr><tr><td align="left"><strong>[A-Z]</strong></td><td align="left">[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。<img src="https://www.runoob.com/wp-content/uploads/2014/03/C5E357BD-65E3-4EB3-9D80-10D096F19287.jpg" alt="img"></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp7">尝试一下 »</a></td></tr><tr><td align="left"><strong>.</strong></td><td align="left">匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]。<img src="https://www.runoob.com/wp-content/uploads/2014/03/0FD7E77D-38A7-43BC-B51A-7DBA23A77756.jpg" alt="img"></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp8">尝试一下 »</a></td></tr><tr><td align="left"><strong>[\s\S]</strong></td><td align="left">匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。<img src="https://www.runoob.com/wp-content/uploads/2014/03/47CA6C59-64CF-433A-909E-1E342349A4E0.jpg" alt="img"></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp9">尝试一下 »</a></td></tr><tr><td align="left"><strong>\w</strong></td><td align="left">匹配字母、数字、下划线。等价于 [A-Za-z0-9_]<img src="https://www.runoob.com/wp-content/uploads/2014/03/F35A5971-3519-4CAE-8BEC-9DE8F4A55257.jpg" alt="img"  /></td><td align="left"><a href="https://www.runoob.com/try/try.php?filename=tryjsref_regexp10">尝试一下 »</a></td></tr></tbody></table><h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\cx</td><td align="left">匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr></tbody></table><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的 <strong>runoo*b</strong> 中的 *****，简单的说就是表示任何字符串的意思。如果要查找字符串中的 ***** 符号，则需要对 ***** 进行转义，即在其前加一个 <em>***，**runo*ob</em>* 匹配字符串 <strong>runo*ob</strong>。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符*<em>*</em> 放在它们前面。下表列出了正则表达式中的特殊字符：</p><table><thead><tr><th align="left">特别字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">$</td><td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 $。</td></tr><tr><td align="left">( )</td><td align="left">标记一个<u>子表达式</u>的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式<strong>零次或多次</strong>。要匹配 * 字符，请使用 *。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式<strong>一次或多次</strong>。要匹配 + 字符，请使用 +。</td></tr><tr><td align="left">.</td><td align="left">匹配<strong>除换行符 \n 之外</strong>的任何单字符。要匹配 . ，请使用 . 。</td></tr><tr><td align="left">[</td><td align="left">标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式<strong>零次或一次</strong>，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td></tr><tr><td align="left">\</td><td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “&quot;，而 ‘(‘ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 ^。</td></tr><tr><td align="left">{</td><td align="left">标记<u>限定符表达式</u>的开始。要匹配 {，请使用 {。</td></tr><tr><td align="left">|</td><td align="left">指明两项之间的一个选择。要匹配 |，请使用 |。</td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 <strong>+</strong> 或 <strong>?</strong> 或 <strong>{n}</strong> 或 <strong>{n,}</strong> 或 <strong>{n,m}</strong> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>定位符用来描述字符串或单词的边界，<strong>^</strong> 和 <strong>$</strong> 分别指字符串的开始与结束，<strong>\b</strong> 描述单词的前或后边界，<strong>\B</strong> 表示非单词边界。</p><p>正则表达式的定位符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，即字与空格间的位置。</td></tr><tr><td align="left">\B</td><td align="left">非单词边界匹配。</td></tr></tbody></table><p>\b单词边界元字符确保只检测整个单词。否则，诸如 “is issued” 或 “this is” 之类的词组将不能正确地被此表达式识别。</p><p> \i 标记指定不区分大小写。</p><p>全局标记 \g 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配</p><p>多行标记 \m 指定换行符的两边可能出现潜在的匹配。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p>用圆括号 <strong>()</strong> 将所有选择项括起来，相邻的选择项之间用 <strong>|</strong> 分隔。</p><p><strong>()</strong> 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)。</p><h2 id="一、校验数字的表达式"><a href="#一、校验数字的表达式" class="headerlink" title="一、校验数字的表达式"></a>一、校验数字的表达式</h2><ul><li>数字：<strong>^[0-9]*$</strong></li><li>n位的数字：<strong>^\d{n}$</strong></li><li>至少n位的数字<strong>：^\d{n,}$</strong></li><li>m-n位的数字：<strong>^\d{m,n}$</strong></li><li>零和非零开头的数字：<strong>^(0|[1-9][0-9]*)$</strong></li><li>非零开头的最多带两位小数的数字：<strong>^([1-9][0-9]*)+(.[0-9]{1,2})?$</strong></li><li>带1-2位小数的正数或负数：<strong>^(-)?\d+(.\d{1,2})$</strong></li><li>正数、负数、和小数：<strong>^(-|+)?\d+(.\d+)?$</strong></li><li>有两位小数的正实数：<strong>^[0-9]+(.[0-9]{2})?$</strong></li><li>有1~3位小数的正实数：<strong>^[0-9]+(.[0-9]{1,3})?$</strong></li><li>非零的正整数：<strong>^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^+?[1-9][0-9]*$</strong></li><li>非零的负整数：<strong>^-[1-9][]0-9”*$ 或 ^-[1-9]\d*$</strong></li><li>非负整数：<strong>^\d+$ 或 ^[1-9]\d*|0$</strong></li><li>非正整数：<strong>^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</strong></li><li>非负浮点数：<strong>^\d+(.\d+)?$ 或 ^[1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0$</strong></li><li>非正浮点数：<strong>^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d*.\d*|0.\d*[1-9]\d*))|0?.0+|0$</strong></li><li>正浮点数：<strong>^[1-9]\d*.\d*|0.\d*[1-9]\d*$ 或 ^(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*))$</strong></li><li>负浮点数：<strong>^-([1-9]\d*.\d*|0.\d*[1-9]\d*)$ 或 ^(-(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*)))$</strong></li><li>浮点数：<strong>^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d*.\d*|0.\d*[1-9]\d*|0?.0+|0)$</strong></li></ul><hr><h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><ul><li>汉字：<strong>^[\u4e00-\u9fa5]{0,}$</strong></li><li>英文和数字：<strong>^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$</strong></li><li>长度为3-20的所有字符：<strong>^.{3,20}$</strong></li><li>由26个英文字母组成的字符串：<strong>^[A-Za-z]+$</strong></li><li>由26个大写英文字母组成的字符串：<strong>^[A-Z]+$</strong></li><li>由26个小写英文字母组成的字符串：<strong>^[a-z]+$</strong></li><li>由数字和26个英文字母组成的字符串：<strong>^[A-Za-z0-9]+$</strong></li><li>由数字、26个英文字母或者下划线组成的字符串：<strong>^\w+$ 或 ^\w{3,20}$</strong></li><li>中文、英文、数字包括下划线：<strong>^[\u4E00-\u9FA5A-Za-z0-9_]+$</strong></li><li>中文、英文、数字但不包括下划线等符号：<strong>^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</strong></li><li>可以输入含有^%&amp;’,;=?$&quot;等字符：**[^%&amp;’,;=?$\x22]+**</li><li>禁止输入含有<del>的字符：**[^</del>]+**</li></ul><hr><h2 id="三、特殊需求表达式"><a href="#三、特殊需求表达式" class="headerlink" title="三、特殊需求表达式"></a>三、特殊需求表达式</h2><ul><li>Email地址：<strong>^\w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*$</strong></li><li>域名：**[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.?**</li><li>InternetURL：**[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$**</li><li>手机号码：<strong>^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$</strong></li><li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<strong>^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$</strong></li><li>国内电话号码(0511-4405222、021-87888822)：<strong>\d{3}-\d{8}|\d{4}-\d{7}</strong></li><li>电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: <strong>((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)</strong></li><li>身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：**(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)**</li><li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<strong>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</strong></li><li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<strong>^[a-zA-Z]\w{5,17}$</strong></li><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：<strong>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$</strong></li><li>强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：<strong>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</strong></li><li>日期格式：<strong>^\d{4}-\d{1,2}-\d{1,2}</strong></li><li>一年的12个月(01～09和1～12)：<strong>^(0?[1-9]|1[0-2])$</strong></li><li>一个月的31天(01～09和1～31)：<strong>^((0?[1-9])|((1|2)[0-9])|30|31)$</strong></li><li>钱的输入格式：<ol><li>有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：<strong>^[1-9][0-9]*$</strong></li><li>这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：<strong>^(0|[1-9][0-9]*)$</strong></li><li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：<strong>^(0|-?[1-9][0-9]*)$</strong></li><li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：<strong>^[0-9]+(.[0-9]+)?$</strong></li><li>必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：<strong>^[0-9]+(.[0-9]{2})?$</strong></li><li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：<strong>^[0-9]+(.[0-9]{1,2})?$</strong></li><li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：<strong>^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</strong></li><li>1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：<strong>^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</strong></li><li>备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</li></ol></li><li>xml文件：<strong>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$</strong></li><li>中文字符的正则表达式：**[\u4e00-\u9fa5]**</li><li>双字节字符：**[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))**</li><li>空白行的正则表达式：<strong>\n\s*\r (可以用来删除空白行)</strong></li><li>HTML标记的正则表达式：**&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)**</li><li>腾讯QQ号：**[1-9][0-9]{4,} (腾讯QQ号从10000开始)**</li><li>中国邮政编码：**[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)**</li><li>IPv4地址：**((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}**</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket</title>
      <link href="/c-sin7/lhsin.cn/2023/02/10/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/Socket/"/>
      <url>/c-sin7/lhsin.cn/2023/02/10/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/Socket/</url>
      
        <content type="html"><![CDATA[<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p><strong>TCP/IP、UDP</strong></p><ol><li><p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。</p></li><li><p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于TCP/IP协议族中的一种。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20190718154523875.png" style="zoom:80%;" /><p><strong>Socket是什么呢？</strong></p><pre><code>Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。</code></pre><p>在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20190718154556909.png" alt="img"  /><p>先从服务器端说起。</p><p>服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。</p><p>在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)</p><p>如果连接成功，这时客户端与服务器端的连接就建立了。</p><p>客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。</p><h1 id="1、网络中进程之间如何通信？"><a href="#1、网络中进程之间如何通信？" class="headerlink" title="1、网络中进程之间如何通信？"></a>1、网络中进程之间如何通信？</h1><p>本地的进程间通信（IPC）有很多种方式，但可以总结为下面4类：</p><ul><li>消息传递（管道、FIFO、消息队列）</li><li>同步（互斥量、条件变量、读写锁、文件和写记录锁、信号量）</li><li>共享内存（匿名的和具名的）</li><li>远程过程调用（Solaris门和Sun RPC）</li></ul><p>本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。</p><p>其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“<strong>ip地址</strong>”可以唯一标识网络中的主机，而传输层的“<strong>协议+端口</strong>”可以唯一标识主机中的应用程序（进程）。</p><p>利用三元组（ip地址，协议，端口）就可以标识网络的进程了。</p><h1 id="2、socket的基本操作"><a href="#2、socket的基本操作" class="headerlink" title="2、socket的基本操作"></a>2、socket的基本操作</h1><p>socket是“open—write/read—close”模式的一种实现，socket提供了这些操作对应的函数接口。下面以TCP为例，介绍几个基本的socket接口函数。</p><h2 id="2-1、socket-函数"><a href="#2-1、socket-函数" class="headerlink" title="2.1、socket()函数"></a>2.1、socket()函数</h2><pre class=" language-vim"><code class="language-vim">int <span class="token function">socket</span><span class="token punctuation">(</span>int domain<span class="token punctuation">,</span> int type<span class="token punctuation">,</span> int protocol<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>socket函数对应于普通文件的打开操作。普通文件的打开操作返回一个文件描述字</p><p>而<strong>socket()<strong>用于创建一个socket描述符（</strong>socket descriptor</strong>），它唯一标识一个socket。</p><p>这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</p><p>正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</p><ul><li><p><strong>domain</strong>：即<strong>协议域</strong>，又称为协议族（family）。</p><p>常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。</p><p>协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</p></li><li><p><strong>type</strong>：指定socket<strong>类型</strong>。</p><p>常用的socket类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</p></li><li><p><strong>protocol</strong>：故名思意，就是<strong>指定协议</strong>。</p><p>常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议</p></li></ul><p>注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</p><p>当我们调用<strong>socket</strong>创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋值一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</p><h2 id="2-2、bind-函数"><a href="#2-2、bind-函数" class="headerlink" title="2.2、bind()函数"></a>2.2、bind()函数</h2><p>正如上面所说bind()函数把一个地址族中的特定地址赋给socket。</p><p>例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</p><pre class=" language-vim"><code class="language-vim">int <span class="token function">bind</span><span class="token punctuation">(</span>int sockfd<span class="token punctuation">,</span> const struct sockaddr <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>函数的三个参数分别为：</p><ul><li><p>sockfd：即socket描述字，它是通过socket()函数创建，唯一标识一个socket。<strong>bind()函数就是将给这个描述字绑定一个名字</strong></p></li><li><p>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，如ipv4对应的是：</p><pre class=" language-c++"><code class="language-c++">struct sockaddr_in &#123;    sa_family_t    sin_family;     in_port_t      sin_port;       struct in_addr sin_addr;   &#125;;struct in_addr &#123;    uint32_t       s_addr;     &#125;;</code></pre><p>ipv6对应的是：</p><pre class=" language-c++"><code class="language-c++">struct sockaddr_in6 &#123;     sa_family_t     sin6_family;        in_port_t       sin6_port;          uint32_t        sin6_flowinfo;      struct in6_addr sin6_addr;          uint32_t        sin6_scope_id;  &#125;;struct in6_addr &#123;     unsigned char   s6_addr[16];    &#125;;</code></pre><p>Unix域对应的是：</p><pre class=" language-c++"><code class="language-c++">#define UNIX_PATH_MAX    108struct sockaddr_un &#123;     sa_family_t sun_family;                    char        sun_path[UNIX_PATH_MAX];   &#125;;</code></pre></li></ul><p>通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；</p><p>而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。</p><p>这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</p><h3 id="网络字节序与主机字节序"><a href="#网络字节序与主机字节序" class="headerlink" title="网络字节序与主机字节序"></a>网络字节序与主机字节序</h3><p><strong>主机字节序</strong></p><p>就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。</p><p>　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。高高低低——小端</p><p>　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p><p><strong>网络字节序</strong>：</p><p>4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。</p><p>即大端字节序。<strong>由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。</strong></p><p>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</p><p>所以： 在将一个地址绑定到socket的时候，请<strong>先将主机字节序转换成为网络字节序</strong>，将其转化为网络字节序再赋给socket。</p><h2 id="2-3、listen-、connect-函数"><a href="#2-3、listen-、connect-函数" class="headerlink" title="2.3、listen()、connect()函数"></a>2.3、listen()、connect()函数</h2><p>如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket</p><p>如果客户端这时调用connect()发出连接请求，服务器端就会接收到这个请求。</p><pre class=" language-c++"><code class="language-c++">int listen(int sockfd, int backlog);int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p>listen函数的第一个参数即为要监听的socket描述字，第二个参数为相应socket可以排队的<strong>最大连接个数</strong>。socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为<strong>被动类型的，等待客户的连接请求</strong>。</p><p>connect函数的第一个参数即为客户端的socket描述字，第二参数为服务器的socket地址，第三个参数为socket地址的长度。客户端通过调用connect函数来建立与TCP服务器的连接。</p><h2 id="2-4、accept-函数"><a href="#2-4、accept-函数" class="headerlink" title="2.4、accept()函数"></a>2.4、accept()函数</h2><p>TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。</p><p>TCP客户端依次调用socket()、connect()之后就想TCP服务器发送了一个连接请求。</p><p>TCP服务器监听到这个请求之后，就会调用accept()函数取接收请求，这样连接就建立好了。</p><p>之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</p><pre class=" language-c++"><code class="language-c++">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></pre><p>accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度。</p><p>如果accpet成功，那么其返回值是<strong>由内核自动生成的一个全新的描述字</strong>，代表与返回客户的TCP连接。</p><p>注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为<strong>监听socket描述字</strong>；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，<strong>它在该服务器的生命周期内一直存在</strong>。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</p><h2 id="2-5、read-、write-等函数"><a href="#2-5、read-、write-等函数" class="headerlink" title="2.5、read()、write()等函数"></a>2.5、read()、write()等函数</h2><p>至此服务器与客户已经建立好连接了。可以调用网络I/O进行读写操作了，即实现了网咯中不同进程之间的通信。</p><p>网络I/O操作有下面几组：</p><ul><li>read()/write()</li><li>recv()/send()</li><li>readv()/writev()</li><li>recvmsg()/sendmsg()</li><li>recvfrom()/sendto()</li></ul><p>推荐使用recvmsg()/sendmsg()函数，这两个函数是最通用的I/O函数</p><p>实际上可以把上面的其它函数都替换成这两个函数。它们的声明如下：</p><pre class=" language-c++"><code class="language-c++">#include ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count);#include #include ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t recv(int sockfd, void *buf, size_t len, int flags);ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,                      const struct sockaddr *dest_addr, socklen_t addrlen);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,                        struct sockaddr *src_addr, socklen_t *addrlen);ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</code></pre><p>read函数是负责从fd中读取内容。</p><p>​    当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。</p><p>​    如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</p><p>write函数将buf中的nbytes字节内容写入文件描述符fd。</p><p>​    成功时返回写的字节数。失败时返回-1，并设置errno变量。</p><p>在网络程序中，当我们向套接字文件描述符写时有俩种可能。</p><p>​    1)write的返回值大于0，表示写了部分或者是 全部的数据。</p><p>​    2)返回的值小于0，此时出现了错误。</p><p>​    如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示 网络连接出现了问题(对方已经关闭了连接)。</p><h2 id="2-6、close-函数"><a href="#2-6、close-函数" class="headerlink" title="2.6、close()函数"></a>2.6、close()函数</h2><p>完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</p><pre class=" language-c++"><code class="language-c++">#include int close(int fd);</code></pre><p>close一个TCP socket的缺省行为时把该socket标记为已关闭，然后立即返回到调用进程。该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。</p><p>注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</p><h1 id="3、socket中TCP的三次握手建立连接详解"><a href="#3、socket中TCP的三次握手建立连接详解" class="headerlink" title="3、socket中TCP的三次握手建立连接详解"></a>3、socket中TCP的三次握手建立连接详解</h1><p>tcp建立连接要进行“三次握手”，即交换三个分组。大致流程如下：</p><ul><li>客户端向服务器发送一个SYN J</li><li>服务器向客户端响应一个SYN K，并对SYN J进行确认ACK J+1</li><li>客户端再想服务器发一个确认ACK K+1</li></ul><p>只有就完了三次握手，但是这个三次握手发生在socket的那几个函数中呢？请看下图：</p><p><a href="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157467258.png"><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0NzYyODYucG5n" alt="image"></a></p><p>socket中发送的TCP三次握手</p><ul><li>当客户端调用connect时，触发了连接请求，向服务器发送了SYN J包，这时connect进入阻塞状态；</li><li>服务器监听到连接请求，即收到SYN J包，调用accept函数接收请求向客户端发送SYN K ，ACK J+1，这时accept进入阻塞状态；</li><li>客户端收到服务器的SYN K ，ACK J+1之后，这时connect返回，并对SYN K进行确认；</li><li>服务器收到ACK K+1时，accept返回，至此三次握手完毕，连接建立。</li></ul><h1 id="4、socket中TCP的四次握手释放连接详解"><a href="#4、socket中TCP的四次握手释放连接详解" class="headerlink" title="4、socket中TCP的四次握手释放连接详解"></a>4、socket中TCP的四次握手释放连接详解</h1><p>上面介绍了socket中TCP的三次握手建立过程，及其涉及的socket函数。</p><p>现在介绍socket中的四次握手释放连接的过程</p><p><a href="http://images.cnblogs.com/cnblogs_com/skynet/201012/201012122157487616.png"><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/aHR0cHM6Ly9pbWFnZXMuY25ibG9ncy5jb20vY25ibG9nc19jb20vc2t5bmV0LzIwMTAxMi8yMDEwMTIxMjIxNTc0OTQ2OTMucG5n" alt="image"></a></p><p>socket中发送的TCP四次握手</p><ul><li><p>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</p></li><li><p>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</p></li><li><p>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</p></li><li><p>接收到这个FIN的源发送端TCP对它进行确认。</p><p>这样每个方向上都有一个FIN和ACK。</p></li></ul><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20190718155008892.png" alt="img"></p></li></ol><p>小明住在上海市长江路幸福小区5#666，现在小明在京东上面买了一部小米10Pro。京东在接到小米的订单后，工作人员从仓库中找到一部小米10Pro（应用层）。工作人员将手机打包好， 交给了京东物流（传输层）。接下来手机就到了转运中心（路由器），转运中心根据时间，成本等一系列因素决定下一步该发往哪一个转运中心(网络层)。决定好接下来发往哪一个转运中心后就开始用货车运输了，那么运输的过程就是数据链路层了，链路层负责将数据从一个端点送到另一个端点。那么货车行驶的道路就是物理层。几经周转，手机安全地送到了小明手上。</p><p>我们将一个小区比作一台计算机，一台计算机里面跑了很多程序，怎么区分程序呢，用的是端口，就好像小区用门牌号区分每一户人家一样。手机送到小明家了，怎么进去呢？从大门进啊，怎么找到大门呢？门牌号呀。不就相当于从互联网来的数据找到接收端计算机后再根据端口判断应该给哪一个程序一样吗。小明家的入口就可以用小区地址+门牌号进行唯一表示，那么同样的道理，程序也可以用IP+端口号进行唯一标识。那么这个程序的入口就被称作Socket。</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存</title>
      <link href="/c-sin7/lhsin.cn/2023/02/10/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BC%93%E5%AD%98/"/>
      <url>/c-sin7/lhsin.cn/2023/02/10/%E6%AF%8F%E5%A4%A9%E5%B0%8F%E7%9F%A5%E8%AF%86/%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>缓存是将==请求的结果==存储在与<strong>原始存储位置</strong>或<strong>临时存储位置</strong>不同的位置的过程，可以避免重复执行相同的操作。<br>基本上，缓存是文件和数据的==临时存储==，从这个新位置访问数据会更快。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li>Web浏览器缓存HTML、CSS、JS和图像，以便在再次请求时更快的访问网站。 </li><li>==CDN存储静态文件==，有助于减少延迟。</li><li>DNS用于获取查询的IP地址，查询结果可以存储在缓存中，因此当我们多次请求IP地址时，==不必再次执行DNS查询==，从而可以更快的访问网页。<h2 id="回收机制（Eviction-policy）"><a href="#回收机制（Eviction-policy）" class="headerlink" title="回收机制（Eviction policy）"></a>回收机制（Eviction policy）</h2>当缓存用完时，需要删除旧缓存项，从而可以缓存新内容。事实上，删除最近最少使用的对象是最流行的方法之一，这个解决方案可以优化缓存中命中请求资源的概率。</li><li><strong>随机替换（RR，Random Replacement）</strong>：正如其字面意思，我们可以随机删除一个条目。</li><li><strong>最少使用次数（LFU，Least frequently used）</strong>：记录一个条目被请求的频率，并删除最不频繁使用的条目。</li><li><strong>最近最少使用（LRU，Least Recently Used）</strong>：在LRU中，删除最近使用次数最少的条目。</li><li><strong>先入先出（FIFO，First In First Out）</strong>：FIFO算法保存对象加载到缓存中的顺序。如果缓存没有命中，从头部取出一个或多个对象，并将一个新的缓存对象插入到队尾。如果缓存命中，保持缓存不变。</li></ul><h2 id="不同的缓存方法"><a href="#不同的缓存方法" class="headerlink" title="不同的缓存方法"></a>不同的缓存方法</h2><ol><li><strong>应用服务器缓存（Application server cache）</strong>：我们可以==直接在应用层==缓存数据。每次向服务发出请求时，如果存在缓存的本地数据，可以快速返回。如果不在缓存中，将从数据库查询数据。</li><li><strong>全局缓存（Global caches）</strong>：在全局缓存中，==所有节点使用相同的单一缓存空间==，每个应用节点以与本地节点相同的方式查询缓存。</li><li><strong>分布式缓存（Distributed cache）</strong>：通常使用==一致性哈希算法==分割缓存数据，==每个节点都拥有部分缓存数据==。如果请求节点正在搜索某一段数据，那么可以很容易的使用哈希函数从分布式缓存中定位信息，以确定数据是否可用。</li><li><strong>内容分发网络（CDN，Content Distribution Network）</strong>:如果我们正在开发的框架还没有大到足以拥有自己的CDN，而我们的页面又需要大量静态媒体，那么租用CDN是最好的选择。使用像apache这样的轻量级HTTP服务器，可以为不同的子域（如“blog.enjoyalgorithms.com”）提供静态媒体服务，并将DNS从我们的服务器切到CDN层。</li><li><strong>客户端缓存（Client-Side Caches）</strong>：客户端缓存直接在浏览器或其他客户端（例如中间网络缓存）中缓存以前请求的文件数据。</li><li><strong>ISP层缓存（ISP layer cache）</strong>:ISP缓存的工作方式与浏览器缓存基本相同。一旦你访问了一个网站，你的ISP可能会缓存这些页面，这样当你下次访问它们时，加载速度会更快。这样做的主要问题是，与浏览器缓存不同，你不能删除这些临时文件，必须等待ISP的缓存过期才能请求文件的新副本。</li></ol><h2 id="缓存失效（Cache-Invalidation）"><a href="#缓存失效（Cache-Invalidation）" class="headerlink" title="缓存失效（Cache Invalidation）"></a>缓存失效（Cache Invalidation）</h2><p>如果数据库中的数据被更改，它在缓存中应该是无效的，否则可能会触发不一致的应用程序操作。当前主要有三种缓存系统设计方案：</p><ol><li><strong>Write through cache</strong>：通过缓存执行写操作，只有当写DB和缓存都成功时，写操作才被验证为成功。在缓存和存储之间，将拥有完全的数据一致性。在崩溃、电源故障或其他系统干扰的情况下，任何东西都不会丢失。然而，在这种情况下，因为要写入两个不同的系统，写入延迟会更高。</li><li><strong>Write around cache</strong>：写操作绕过缓存，直接写入DB。在缓存读取过程中，由于数据不在缓存中，cache miss会增加，缓存设备需要从数据库中读取信息。因此，在快速写入和重新读取数据的应用程序中，这可能会导致更高的读延迟。</li><li><strong>Write back cache</strong>：写操作直接发送给缓存层，一旦缓存的写操作完成，就认为写操作成功。然后缓存异步的将写操作同步到DB。对于写密集型应用，这可以降低写延迟以及提高写吞吐量。但是，因为缓存是写入数据的唯一副本，如果缓存层被关闭，有可能丢失数据。通过在缓存中部署多个可以识别写操作的副本，我们可以尽量减少数据丢失的风险。</li></ol><h1 id="缓存的好处"><a href="#缓存的好处" class="headerlink" title="缓存的好处"></a>缓存的好处</h1><ol><li><strong>提高应用程序性能</strong>—缓存可以用来==提高系统性能和降低API延迟==。</li><li><strong>降低数据库成本</strong>——缓存会占用缓存服务器的额外流量，从而==减少数据库流量==，最终降低数据库成本。</li><li><strong>减轻后端负载</strong>——将相同的请求流量从主服务器卸载到缓存服务器将减轻后端负载。</li><li>**增加读吞吐量(IOPS)**——缓存服务器对缓存数据的响应比主服务器快得多，这增加了读吞吐量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将Hexo部署到云服务器(CentOS)</title>
      <link href="/c-sin7/lhsin.cn/2023/02/09/%E5%B0%86Hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/c-sin7/lhsin.cn/2023/02/09/%E5%B0%86Hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1. 安装git"></a>1. 安装git</h2><p>输入下面命令即可安装</p><pre class=" language-bash"><code class="language-bash">//方法一：<span class="token function">sudo</span> apt <span class="token function">install</span> <span class="token function">git</span>//方法二：yum <span class="token function">install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-develyum <span class="token function">install</span> -y <span class="token function">git</span></code></pre><p>查看git版本</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> --version </code></pre><h2 id="2-配置参数"><a href="#2-配置参数" class="headerlink" title="2. 配置参数"></a>2. 配置参数</h2><p>接下来在git中配置自己的名称和电子邮件地址，可以通过使用以下命令来完成此操作：</p><pre class=" language-.vim"><code class="language-.vim">git config --global user.name "用户名" git config --global user.email "用户邮箱"</code></pre><p>可以通过下面命令查看是否正确配置。</p><pre class=" language-.vim"><code class="language-.vim">git config --list</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209171308239.png" alt="git安装与配置" style="zoom: 80%;" /><h2 id="3-创建一个ssh-key"><a href="#3-创建一个ssh-key" class="headerlink" title="3.创建一个ssh key"></a>3.创建一个ssh key</h2><p>作用：将电脑和github账号联系在一起的密钥，可以十分方便的通过git上传代码。</p><p>获取密钥的方法如下：</p><p>首先在命令行输入cd ~/.ssh，第一次配置会显示没有那个文件或目录，这是正常现象。</p><p>然后在命令行输入ssh-keygen -t rsa -C “邮箱地址”，接下来连按三次回车就可以了。</p><p>命令行代码如下：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209171948768.png" alt="创建ssh key" style="zoom:80%;" /><p>密钥就创建成功了。</p><p>打开/root/.ssh文件夹下id_rsa.pub文件，复制里面的内容</p><h2 id="4-登录GitHub添加ssh-key"><a href="#4-登录GitHub添加ssh-key" class="headerlink" title="4.登录GitHub添加ssh key"></a>4.登录GitHub添加ssh key</h2><p>选择setting里面的SSH and GPG keys选项</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209172417818.png" alt="SSH and GPG keys"></p><p>点击New SSH keys后界面如下图所示，Title是给密钥起一个名字，随便起一个就行，之后把刚刚复制的密钥填写在下边的大框里，点击Add SSH keys即可。</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209172508480.png" alt="New SSH keys"></p><h2 id="5-创建用户并配置初始化仓库"><a href="#5-创建用户并配置初始化仓库" class="headerlink" title="5.创建用户并配置初始化仓库"></a>5.创建用户并配置初始化仓库</h2><p>创建一个 git 仓库</p><pre class=" language-bash"><code class="language-bash"><span class="token function">useradd</span> <span class="token function">git</span> <span class="token function">passwd</span> <span class="token function">git</span> // 设置密码<span class="token function">su</span> <span class="token function">git</span> // 这步很重要，避免文件权限的各种问题<span class="token function">cd</span> /home/git/<span class="token function">mkdir</span> -p project/hexo-blog // 项目存在的真实目录,存放hexo静态文件<span class="token function">mkdir</span> repos <span class="token operator">&amp;&amp;</span> <span class="token function">cd</span> repos // 放置git仓库的文件夹<span class="token function">git</span> init --bare hexo-blog-repo.git// 创建一个裸露的仓库</code></pre><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209175642145.png" alt="配置初始化仓库"></p><h2 id="6-创建钩子函数"><a href="#6-创建钩子函数" class="headerlink" title="6.创建钩子函数"></a>6.创建钩子函数</h2><p> 新建文件夹hexo-blog-repo.git 在文件夹中创建钩子post-receive，把提交到 git 仓库的文件同步到 home/hexo文件夹中</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> hexo-blog-repo.git/hooks //进入hooks文件夹vim post-receive //创建hook钩子函数文件<span class="token punctuation">(</span>git提交时自动部署<span class="token punctuation">)</span>，</code></pre><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209175759880.png" alt="钩子函数"></p><p>编写内容如下：（i进入insert模式，编写完毕后按Esc，连按两次Z保存退出）</p><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> --work-tree<span class="token operator">=</span>/home/git/projects/hexo-blog --git-dir<span class="token operator">=</span>/home/git/repos/hexo-blog-repo checkout -f</code></pre><h2 id="7-修改权限"><a href="#7-修改权限" class="headerlink" title="7.修改权限"></a>7.修改权限</h2><p>chmod用法： 用来修改某个目录或文件的访问权限</p><pre class=" language-bash"><code class="language-bash"><span class="token function">chmod</span> +x post-receive<span class="token keyword">exit</span> // 退出到 root 登录<span class="token function">chown</span> -R git:git /home/git/repos/hexo-blog-repo.git // 添加权限</code></pre><h2 id="8-测试能否拉取"><a href="#8-测试能否拉取" class="headerlink" title="8.测试能否拉取"></a>8.测试能否拉取</h2><p>在本地打开一个终端，以 ssh 的方式登录云服务器</p><p>server_ip：用户的服务器ip</p><pre class=" language-shell"><code class="language-shell">ssh -v git@server_ip// 输入密码 即可成功登录云服务器</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230210135945164.png" alt=" ssh 登录云服务器" style="zoom: 80%;" /><pre class=" language-bash"><code class="language-bash"><span class="token function">git</span> clone git@server_ip:/home/git/repos/hexo-blog-repo.git</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209180030554.png" alt="clone结果" style="zoom:80%;" /><h2 id="9-建立客户端与服务器的-SSH-免密连接"><a href="#9-建立客户端与服务器的-SSH-免密连接" class="headerlink" title="9.建立客户端与服务器的 SSH 免密连接"></a>9.建立客户端与服务器的 SSH 免密连接</h2><p>创建 authorized_keys 以及配置权限</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /home/git/.ssh<span class="token function">touch</span> authorized_keys  //存放客户端的ssh公钥<span class="token punctuation">(</span>id_rsa.pub<span class="token punctuation">)</span><span class="token function">chmod</span> 600 authorized_keys   //配置权限</code></pre><h2 id="10-生成密钥对（已有的请忽略）"><a href="#10-生成密钥对（已有的请忽略）" class="headerlink" title="10.生成密钥对（已有的请忽略）"></a>10.生成密钥对（已有的请忽略）</h2><p>进入你本机的(windows) c:/Users/电脑名称/.ssh 文件夹下，查看是否有名为 <code>id_rsa.pub</code> 和 <code>id_rsa</code> 的文件：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209180411071.png" alt="本机密钥对" style="zoom:67%;" /><p>如果有，请跳过下面 <strong>生成密钥</strong> 这一步：</p><pre class=" language-bash"><code class="language-bash">ssh-keygen -t rsa</code></pre><blockquote><p>中途不管你提示啥，一直Enter就是了，生成成功的话会在控制台打印出一个图案</p></blockquote><h2 id="11-建立-SSH-信任关系（免密登录）"><a href="#11-建立-SSH-信任关系（免密登录）" class="headerlink" title="11.建立 SSH 信任关系（免密登录）"></a>11.建立 SSH 信任关系（免密登录）</h2><pre class=" language-bash"><code class="language-bash">ssh-copy-id -i C:/Users/电脑用户名/.ssh/id_rsa.pub git@server_ip<span class="token function">ssh</span> git@server_ip // 测试能否登录</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209200559093.png" alt="登录情况" style="zoom: 80%;" /><p>注意本地 ssh-keygen生成密钥对时<strong>最好不要对密钥对进行重命名</strong></p><h2 id="12-限制-git-用户的权限"><a href="#12-限制-git-用户的权限" class="headerlink" title="12.限制 git 用户的权限"></a>12.限制 git 用户的权限</h2><p>为了安全起见，最好是将 git 用户的权限设置为只能执行 <strong>git clone , git push</strong> 命令等等：</p><p>/usr/bin/git-shell</p><pre class=" language-bash"><code class="language-bash">// 查看 git-shell 是否在登录方式里面<span class="token function">cat</span> /etc/shells // 查看是否安装<span class="token function">which</span> git-shell//添加第2步显示出来的路径，通常为 /usr/bin/git-shellvim /etc/shells</code></pre><p>/etc/shells内容：</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209201858460.png" alt="/etc/shells内容" style="zoom:80%;" /><p>同时修改 /etc/passwd 文件内容，更改权限：</p><pre class=" language-bash"><code class="language-bash">将原来的:git:x:1002:1002::/home/git:/bin/bash //原来的修改为:git:x:1001:1001::/home/git:/usr/bin/git-shell //修改之后</code></pre><h2 id="13-安装配置-Nginx"><a href="#13-安装配置-Nginx" class="headerlink" title="13.安装配置 Nginx"></a>13.安装配置 Nginx</h2><h4 id="13-1安装"><a href="#13-1安装" class="headerlink" title="13.1安装"></a>13.1安装</h4><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/src <span class="token function">wget</span> <span class="token string">"http://nginx.org/download/nginx-1.17.8.tar.gz"</span> //下载安装文件<span class="token function">tar</span> -xvzf nginx-1.17.8.tar.gz -C <span class="token punctuation">..</span>/<span class="token function">cd</span> <span class="token punctuation">..</span>/nginx-1.17.8./configure --prefix<span class="token operator">=</span>/usr/local/nginx-webServer --with-http_stub_status_module --with-http_ssl_module --with-file-aio --with-http_realip_module <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span> // 编译安装<span class="token function">alias</span> nginx<span class="token operator">=</span><span class="token string">'/usr/local/nginx-webServer/sbin/nginx'</span> //取别名为nginx，方便调用</code></pre><p>根据上面的步骤，安装完成，在控制台输入</p><h4 id="13-2查看版本"><a href="#13-2查看版本" class="headerlink" title="13.2查看版本"></a>13.2查看版本</h4><pre class=" language-bash"><code class="language-bash">nginx -v</code></pre><p>可看到版本信息，代表安装成功</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209202213615.png" alt="nginx版本" style="zoom:80%;" /><h4 id="13-3运行"><a href="#13-3运行" class="headerlink" title="13.3运行"></a>13.3运行</h4><pre class=" language-bash"><code class="language-bash">nginx</code></pre><p>如果80端口被占用</p><h4 id="13-4安装iptables服务"><a href="#13-4安装iptables服务" class="headerlink" title="13.4安装iptables服务"></a>13.4安装iptables服务</h4><p>需要通过防火墙开放对外端口。如果服务器上没有iptables服务，需要安装。如果有，则跳过。</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> iptables-servicessystemctl mask firewalld.servicesystemctl <span class="token function">enable</span> iptables.servicesystemctl <span class="token function">enable</span> ip6tables.service</code></pre><h4 id="13-5配置端口"><a href="#13-5配置端口" class="headerlink" title="13.5配置端口"></a>13.5配置端口</h4><p>进入iptables配置80端口，因为nginx默认是由80端口访问</p><pre class=" language-bash"><code class="language-bash"><span class="token function">vi</span> /etc/sysconfig/iptables</code></pre><p>打开后，默认的配置信息如下（加粗部分为新添加的）：</p><pre class=" language-bash"><code class="language-bash">INPUT ACCEPT <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>:FORWARD ACCEPT <span class="token punctuation">[</span>0:0<span class="token punctuation">]</span>:OUTPUT ACCEPT <span class="token punctuation">[</span>6:696<span class="token punctuation">]</span>-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPTA INPUT -p tcp -m state --state NEW -m tcp --dport 30000:30999 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT</code></pre><p>后续需要开放其它端口，也是在此文件中添加修改即可！</p><p>修改完后，保存退出文件编辑。</p><pre class=" language-bash"><code class="language-bash">:wq</code></pre><h4 id="13-6重启防火墙"><a href="#13-6重启防火墙" class="headerlink" title="13.6重启防火墙"></a>13.6重启防火墙</h4><pre class=" language-bash"><code class="language-bash">systemctl restart iptables.service</code></pre><h4 id="13-7端口占用问题"><a href="#13-7端口占用问题" class="headerlink" title="13.7端口占用问题"></a>13.7端口占用问题</h4><p>1）<strong>先查看80端口被什么占用了</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token function">fuser</span> -n tcp 80</code></pre><p>2）<strong>将占用端口杀掉</strong></p><pre class=" language-bash"><code class="language-bash"><span class="token function">kill</span> -9 进程号</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209203733586.png" alt="杀掉占用端口" style="zoom:80%;" /><h2 id="14-Nginx详细配置"><a href="#14-Nginx详细配置" class="headerlink" title="14.Nginx详细配置"></a>14.Nginx详细配置</h2><p>将 user 修改为 root //避免权限不足无法访问博客目录<br>将 root 解析路径修改为博客目录 /home/git/project/hexo-blog</p><pre class=" language-bash"><code class="language-bash">nginx -s stop //先停止nginx<span class="token function">cd</span> /usr/local/nginx-webServer/confvim nginx.conf //打开配置文件nginx -s reload //重启nginx</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209213256203.png" alt="Nginx原先配置" style="zoom:80%;" /><p>更改之后</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209213508091.png" alt="Nginx配置更新" style="zoom:80%;" /><h2 id="15-配置站点配置文件"><a href="#15-配置站点配置文件" class="headerlink" title="15.配置站点配置文件"></a>15.配置站点配置文件</h2><p>config.yml 的 deploy:</p><pre class=" language-shel"><code class="language-shel">deploy:  type: git  repo:         server: git@server_ip:/home/git/repos/hexo-blog-repo.git  branch: master</code></pre><p>server_ip : 即你购买的服务器的 IP 地址</p><p>部署</p><pre class=" language-bash"><code class="language-bash">hexo g -d</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230221194613138.png" alt="image-20230221194613138" style="zoom:50%;" /><p><a href="https://zhuanlan.zhihu.com/p/359394085">【Nginx/Hexo】在云服务器上搭建个人博客 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS下安装yum</title>
      <link href="/c-sin7/lhsin.cn/2023/02/09/CentOS%E5%AE%89%E8%A3%85yum/"/>
      <url>/c-sin7/lhsin.cn/2023/02/09/CentOS%E5%AE%89%E8%A3%85yum/</url>
      
        <content type="html"><![CDATA[<h1 id="CentOS下安装yum"><a href="#CentOS下安装yum" class="headerlink" title="CentOS下安装yum"></a>CentOS下安装yum</h1><p>查看已安装的yumrpm -qa|grep yum</p><p>删除已有的yumrpm -aq|grep yum|xargs rpm -e –nodeps</p><p>下载以下安装包wget <a href="http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/pyth">http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/pyth</a></p><h2 id="1-查看已安装的yum"><a href="#1-查看已安装的yum" class="headerlink" title="1.查看已安装的yum"></a>1.查看已安装的yum</h2><pre class=" language-vim"><code class="language-vim">rpm <span class="token operator">-</span><span class="token keyword">qa</span>|<span class="token keyword">grep</span> yum</code></pre><h2 id="2-删除已有的yum"><a href="#2-删除已有的yum" class="headerlink" title="2.删除已有的yum"></a>2.删除已有的yum</h2><pre class=" language-vim"><code class="language-vim">rpm <span class="token operator">-</span>aq|<span class="token keyword">grep</span> yum|xargs rpm <span class="token operator">-</span><span class="token keyword">e</span> <span class="token operator">-</span><span class="token operator">-</span>nodeps </code></pre><h2 id="3-下载所需安装包"><a href="#3-下载所需安装包" class="headerlink" title="3.下载所需安装包"></a>3.下载所需安装包</h2><pre class=" language-vim"><code class="language-vim">wget http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tel<span class="token operator">.</span>mirrors<span class="token operator">.</span><span class="token number">163</span><span class="token operator">.</span><span class="token builtin">com</span><span class="token operator">/</span>centos<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>os<span class="token operator">/</span>x86_64<span class="token operator">/</span>Packages<span class="token operator">/</span><span class="token keyword">python</span><span class="token operator">-</span><span class="token number">2.7</span><span class="token operator">.</span><span class="token number">5</span><span class="token operator">-</span><span class="token number">89</span><span class="token operator">.</span>el7<span class="token operator">.</span>x86_64<span class="token operator">.</span>rpm wget http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tel<span class="token operator">.</span>mirrors<span class="token operator">.</span><span class="token number">163</span><span class="token operator">.</span><span class="token builtin">com</span><span class="token operator">/</span>centos<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>os<span class="token operator">/</span>x86_64<span class="token operator">/</span>Packages<span class="token operator">/</span><span class="token keyword">python</span><span class="token operator">-</span>iniparse<span class="token operator">-</span><span class="token number">0.4</span><span class="token operator">-</span><span class="token number">9</span><span class="token operator">.</span>el7<span class="token operator">.</span>noarch<span class="token operator">.</span>rpm wget http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tel<span class="token operator">.</span>mirrors<span class="token operator">.</span><span class="token number">163</span><span class="token operator">.</span><span class="token builtin">com</span><span class="token operator">/</span>centos<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>os<span class="token operator">/</span>x86_64<span class="token operator">/</span>Packages<span class="token operator">/</span>yum<span class="token operator">-</span><span class="token number">3.4</span><span class="token operator">.</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">168</span><span class="token operator">.</span>el7<span class="token operator">.</span>centos<span class="token operator">.</span>noarch<span class="token operator">.</span>rpmwget http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tel<span class="token operator">.</span>mirrors<span class="token operator">.</span><span class="token number">163</span><span class="token operator">.</span><span class="token builtin">com</span><span class="token operator">/</span>centos<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>os<span class="token operator">/</span>x86_64<span class="token operator">/</span>Packages<span class="token operator">/</span>yum<span class="token operator">-</span>metadata<span class="token operator">-</span>parser<span class="token operator">-</span><span class="token number">1.1</span><span class="token operator">.</span><span class="token number">4</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">.</span>el7<span class="token operator">.</span>x86_64<span class="token operator">.</span>rpmwget http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>tel<span class="token operator">.</span>mirrors<span class="token operator">.</span><span class="token number">163</span><span class="token operator">.</span><span class="token builtin">com</span><span class="token operator">/</span>centos<span class="token operator">/</span><span class="token number">7</span><span class="token operator">/</span>os<span class="token operator">/</span>x86_64<span class="token operator">/</span>Packages<span class="token operator">/</span>yum<span class="token operator">-</span>plugin<span class="token operator">-</span>fastestmirror<span class="token operator">-</span><span class="token number">1.1</span><span class="token operator">.</span><span class="token number">31</span><span class="token operator">-</span><span class="token number">54</span><span class="token operator">.</span>el7_8<span class="token operator">.</span>noarch<span class="token operator">.</span>rpm</code></pre><p>如果找不到以上版本，可以到 <a href="http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/?login=from_csdn">http://tel.mirrors.163.com/centos/7/os/x86_64/Packages/</a> 下载最新版本</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/20210505211959838.png" alt="下载最新版本"></p><h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4.安装"></a>4.安装</h2><pre class=" language-vim"><code class="language-vim">rpm <span class="token operator">-</span>ivh <span class="token keyword">python</span><span class="token operator">-</span><span class="token number">2.7</span><span class="token operator">.</span><span class="token number">5</span><span class="token operator">-</span><span class="token number">89</span><span class="token operator">.</span>el7<span class="token operator">.</span>x86_64<span class="token operator">.</span>rpm <span class="token keyword">python</span><span class="token operator">-</span>iniparse<span class="token operator">-</span><span class="token number">0.4</span><span class="token operator">-</span><span class="token number">9</span><span class="token operator">.</span>el7<span class="token operator">.</span>noarch<span class="token operator">.</span>rpm <span class="token operator">-</span><span class="token operator">-</span>nodeps <span class="token operator">-</span><span class="token operator">-</span>forcerpm <span class="token operator">-</span>ivh yum<span class="token operator">-</span>metadata<span class="token operator">-</span>parser<span class="token operator">-</span><span class="token number">1.1</span><span class="token operator">.</span><span class="token number">4</span><span class="token operator">-</span><span class="token number">10</span><span class="token operator">.</span>el7<span class="token operator">.</span>x86_64<span class="token operator">.</span>rpm <span class="token operator">-</span><span class="token operator">-</span>nodeps <span class="token operator">-</span><span class="token operator">-</span>forcerpm <span class="token operator">-</span>ivh yum<span class="token operator">-</span><span class="token number">3.4</span><span class="token operator">.</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">168</span><span class="token operator">.</span>el7<span class="token operator">.</span>centos<span class="token operator">.</span>noarch<span class="token operator">.</span>rpm yum<span class="token operator">-</span>plugin<span class="token operator">-</span>fastestmirror<span class="token operator">-</span><span class="token number">1.1</span><span class="token operator">.</span><span class="token number">31</span><span class="token operator">-</span><span class="token number">54</span><span class="token operator">.</span>el7_8<span class="token operator">.</span>noarch<span class="token operator">.</span>rpm <span class="token operator">-</span><span class="token operator">-</span>nodeps <span class="token operator">-</span><span class="token operator">-</span>force</code></pre><h2 id="5-更改-yum源"><a href="#5-更改-yum源" class="headerlink" title="5.更改 yum源"></a>5.更改 yum源</h2><ul><li><p>到该网站 <a href="http://mirrors.163.com/.help/centos.html?login=from_csdn">http://mirrors.163.com/.help/centos.html</a> 下载配置文件，重命名为CentOS-Base.repo</p><ul><li><p>首先备份/etc/yum.repos.d/CentOS-Base.repo</p><pre class=" language-vim"><code class="language-vim">mv <span class="token operator">/</span>etc<span class="token operator">/</span>yum<span class="token operator">.</span>repos<span class="token operator">.</span><span class="token keyword">d</span><span class="token operator">/</span>CentOS<span class="token operator">-</span>Base<span class="token operator">.</span>repo <span class="token operator">/</span>etc<span class="token operator">/</span>yum<span class="token operator">.</span>repos<span class="token operator">.</span><span class="token keyword">d</span><span class="token operator">/</span>CentOS<span class="token operator">-</span>Base<span class="token operator">.</span>repo<span class="token operator">.</span><span class="token builtin">backup</span></code></pre></li><li><p>下载对应版本repo文件， 放入/etc/yum.repos.d/（操作前请做好相应备份）</p><p><a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo?login=from_csdn">CentOS7</a></p><p><a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo?login=from_csdn">CentOS6</a></p><p><a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo?login=from_csdn">CentOS5</a></p></li><li><p>运行以下命令生成缓存</p></li></ul><pre class=" language-vim"><code class="language-vim">yum clean <span class="token keyword">all</span>yum makecache</code></pre></li><li><p>修改配置文件</p><ul><li>运行一下命令打开CentOS-Base.repo文件</li></ul><pre class=" language-vim"><code class="language-vim"><span class="token keyword">cd</span> <span class="token operator">/</span>etc<span class="token operator">/</span>yum<span class="token operator">.</span>repos<span class="token operator">.</span><span class="token keyword">d</span> <span class="token keyword">vim</span> CentOS<span class="token operator">-</span>Base<span class="token operator">.</span>repo</code></pre><blockquote><p>也可以通过Xftp7软件编辑，更加方便快捷</p></blockquote><ul><li>将以下配置更换Centos-Base.repo里的内容</li></ul><pre class=" language-vim"><code class="language-vim"># CentOS<span class="token operator">-</span>Base<span class="token operator">.</span>repo## The mirror system uses the connecting IP address of the client and the# <span class="token keyword">update</span> status of each mirror <span class="token keyword">to</span> pick mirrors that are updated <span class="token keyword">to</span> and# geographically <span class="token keyword">close</span> <span class="token keyword">to</span> the client<span class="token operator">.</span>  You should use this <span class="token keyword">for</span> CentOS updates# unless you are manually picking other mirrors<span class="token operator">.</span>## If the mirrorlist<span class="token operator">=</span> does not work <span class="token keyword">for</span> you<span class="token punctuation">,</span> <span class="token keyword">as</span> a fall back you can <span class="token keyword">try</span> the# remarked out baseurl<span class="token operator">=</span> line instead<span class="token operator">.</span>## <span class="token punctuation">[</span>base<span class="token punctuation">]</span>name<span class="token operator">=</span>CentOS<span class="token operator">-</span>$releasever <span class="token operator">-</span> Base#mirrorlist<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrorlist<span class="token operator">.</span>centos<span class="token operator">.</span>org<span class="token operator">/</span><span class="token operator">?</span>release<span class="token operator">=</span>$releasever&amp;arch<span class="token operator">=</span>$basearch&amp;repo<span class="token operator">=</span>osbaseurl<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token operator">.</span>ustc<span class="token operator">.</span>edu<span class="token operator">.</span><span class="token keyword">cn</span><span class="token operator">/</span>centos<span class="token operator">/</span>$releasever<span class="token operator">/</span>os<span class="token operator">/</span>$basearch<span class="token operator">/</span>gpgcheck<span class="token operator">=</span><span class="token number">1</span>gpgkey<span class="token operator">=</span><span class="token keyword">file</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span>etc<span class="token operator">/</span>pki<span class="token operator">/</span>rpm<span class="token operator">-</span>gpg<span class="token operator">/</span>RPM<span class="token operator">-</span>GPG<span class="token operator">-</span>KEY<span class="token operator">-</span>CentOS<span class="token operator">-</span><span class="token number">7</span> #released updates<span class="token punctuation">[</span>updates<span class="token punctuation">]</span>name<span class="token operator">=</span>CentOS<span class="token operator">-</span>$releasever <span class="token operator">-</span> Updates# mirrorlist<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrorlist<span class="token operator">.</span>centos<span class="token operator">.</span>org<span class="token operator">/</span><span class="token operator">?</span>release<span class="token operator">=</span>$releasever&amp;arch<span class="token operator">=</span>$basearch&amp;repo<span class="token operator">=</span>updatesbaseurl<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token operator">.</span>ustc<span class="token operator">.</span>edu<span class="token operator">.</span><span class="token keyword">cn</span><span class="token operator">/</span>centos<span class="token operator">/</span>$releasever<span class="token operator">/</span>updates<span class="token operator">/</span>$basearch<span class="token operator">/</span>gpgcheck<span class="token operator">=</span><span class="token number">1</span>gpgkey<span class="token operator">=</span><span class="token keyword">file</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span>etc<span class="token operator">/</span>pki<span class="token operator">/</span>rpm<span class="token operator">-</span>gpg<span class="token operator">/</span>RPM<span class="token operator">-</span>GPG<span class="token operator">-</span>KEY<span class="token operator">-</span>CentOS<span class="token operator">-</span><span class="token number">7</span> #additional packages that may <span class="token keyword">be</span> useful<span class="token punctuation">[</span>extras<span class="token punctuation">]</span>name<span class="token operator">=</span>CentOS<span class="token operator">-</span>$releasever <span class="token operator">-</span> Extras# mirrorlist<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrorlist<span class="token operator">.</span>centos<span class="token operator">.</span>org<span class="token operator">/</span><span class="token operator">?</span>release<span class="token operator">=</span>$releasever&amp;arch<span class="token operator">=</span>$basearch&amp;repo<span class="token operator">=</span>extrasbaseurl<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token operator">.</span>ustc<span class="token operator">.</span>edu<span class="token operator">.</span><span class="token keyword">cn</span><span class="token operator">/</span>centos<span class="token operator">/</span>$releasever<span class="token operator">/</span>extras<span class="token operator">/</span>$basearch<span class="token operator">/</span>gpgcheck<span class="token operator">=</span><span class="token number">1</span>gpgkey<span class="token operator">=</span><span class="token keyword">file</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span>etc<span class="token operator">/</span>pki<span class="token operator">/</span>rpm<span class="token operator">-</span>gpg<span class="token operator">/</span>RPM<span class="token operator">-</span>GPG<span class="token operator">-</span>KEY<span class="token operator">-</span>CentOS<span class="token operator">-</span><span class="token number">7</span> #additional packages that extend functionality of existing packages<span class="token punctuation">[</span>centosplus<span class="token punctuation">]</span>name<span class="token operator">=</span>CentOS<span class="token operator">-</span>$releasever <span class="token operator">-</span> Plus# mirrorlist<span class="token operator">=</span>http<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrorlist<span class="token operator">.</span>centos<span class="token operator">.</span>org<span class="token operator">/</span><span class="token operator">?</span>release<span class="token operator">=</span>$releasever&amp;arch<span class="token operator">=</span>$basearch&amp;repo<span class="token operator">=</span>centosplusbaseurl<span class="token operator">=</span>https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token operator">.</span>ustc<span class="token operator">.</span>edu<span class="token operator">.</span><span class="token keyword">cn</span><span class="token operator">/</span>centos<span class="token operator">/</span>$releasever<span class="token operator">/</span>centosplus<span class="token operator">/</span>$basearch<span class="token operator">/</span>gpgcheck<span class="token operator">=</span><span class="token number">1</span>enabled<span class="token operator">=</span><span class="token number">0</span>gpgkey<span class="token operator">=</span><span class="token keyword">file</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token operator">/</span>etc<span class="token operator">/</span>pki<span class="token operator">/</span>rpm<span class="token operator">-</span>gpg<span class="token operator">/</span>RPM<span class="token operator">-</span>GPG<span class="token operator">-</span>KEY<span class="token operator">-</span>CentOS<span class="token operator">-</span><span class="token number">7</span></code></pre><ul><li>配置完成后更新缓存</li></ul><pre class=" language-vim"><code class="language-vim">yum clean <span class="token keyword">all</span>yum makecache</code></pre></li></ul><p>完成以上步骤就可以成功在Linux安装上yum</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> yum </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>picgo图床设置与typora配置</title>
      <link href="/c-sin7/lhsin.cn/2023/01/11/picgo-config/"/>
      <url>/c-sin7/lhsin.cn/2023/01/11/picgo-config/</url>
      
        <content type="html"><![CDATA[<h1 id="picgo图床设置与typora配置"><a href="#picgo图床设置与typora配置" class="headerlink" title="picgo图床设置与typora配置"></a>picgo图床设置与typora配置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    PicGo是一个热门的图床工具，是可以自动把本地图片转换成链接的一款工具，是一款简洁容易操作的图床工具，可以支持微博、腾讯云、Github、阿里云等常用图床，功能可以说非常强大。</p><p>​    Typora是一款跨平台的Markdown编辑器软件，我们常常用它来写笔记或者博客。当使用Typora做笔记时，常常需要上传知识点截图到笔记上。截图图像为本地图像（存储在自己的电脑上，当我们把电脑本地图像进行删除或者误删时，再次打开笔记之前的截图都会显示丢，或者作为博客时，需要部署到远程仓库或服务器，而本地图片显然不能满足我们的需求。</p><p>​    使用PicGo图床工具将截图图像转换成链接或者上传到远程仓库服务器，当下次打开笔记或者查看远程博客时，编辑器会通过链接返回图像，上传后删除本地图像图像也不会丢失。下面将以配置picgo来介绍图床的搭建和配置使用以及介绍typora的图床配置。    </p><h2 id="PicGo下载"><a href="#PicGo下载" class="headerlink" title="PicGo下载"></a>PicGo下载</h2><p>Picgo最新图床工具下载链接：</p><p><a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p>mac系统选择dmg下载，windows选择.exe下载。</p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111200044898.png" alt="图床下载地址"></p><p><strong>此处建议下载稳定的正式版本。</strong></p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111200208026.png" alt="下载最新稳定版本"></p><p><strong>翻到下面进行下载安装。</strong></p><p><img src="https://raw.githubusercontent.com/reasonllh/IMG/main/image-20230111200504555.png" alt="下载对应系统版本"></p><h2 id="图床搭建"><a href="#图床搭建" class="headerlink" title="图床搭建"></a>图床搭建</h2><p>​    下面将介绍和使用==GitHub==来作为==图床==的具体用法。由于在国内有时无法访问GitHub或者速度过慢，可以先搭个梯子。</p><h3 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h3><hr><ol><li><p>首先登陆 GitHub，点击右上角的==+==，点击新建一个**仓库（New repository)**。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111201103490.png" alt="新建仓库"></p></li><li><p>进入页面，设置仓库名称， 选择仓库类型为==公开（Public）==， 由于私有仓库只有自己能够访问，上传图像后无法显示，所以必须时公有仓库。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111201536456.png" alt="设置远程仓库"></p></li><li><p>创建远程仓库后，点击右上角头像，进入设置。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111201701845.png" alt="进入设置"></p></li><li><p>接下来需要在 github 上生成一个token以便于 PicGo  根据令牌信息上传图像到我们的仓库。进入设置后，划到最下面左边栏中选择==开发人员设置（Developer  settings）==进入页面就可以看到 Personal access tokens。</p></li><li><p>点击==Generate new token== 创建一个新token，这里选择classic模式。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111202739291.png" alt="Generate选项"></p></li><li><p>生成令牌，过程如图，选择完后划到最下面按下==Generate token==，即可生成令牌。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111203414659.png" alt="生成令牌过程"></p></li><li><p>生成token如图所示，请注意蓝色框提醒==务必立即复制您的个人访问令牌。你将无法再看到它==，请先将生成的token复制保存下来，退出此页面后将<strong>再也看不到该token</strong>。</p></li></ol><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111203754137.png" alt="复制令牌"></p><h3 id="PicGo配置与使用"><a href="#PicGo配置与使用" class="headerlink" title="PicGo配置与使用"></a>PicGo配置与使用</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><hr><p>​    打开 PicGo，进入github设置</p><ul><li>仓库名格式： <code>用户名/仓库名</code>，例如<code>reasonllh/picgoIMG</code></li><li>分支名：main</li><li>token令牌：刚刚从复制保存的token令牌粘贴到此处</li><li>可以将此设置为默认图床</li></ul><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111204300355.png" alt="picGo图床设置"></p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>​    picgo的图片上传方式就很多了，可以将图片拖拽到此处，也可以上传图片上传，更多的用法可以参考官方文档：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230210214242635.png" alt="picgo图片上传区" style="zoom:67%;" /><hr><h2 id="Typora图床设置"><a href="#Typora图床设置" class="headerlink" title="Typora图床设置"></a>Typora图床设置</h2><p>​    相信很多小伙伴也跟Reason一样有写博客的需求，而typora是一款很多程序员使用的编写markdown格式的软件，下面将介绍typora的图床有关配置。</p><ol><li>打开<code>Typora</code>，点击左上角菜单栏进入==偏好设置==。</li><li>选择 <code>图像</code> ，在<code>上传服务</code>一栏中选择<code>PicGo</code>。注意如果是windows的话还需要选择PicGo.exe的路径，最后点击<code>验证图片上传选项</code>显示成功即Typora配置图床工具完成。</li></ol><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111205309304.png" alt="typora设置"></p><ol><li><p>将图片放入Typora笔记中，右击图像选择==上传图片==即可上传到远程仓库。</p><p> <img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111205714617.png" alt="上传图片选项">               </p></li></ol><p>​                                                            </p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> picGo </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sin</title>
      <link href="/c-sin7/lhsin.cn/2023/01/11/sin/"/>
      <url>/c-sin7/lhsin.cn/2023/01/11/sin/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>about hexo</title>
      <link href="/c-sin7/lhsin.cn/2023/01/11/about%20hexo/"/>
      <url>/c-sin7/lhsin.cn/2023/01/11/about%20hexo/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/blinkfox/hexo-theme-matery">blinkfox/hexo-theme-matery：一个漂亮的hexo博客主题，具有材料设计和响应式设计而成的全面、美观的Hexo主题。国内访问：http://blinkfox.com (github.com)</a></p><p><a href="https://blinkfox.github.io/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-3">Hexo博客主题之hexo-theme-matery的介绍 | 闪烁之狐 (blinkfox.github.io)</a></p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230111222235606.png" alt="image-20230111222235606"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flex弹性盒子</title>
      <link href="/c-sin7/lhsin.cn/2023/01/07/M1D7/"/>
      <url>/c-sin7/lhsin.cn/2023/01/07/M1D7/</url>
      
        <content type="html"><![CDATA[<p>2023.1.7</p><p>[HTML学习](<a href="https://developer.mozilla.org/en-US/docs/Web/HTML">HTML：超文本标记语言|多核 (mozilla.org)</a>)</p><h1 id="Flex弹性盒子学习"><a href="#Flex弹性盒子学习" class="headerlink" title="Flex弹性盒子学习"></a><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">Flex弹性盒子学习</a></h1><h2 id="一、弹性盒子介绍"><a href="#一、弹性盒子介绍" class="headerlink" title="一、弹性盒子介绍"></a>一、弹性盒子介绍</h2><p>​    采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230108152912342.png" alt="Flex 容器" style="zoom:80%;" /><p>​    容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。<strong>项目默认沿主轴排列</strong>。</p><p>​    主轴的开始位置（与边框的交叉点）叫==main start==，结束位置叫做==main end==；</p><p>​    交叉轴的开始位置叫==cross start==，结束位置叫==cross end==。</p><p>​    单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h2 id="二、容器的属性"><a href="#二、容器的属性" class="headerlink" title="二、容器的属性"></a>二、容器的属性</h2><ul><li><strong>flex-direction:row | row-reverse | column | column-reverse;</strong></li><li><strong>flex-wrap:nowrap | wrap | wrap-reverse;</strong></li><li><strong>flex-flow: flex-direction || flex-wrap;</strong></li><li><strong>justify-content:flex-start | flex-end | center | space-between | space-around;</strong></li><li><strong>align-items:flex-start | flex-end | center | baseline | stretch;</strong></li><li><strong>align-content:flex-start | flex-end | center | space-between | space-around | stretch;</strong></li></ul><p><strong>2.1flex-direction主轴的方向（即项目的排列方向）</strong></p><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul><p><strong>2.2flex-wrap换行取值</strong></p><p>​    默认情况下，项目都排在一条线（又称”轴线”）上。如果一条轴线排不下，如何换行。</p><ul><li><p><code>nowrap</code>（默认）：不换行。</p></li><li><p><code>wrap</code>：换行，第一行在上方。</p></li><li><p><code>wrap-reverse</code>：换行，第一行在下方。</p></li></ul><p><strong>2.3<code>flex-flow</code>=<code>flex-direction</code>+<code>flex-wrap</code>，默认值为<code>row nowrap</code></strong></p><p><strong>2.4justify-content项目在主轴上的对齐方式</strong></p><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230108154405854.png" alt="justify-content项目在主轴上的对齐方式" style="zoom:50%;" /><p><strong>2.5align-items项目在交叉轴上如何对齐</strong></p><p>​    具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230108154638899.png" alt="align-items项目在交叉轴上对齐方式" style="zoom:50%;" /><p><strong>2.6align-content定义了多根轴线的对齐方式</strong></p><p>​    如果项目只有一根轴线，该属性不起作用。</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230108155228637.png" alt="align-content在多根轴线上的对齐方式" style="zoom:50%;" /><h2 id="三、项目的属性"><a href="#三、项目的属性" class="headerlink" title="三、项目的属性"></a>三、项目的属性</h2><p>以下6个属性设置在项目上</p><ul><li><code>order:&lt;integer&gt;;/* default 0 */</code></li><li><code>flex-grow</code>:<number>;/* default 0 */</li><li><code>flex-shrink</code>:<number>; /* default 1 */</li><li><code>flex-basis</code>:<length> | auto; /* default auto */</li><li><code>flex</code>:none | [ &lt;’flex-grow’&gt; &lt;’flex-shrink’&gt;? || &lt;’flex-basis’&gt; ]</li><li><code>align-self</code>:auto | flex-start | flex-end | center | baseline | stretch;</li></ul><p><strong>3.1order项目的排列顺序</strong></p><p>​    数值越小，排列越靠前，默认为0。</p><p><strong>3.2flex-grow项目的放大比例</strong></p><p>​    默认为<code>0</code>，即如果存在剩余空间，也不放大</p><p>​    如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。</p><p>​    如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><p><strong>3.3flex-shrink项目的缩小比例</strong></p><p>​    默认为1，即如果空间不足，该项目将缩小。</p><p>​    如果所有项目的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小。</p><p>​    如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。</p><p><strong>3.4flex-basis在分配多余空间之前，项目占据的主轴空间</strong></p><p>​    浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><p>​    它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><p><strong>3.5 flex=<code>flex-grow</code>+<code>flex-shrink</code> + <code>flex-basis</code></strong></p><p>​    默认值为<code>0 1 auto</code>。后两个属性可选。</p><p>​    该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>​    建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><p><strong>3.6 align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性</strong></p><p>​    <code>align-self</code>属性默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/bg2015071016.png" alt="align-self允许单个项目有不一样的对齐方式" style="zoom:50%;" /><p>​    该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/c-sin7/lhsin.cn/2022/03/01/SpringBoot%E8%AE%B2%E4%B9%89/"/>
      <url>/c-sin7/lhsin.cn/2022/03/01/SpringBoot%E8%AE%B2%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h3 id="课程内容说明"><a href="#课程内容说明" class="headerlink" title="课程内容说明"></a>课程内容说明</h3><table><thead><tr><th>学习者</th><th>课程单元</th></tr></thead><tbody><tr><td><strong>小白</strong></td><td><font color="#ff0000"><b>基础篇</b></font></td></tr><tr><td><strong>初学者</strong></td><td><font color="#cc0000"><b>应用篇</b></font>（  运维实用篇  &amp;  开发实用篇  ）</td></tr><tr><td><strong>开发者</strong></td><td><font color="#990000"><b>原理篇</b></font></td></tr></tbody></table><p>​        每个课程单元内容设置不同，目标也不一样，作为学习者如果想达成最佳的学习效果，最好明确自己的学习目标再进行学习，这样目标明确，学习的时候能够更轻松，你就不会在学习的时候纠结如下的问题了。比如学着<font color="#ff0000"><b>基础篇</b></font>在那想，这个东西是个什么原理啊？这个东西是这么用的，那个东西该怎么用啊？因为原理性的内容统一放置到了<font color="#990000"><b>原理篇</b></font>讲解了，应用相关的内容统一放到<font color="#cc0000"><b>应用篇</b></font>里面讲解，你在<font color="#ff0000"><b>基础篇</b></font>阶段纠结也没有用，这一部分不讲这些知识，在<font color="#ff0000"><b>基础篇</b></font>先把SpringBoot的基础使用掌握完再说后面的知识吧。</p><p>​        此外还有一点需要说明的是，目前SpringBoot技术发展速度很快，更新速度也很快，因此后续还会对本套课程进行持续更新，特此在三个课程单元的基础上追加一个<strong>番外篇</strong>。番外篇的设置为了解决如下问题：</p><ul><li>持续更新SpringBoot后续发展出现的新技术</li><li>讲解部分知识点规模较大的支线知识（例如WebFlux）</li><li>扩展非实用性知识，扩展学习者视野</li></ul><p>​        每一个课程单元的学习目标如下，请各位查收，在学习的过程中可以阶段性的给自己提个问题，下面列出来的这些学习目标你是否达成了，可以检验你的学习成果。</p><table><thead><tr><th>课程单元</th><th>学习目标</th></tr></thead><tbody><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>能够创建SpringBoot工程<br/>基于SpringBoot实现ssm/ssmp整合</td></tr><tr><td><font color="#cc0000"><b>应用篇</b></font></td><td>能够掌握SpringBoot程序多环境开发<br/>能够基于Linux系统发布SpringBoot工程<br/>能够解决线上灵活配置SpringBoot工程的需求<br/>能够基于SpringBoot整合任意第三方技术</td></tr><tr><td><font color="#990000"><b>原理篇</b></font></td><td>掌握SpringBoot内部工作流程<br/>理解SpringBoot整合第三方技术的原理<br/>实现自定义开发整合第三方技术的组件</td></tr><tr><td><strong>番外篇</strong></td><td>掌握SpringBoot整合非常见的第三方技术<br/>掌握相同领域的更多的解决方案，并提升同领域方案设计能力</td></tr></tbody></table><p>​        整体课程包含的内容就是这些啦，要想完成前面这些内容的学习，顺利的达成学习目标，有些东西还是要提前和大家说清楚的。SpringBoot课程不像是Java基础，不管你有没有基础，都可以听一听，这个课程还真不行，需要一定的前置知识。下面给大家列表一些前置知识，如果还有不太会的，需要想办法快速补救一下。</p><h3 id="课程前置知识说明"><a href="#课程前置知识说明" class="headerlink" title="课程前置知识说明"></a>课程前置知识说明</h3><table><thead><tr><th>课程单元</th><th>前置知识</th><th>要求</th></tr></thead><tbody><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>Java基础语法</td><td>面向对象，封装，继承，多态，类与接口，集合，IO，网络编程等</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>Spring与SpringMVC</td><td>知道Spring是用来管理bean，能够基于Restful实现页面请求交互功能</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>Mybatis与Mybatis-Plus</td><td>基于Mybatis和MybatisPlus能够开发出包含基础CRUD功能的标准Dao模块</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>数据库MySQL</td><td>能够读懂基础CRUD功能的SQL语句</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>服务器</td><td>知道服务器与web工程的关系，熟悉web服务器的基础配置</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>maven</td><td>知道maven的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承</td></tr><tr><td><font color="#ff0000"><b>基础篇</b></font></td><td>web技术（含vue，ElementUI)</td><td>知道vue如何发送ajax请求，如何获取响应数据，如何进行数据模型双向绑定</td></tr><tr><td><font color="#cc0000"><b>应用篇</b></font></td><td>Linux（CenterOS7）</td><td>熟悉常用的Linux基础指令，熟悉Linux系统目录结构</td></tr><tr><td><font color="#cc0000"><b>应用篇</b></font></td><td>实用开发技术</td><td>缓存：Redis、MongoDB、……<br/>消息中间件:RocketMq、RabbitMq、……</td></tr><tr><td><font color="#990000"><b>原理篇</b></font></td><td>Spring</td><td>了解Spring加载bean的各种方式<br/>知道Spring容器底层工作原理，能够阅读简单的Spring底层源码</td></tr></tbody></table><p>​        看着略微有点多，其实还好吧，如果个别技术真的不会，在学习课程的时候多用心听就好，基础篇是可以跟着学下来了，后面的实用篇和原理篇就比较难了。比如我要在Linux系统下操作，命令我就直接使用了，然后你看不懂可能学习起来就比较心累了。</p><p>​        课程安排就说到这里了，下面进入到SpringBoot<font color="#ff0000"><b>基础篇</b></font>的学习</p><h1 id="SpringBoot基础篇"><a href="#SpringBoot基础篇" class="headerlink" title="SpringBoot基础篇"></a>SpringBoot基础篇</h1><p>​        在基础篇中，我给学习者的定位是先上手，能够使用SpringBoot搭建基于SpringBoot的web项目开发，所以内容设置较少，主要包含如下内容：</p><ul><li>SpringBoot快速入门</li><li>SpringBoot基础配置</li><li>基于SpringBoot整合SSMP</li></ul><h2 id="JC-1-快速上手SpringBoot"><a href="#JC-1-快速上手SpringBoot" class="headerlink" title="JC-1.快速上手SpringBoot"></a>JC-1.快速上手SpringBoot</h2><p>​        学习任意一项技术，首先要知道这个技术的作用是什么，不然学完以后，你都不知道什么时候使用这个技术，也就是技术对应的应用场景。SpringBoot技术由Pivotal团队研发制作，功能的话简单概括就是加速Spring程序的开发，这个加速要从如下两个方面来说</p><ul><li>Spring程序初始搭建过程</li><li>Spring程序的开发过程</li></ul><p>​    通过上面两个方面的定位，我们可以产生两个模糊的概念：</p><ol><li>SpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件/配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子</li><li>SpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？</li></ol><p>​    带着上面这些疑问我们就着手第一个SpringBoot程序的开发了，看看到底使用SpringBoot技术能简化开发到什么程度。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        如果对Spring程序的基础开发不太懂的小伙伴，看到这里可以弃坑了，下面的内容学习需要具备Spring技术的知识，硬着头皮学不下去的。</p><h3 id="JC-1-1-SpringBoot入门程序制作（一）"><a href="#JC-1-1-SpringBoot入门程序制作（一）" class="headerlink" title="JC-1-1.SpringBoot入门程序制作（一）"></a>JC-1-1.SpringBoot入门程序制作（一）</h3><p>​        下面让我们开始做第一个SpringBoot程序吧，本课程基于Idea2020.3版本制作，使用的Maven版本为3.6.1，JDK版本为1.8。如果你的环境和上述环境不同，可能在操作界面和操作过程中略有不同，只要软件匹配兼容即可（说到这个Idea和Maven，它们两个还真不是什么版本都能搭到一起的，说多了都是泪啊）。</p><p>​        下面使用SpringBoot技术快速构建一个SpringMVC的程序，通过这个过程体会<font color="#ff0000"><b>简化</b></font>二字的含义。</p><p><strong>步骤①</strong>：创建新模块，选择Spring Initializr，并配置模块相关基础信息</p><p><img src="img%5Cimage-20211116125259385.png" alt="image-20211116125259385"></p><p>​        <font color="#ff0000"><b>特别关注</b></font>：第3步点击Next时，Idea需要联网状态才可以进入到后面那一页，如果不能正常联网，就无法正确到达右面那个设置页了，会一直<font color="#ff0000"><b>联网</b></font>转转转。</p><p>​        <font color="#ff0000"><b>特别关注</b></font>：第5步选择java版本和你计算机上安装的JDK版本匹配即可，但是最低要求为JDK8或以上版本，推荐使用8或11。</p><p><strong>步骤②</strong>：选择当前模块需要使用的技术集</p><p><img src="img%5Cimage-20211116125615728.png" alt="image-20211116125615728"></p><p>​        按照要求，左侧选择web，然后在中间选择Spring Web即可，选完右侧就出现了新的内容项，这就表示勾选成功了。</p><p>​        <font color="#ff0000"><b>关注</b></font>：此处选择的SpringBoot的版本使用默认的就可以了，需要说一点，SpringBoot的版本升级速度很快，可能昨天创建工程的时候默认版本是2.5.4，今天再创建工程默认版本就变成2.5.5了，差别不大，无需过于纠结，并且还可以到配置文件中修改对应的版本。</p><p><strong>步骤③</strong>：开发控制器类</p><pre class=" language-JAVA"><code class="language-JAVA">//Rest模式@RestController@RequestMapping("/books")public class BookController &#123;    @GetMapping    public String getById()&#123;        System.out.println("springboot is running...");        return "springboot is running...";    &#125;&#125;</code></pre><p>​        入门案例制作的SpringMVC的控制器基于Rest风格开发，当然此处使用原始格式制作SpringMVC的程序也是没有问题的，上例中的@RestController与@GetMapping注解是基于Restful开发的典型注解。</p><p>​        <font color="#ff0000"><b>关注</b></font>：做到这里SpringBoot程序的最基础的开发已经做完了，现在就可以正常的运行Spring程序了。可能有些小伙伴会有疑惑，Tomcat服务器没有配置，Spring也没有配置，什么都没有配置这就能用吗？这就是SpringBoot技术的强大之处。关于内部工作流程后面再说，先专心学习开发过程。</p><p><strong>步骤④</strong>：运行自动生成的Application类</p><p><img src="img%5Cimage-20211116130152452.png" alt="image-20211116130152452"></p><p>​        使用带main方法的java程序的运行形式来运行程序，运行完毕后，控制台输出上述信息。</p><p>​        不难看出，运行的信息中包含了8080的端口，Tomcat这种熟悉的字样，难道这里启动了Tomcat服务器？是的，这里已经启动了。那服务器没有配置，哪里来的呢？后面再说。现在你就可以通过浏览器访问请求的路径，测试功能是否工作正常了。</p><pre class=" language-JAVA"><code class="language-JAVA">访问路径：    http://localhost:8080/books</code></pre><p>​        是不是感觉很神奇？当前效果其实依赖的底层逻辑还是很复杂的，但是从开发者角度来看，目前只有两个文件展现到了开发者面前。</p><ul><li><p>pom.xml</p><p>这是maven的配置文件，描述了当前工程构建时相应的配置信息。</p><pre class=" language-XML"><code class="language-XML"><?xml version="1.0" encoding="UTF-8"?><project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">    <modelVersion>4.0.0</modelVersion>    <parent>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-parent</artifactId>        <version>2.5.4</version>    </parent>    <groupId>com.itheima</groupId>    <artifactId>springboot_01_01_quickstart</artifactId>    <version>0.0.1-SNAPSHOT</version>    <dependencies>        <dependency>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-starter-web</artifactId>        </dependency>        <dependency>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-starter-test</artifactId>            <scope>test</scope>        </dependency>    </dependencies></project></code></pre><p>配置中有两个信息需要关注，一个是parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说。</p></li><li><p>Application类</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;</code></pre><p>这个类功能很简单，就一句代码，前面运行程序就是运行的这个类。</p></li></ul><p>​       到这里我们可以大胆推测一下，如果上面这两个文件没有的话，SpringBoot肯定没法玩，看来核心就是这两个文件了。由于是制作第一个SpringBoot程序，先不要关注这两个文件的功能，后面详细讲解内部工作流程。</p><p>​       通过上面的制作，我们不难发现，SpringBoot程序简直太好写了，几乎什么都没写，功能就有了，这也是SpringBoot技术为什么现在这么火的原因，和Spring程序相比，SpringBoot程序在开发的过程中各个层面均具有优势。</p><table><thead><tr><th><strong>类配置文件</strong></th><th><strong>Spring</strong></th><th><strong>SpringBoot</strong></th></tr></thead><tbody><tr><td>pom文件中的坐标</td><td><strong>手工添加</strong></td><td><strong>勾选添加</strong></td></tr><tr><td>web3.0配置类</td><td><strong>手工制作</strong></td><td><strong>无</strong></td></tr><tr><td>Spring/SpringMVC配置类</td><td><strong>手工制作</strong></td><td><strong>无</strong></td></tr><tr><td>控制器</td><td><strong>手工制作</strong></td><td><strong>手工制作</strong></td></tr></tbody></table><p>​        一句话总结一下就是<font color="#ff0000"><b>能少写就少写</b></font>，<font color="#ff0000"><b>能不写就不写</b></font>，这就是SpringBoot技术给我们带来的好处，行了，现在你就可以动手做一做SpringBoot程序了，看看效果如何，是否真的帮助你简化开发了。</p><p><strong>总结</strong></p><ol><li>开发SpringBoot程序在Idea工具中基于联网的前提下可以根据向导快速制作</li><li>SpringBoot程序需要依赖JDK，版本要求最低为JDK8</li><li>SpringBoot程序中需要使用某种功能时可以通过勾选的形式选择技术，也可以手工添加对应的要使用的技术（后期讲解）</li><li>运行SpringBoot程序通过运行Application程序进行</li></ol><p><strong>思考</strong></p><p>​        前面制作的时候说过，这个过程必须联网才可以进行，但是有些时候你会遇到一些莫名其妙的问题，比如基于Idea开发时，你会发现你配置了一些坐标，然后Maven下载对应东西的时候死慢死慢的，甚至还会失败。其实这种现象和Idea这款IDE工具有关，万一Idea不能正常访问网络的话，我们是不是就无法制作SpringBoot程序了呢？咱们下一节再说。</p><h3 id="JC-1-2-SpringBoot入门程序制作（二）"><a href="#JC-1-2-SpringBoot入门程序制作（二）" class="headerlink" title="JC-1-2.SpringBoot入门程序制作（二）"></a>JC-1-2.SpringBoot入门程序制作（二）</h3><p>​        如果Idea不能正常联网，这个SpringBoot程序就无法制作了吗？开什么玩笑，世上IDE工具千千万，难道SpringBoot技术还必须基于Idea来做了？这是不可能的。开发SpringBoot程序可以不基于IDE工具进行，在SpringBoot官网中可以直接创建SpringBoot程序。</p><p>​        SpringBoot官网和Spring的官网是在一起的，都是  spring.io  。你可以通过项目一级一级的找到SpringBoot技术的介绍页，然后在页面中间部位找到如下内容</p><img src="img\image-20211122150444816.png" alt="image-20211122150444816" style="zoom: 67%;" /><p><strong>步骤①</strong>：点击<strong>Spring Initializr</strong>后进入到创建SpringBoot程序界面，接下来就是输入信息的过程，和在Idea中制作是一样的，只是界面发生了变化，根据自己的要求，在左侧选择对应信息和输入对应的信息。</p><img src="img\image-20211122150608039.png" alt="image-20211122150608039"  /><p><strong>步骤②</strong>：右侧的<strong>ADD DEPENDENCIES</strong>用于选择使用何种技术，和之前勾选的Spring WEB是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面。</p><img src="img\image-20211122161257361.png" alt="image-20211122161257361" style="zoom:50%;" /><p><strong>步骤③</strong>：所有信息设置完毕后，点击下面左侧<strong>GENERATE</strong>按钮，生成一个文件包。</p><p><img src="img%5Cimage-202111221615480212.png" alt="image-20211122161548022"></p><p><strong>步骤④</strong>：保存后得到一个压缩文件，这个文件就是创建的SpringBoot工程        </p><p><img src="img%5Cimage-20211122161709478.png" alt="image-20211122161709478"></p><p><strong>步骤⑤</strong>：解压缩此文件得到工程目录，在Idea中导入即可直接使用，和之前在Idea环境下根据向导创建的工程完全一样，你可以创建一个Controller测试一下当前工程是否可用。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        做到这里其实可以透漏一个小秘密，Idea工具中创建SpringBoot工程其实连接的就是SpringBoot的官网，还句话说这种方式和第一种方式是一模一样的，只不过Idea把界面给整合了一下，读取Spring官网信息，然后展示到Idea界面中而已，可以通过如下信息比对一下</p><p><strong>Idea中创建工程时默认选项</strong></p><img src="img\image-20211122162443035.png" alt="image-20211122162443035" style="zoom: 67%;" /><p><strong>SpringBoot官网创建工程时对应的地址</strong></p><p>​        看看SpringBoot官网创建工程的URL地址，是不是和Idea中使用的URL地址是一样的？</p><img src="img\image-20211122162820719.png" alt="image-20211122162820719"  /><p><strong>总结</strong></p><ol><li><p>打开SpringBoot官网，选择<strong>Quickstart Your Project</strong>中的Spring Initializr。</p><img src="img\image-20211122150444816.png" alt="image-20211122150444816" style="zoom: 67%;" /></li><li><p>创建工程。</p><img src="img\image-20211122150608039.png" alt="image-20211122150608039"  /></li><li><p>保存项目文件。</p><p><img src="img%5Cimage-20211122161548022.png" alt="image-20211122161548022"></p></li><li><p>解压项目，通过IDE导入项目后进行编辑使用。</p></li></ol><p><strong>思考</strong></p><p>​        现在创建工程靠的是访问国外的Spring主站，但是互联网信息的访问是可以被约束的，如果一天这个网站你在国内无法访问了，那前面这两种方式就无法创建SpringBoot工程了，这时候又该怎么解决这个问题呢？咱们下一节再说。</p><h3 id="JC-1-3-SpringBoot入门程序制作（三）"><a href="#JC-1-3-SpringBoot入门程序制作（三）" class="headerlink" title="JC-1-3.SpringBoot入门程序制作（三）"></a>JC-1-3.SpringBoot入门程序制作（三）</h3><p>​        前面提到网站如果被限制访问了，该怎么办？开动脑筋想一想，不管是方式一还是方式二其实走的都是同一个路线，就是通过SpringBoot官网创建SpringBoot工程，假如国内有这么一个网站也能提供这样的功能，是不是就解决了呢？必然的嘛，新的问题又来了，国内有提供这样功能的网站吗？还真有，阿里提供了一个，下面问题就简单了，网址告诉我们就OK了，没错，就是这样。</p><p>​        创建工程时，切换选择starter服务路径，然后手工输入阿里云地址即可，地址：<a href="http://start.aliyun.com或https//start.aliyun.com">http://start.aliyun.com或https://start.aliyun.com</a></p><p><img src="img%5Cimage-20211122163605950.png" alt="image-20211122163605950"></p><p>​        阿里为了便于自己公司开发使用，特此在依赖坐标中添加了一些阿里自主的技术，也是为了推广自己的技术吧，所以在依赖选择列表中，你有了更多的选择。此外，阿里提供的地址更符合国内开发者的使用习惯，里面有一些SpringBoot官网上没有给出的坐标，大家可以好好看一看。</p><p><img src="img%5Cimage-20211122163937408.png" alt="image-20211122163937408"></p><p>​        不过有一点需要说清楚，阿里云地址默认创建的SpringBoot工程版本是<font color="#ff0000"><b>2.4.1</b></font>，所以如果你想更换其他的版本，创建项目后在pom文件中手工修改即可，别忘了刷新一下，加载新版本信息。</p><p>​        <font color="#ff0000"><b>注意</b></font>：阿里云提供的工程创建地址初始化完毕后和使用SpringBoot官网创建出来的工程略有区别，主要是在配置文件的形式上有区别,这个信息在后面讲解SpringBoot程序的执行流程时给大家揭晓。</p><p><strong>总结</strong></p><ol><li>选择start来源为自定义URL</li><li>输入阿里云starter地址</li><li>创建项目</li></ol><p><strong>思考</strong></p><p>​        做到这里我们已经有了三种方式创建SpringBoot工程，但是每种方式都要求你必须能上网才能创建工程。假如有一天，你加入了一个保密级别比较高的项目组，整个项目组没有外网，这个事情是不是就不能做了呢？咱们下一节再说。</p><h3 id="JC-1-4-SpringBoot入门程序制作（四）"><a href="#JC-1-4-SpringBoot入门程序制作（四）" class="headerlink" title="JC-1-4.SpringBoot入门程序制作（四）"></a>JC-1-4.SpringBoot入门程序制作（四）</h3><p>​        不能上网，还想创建SpringBoot工程，能不能做呢？能做，但是你要先问问自己联网和不联网到底差别是什么？这个差别找到以后，你就发现，你把联网要干的事情都提前准备好，就无需联网了。</p><p>​        联网做什么呢？首先SpringBoot工程也是基于Maven构建的，而Maven工程中如果加载一些工程需要使用又不存在的东西时，就要联网去下载。其实SpringBoot工程创建的时候就是要去下载一些必要的组件。如果把这些东西提前准备好呢？是的，就是这样。</p><p>​        下面就手工创建一个SpringBoot工程，如果需要使用的东西提前保障在maven仓库中存在，整个过程就可以不依赖联网环境了。不过咱们已经用3种方式创建了SprongBoot工程了，所以下面也没什么东西需要下载了。</p><p><strong>步骤①</strong>：创建工程时，选择创建普通Maven工程。</p><img src="img\image-20211122165341684.png" alt="image-20211122165341684" style="zoom:50%;" /><p><strong>步骤②</strong>：参照标准SpringBoot工程的pom文件，书写自己的pom文件即可。</p><pre class=" language-XML"><code class="language-XML"><?xml version="1.0" encoding="UTF-8"?><project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">    <modelVersion>4.0.0</modelVersion>    <parent>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-parent</artifactId>        <version>2.5.4</version>    </parent>    <groupId>com.itheima</groupId>    <artifactId>springboot_01_04_quickstart</artifactId>    <version>1.0-SNAPSHOT</version>    <properties>        <maven.compiler.source>8</maven.compiler.source>        <maven.compiler.target>8</maven.compiler.target>    </properties>    <dependencies>        <dependency>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-starter-web</artifactId>        </dependency>    </dependencies></project></code></pre><p>​        用什么写什么，不用的都可以不写。当然，现在小伙伴们可能还不知道用什么和不用什么，最简单的就是复制粘贴了，随着后面的学习，你就知道哪些可以省略了。此处我删减了一些目前不是必须的东西，一样能用。核心的内容有两条，一个是继承了一个父工程，另外添加了一个依赖。</p><p><strong>步骤③</strong>：之前运行SpringBoot工程需要一个类，这个缺不了，自己手写一个就行了，建议按照之前的目录结构来创建，先别玩花样，先学走后学跑。类名可以自定义，关联的名称同步修改即可。</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class);    &#125;&#125;</code></pre><p>​        <font color="#ff0000"><b>关注</b></font>：类上面的注解@SpringBootApplication千万别丢了，这个是核心，后面再介绍。</p><p>​        <font color="#ff0000"><b>关注</b></font>：类名可以自定义，只要保障下面代码中使用的类名和你自己定义的名称一样即可，也就是run方法中的那个class对应的名称。</p><p><strong>步骤④</strong>：下面就可以自己创建一个Controller测试一下是否能用了，和之前没有差别的。</p><p>​        看到这里其实应该能够想明白了，通过向导或者网站创建的SpringBoot工程其实就是帮你写了一些代码，而现在是自己手写，写的内容都一样，仅此而已。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        如果你的计算机上从来没有创建成功过SpringBoot工程，自然也就没有下载过SpringBoot对应的坐标相关的资源，那用手写创建的方式在不联网的情况下肯定该是不能用的。所谓手写，其实就是自己写别人帮你生成的东西，但是引用的坐标对应的资源必须保障maven仓库里面有才行，如果没有，还是要去下载的。</p><p><strong>总结</strong></p><ol><li>创建普通Maven工程</li><li>继承spring-boot-starter-parent</li><li>添加依赖spring-boot-starter-web</li><li>制作引导类Application</li></ol><p>​        到这里已经学习了4种创建SpringBoot工程的方式，其实本质是一样的，都是根据SpringBoot工程的文件格式要求，通过不同时方式生成或者手写得到对应的文件，效果完全一样。</p><h4 id="教你一招：在Idea中隐藏指定文件-文件夹"><a href="#教你一招：在Idea中隐藏指定文件-文件夹" class="headerlink" title="教你一招：在Idea中隐藏指定文件/文件夹"></a>教你一招：在Idea中隐藏指定文件/文件夹</h4><p>​        创建SpringBoot工程时，使用SpringBoot向导也好，阿里云也罢，其实都是为了一个目的，得到一个标准的SpringBoot工程文件结构。这个时候就有新的问题出现了，标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，这一节就来说说这些文件怎么处理。</p><p>​        处理方案无外乎两种，如果你对每一个文件/目录足够了解，有用的留着，没有用的完全可以删除掉。或者不删除，但是看着别扭，就设置文件为看不到就行了。删除不说了，选中后直接Delete掉就好了，这一节说说如何隐藏指定的文件或文件夹信息。</p><p>​        既然是在Idea下做隐藏功能，肯定隶属于Idea的设置，设置方式如下。</p><p><strong>步骤①</strong>：打开设置，【Files】→【Settings】。</p><img src="img\image-20211122173835517.png" alt="image-20211122173835517" style="zoom:80%;" /><p><strong>步骤②</strong>：打开文件类型设置界面后，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示。</p><img src="img\image-20211122174020028.png" alt="image-20211122174020028" style="zoom: 67%;" /><p><strong>步骤③</strong>：添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可。</p><p>​    到这里就做完了，其实就是Idea的一个小功能</p><p><strong>总结</strong></p><ol><li>Idea中隐藏指定文件或指定类型文件<ol><li>【Files】→【Settings】</li><li>【Editor】→【File Types】→【Ignored Files and Folders】</li><li>输入要隐藏的名称，支持*号通配符</li><li>回车确认添加</li></ol></li></ol><h3 id="JC-1-5-SpringBoot简介"><a href="#JC-1-5-SpringBoot简介" class="headerlink" title="JC-1-5.SpringBoot简介"></a>JC-1-5.SpringBoot简介</h3><p>​        入门案例做完了，这个时候回忆一下咱们之前说的SpringBoot的功能是什么还记得吗？加速Spring程序的开发，现在是否深有体会？再来看SpringBoot技术的设计初衷就很容易理解了。</p><p>​        SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来<font color="#ff0000"><b>简化Spring应用的初始搭建以及开发过程</b></font>。</p><p>​        都简化了了哪些东西呢？其实就是针对原始的Spring程序制作的两个方面进行了简化：</p><ul><li>Spring程序缺点<ul><li>依赖设置繁琐<ul><li>以前写Spring程序，使用的技术都要自己一个一个的写，现在不需要了，如果做过原始SpringMVC程序的小伙伴应该知道，写SpringMVC程序，最基础的spring-web和spring-webmvc这两个坐标是必须的，就这还不包含你用json啊等等这些坐标，现在呢？一个坐标搞定了。</li></ul></li><li>配置繁琐<ul><li>以前写配置类或者配置文件，然后用什么东西就要自己写加载bean这些东西，现在呢？什么都没写，照样能用。</li></ul></li></ul></li></ul><blockquote><p>回顾</p><p>​    通过上面两个方面的定位，我们可以产生两个模糊的概念：</p><ol><li>SpringBoot开发团队认为原始的Spring程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的Spring程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的Spring程序至少有一个配置文件或配置类，用来描述Spring的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用Spring大部分情况下是做web开发，如果做web开发的话，还要在加载web环境时加载时加载指定的spring配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件/配置类呢？那换了SpringBoot技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子</li><li>SpringBoot开发团队认为原始的Spring程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的jar包（或坐标）然后将这个技术的核心对象交给Spring容器管理，也就是配置成Spring容器管控的bean就可以了。这都是基本操作啊，难道这些东西SpringBoot也能帮我们简化？</li></ol></blockquote><p>​        再来看看前面提出的两个问题，已经有答案了，都简化了，都不用写了，这就是SpringBoot给我们带来的好处。这些简化操作在SpringBoot中有专业的用语，也是SpringBoot程序的核心功能及优点：</p><ul><li>起步依赖（简化依赖配置）<ul><li>依赖配置的书写简化就是靠这个起步依赖达成的。</li></ul></li><li>自动配置（简化常用工程相关配置）<ul><li>配置过于繁琐，使用自动配置就可以做相应的简化，但是内部还是很复杂的，后面具体展开说。</li></ul></li><li>辅助功能（内置服务器，……）<ul><li>除了上面的功能，其实SpringBoot程序还有其他的一些优势，比如我们没有配置Tomcat服务器，但是能正常运行，这是SpringBoot入门程序中一个可以感知到的功能，也是SpringBoot的辅助功能之一。一个辅助功能都能做的这么6，太牛了。</li></ul></li></ul><p>​        下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为4个方面</p><ul><li>parent</li><li>starter</li><li>引导类</li><li>内嵌tomcat</li></ul><h4 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h4><p>​        SpringBoot关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如A技术的2.0版，在与B技术进行配合使用时，与B技术的3.5版可以合作在一起工作，但是和B技术的3.7版合作开发使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。</p><p>​        SpringBoot一看这种情况so easy啊，于是将所有的技术版本的常见使用方案都给开发者整理了出来，以后开发者使用时直接用它提供的版本方案，就不用担心冲突问题了，相当于SpringBoot做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做<font color="#ff0000"><b>parent</b></font>。</p><p>​        <font color="#ff0000"><b>parent</b></font>自身具有很多个版本，每个<font color="#ff0000"><b>parent</b></font>版本中包含有几百个其他技术的版本号，不同的parent间使用的各种技术的版本号有可能会发生变化。当开发者使用某些技术时，直接使用SpringBoot提供的<font color="#ff0000"><b>parent</b></font>就行了，由<font color="#ff0000"><b>parent</b></font>帮助开发者统一的进行各种技术的版本管理。</p><p>​        比如你现在要使用Spring配合MyBatis开发，没有parent之前怎么做呢？选个Spring的版本，再选个MyBatis的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你Spring的版本发生变化需要切换时，你的MyBatis版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现其他问题。现在这一切工作都可以交给parent来做了。你无需关注这些技术间的版本冲突问题，你只需要关注你用什么技术就行了，冲突问题由<font color="#ff0000"><b>parent</b></font>负责处理。</p><p>​        有人可能会提出来，万一<font color="#ff0000"><b>parent</b></font>给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，<font color="#ff0000"><b>parent</b></font>仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，<font color="#ff0000"><b>使用parent可以帮助开发者进行版本的统一管理。</b></font></p><p>​        <font color="#ff0000"><b>关注</b></font>：parent定义出来以后，并不是直接使用的，仅仅给了开发者一个说明书，但是并没有实际使用，这个一定要确认清楚。</p><p>​        那SpringBoot又是如何做到这一点的呢？可以查阅SpringBoot的配置源码，看到这些定义。</p><ul><li>项目中的pom.xml中继承了一个坐标</li></ul><pre class=" language-XML"><code class="language-XML"><parent>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-parent</artifactId>    <version>2.5.4</version></parent></code></pre><ul><li>打开后可以查阅到其中又继承了一个坐标</li></ul><pre class=" language-XML"><code class="language-XML"><parent>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-dependencies</artifactId>    <version>2.5.4</version></parent></code></pre><ul><li>这个坐标中定义了两组信息</li></ul><p>第一组是各式各样的依赖版本号属性，下面列出依赖版本属性的局部，可以看的出来，定义了若干个技术的依赖版本号。</p><pre class=" language-XML"><code class="language-XML"><properties>    <activemq.version>5.16.3</activemq.version>    <aspectj.version>1.9.7</aspectj.version>    <assertj.version>3.19.0</assertj.version>    <commons-codec.version>1.15</commons-codec.version>    <commons-dbcp2.version>2.8.0</commons-dbcp2.version>    <commons-lang3.version>3.12.0</commons-lang3.version>    <commons-pool.version>1.6</commons-pool.version>    <commons-pool2.version>2.9.0</commons-pool2.version>    <h2.version>1.4.200</h2.version>    <hibernate.version>5.4.32.Final</hibernate.version>    <hibernate-validator.version>6.2.0.Final</hibernate-validator.version>    <httpclient.version>4.5.13</httpclient.version>    <jackson-bom.version>2.12.4</jackson-bom.version>    <javax-jms.version>2.0.1</javax-jms.version>    <javax-json.version>1.1.4</javax-json.version>    <javax-websocket.version>1.1</javax-websocket.version>    <jetty-el.version>9.0.48</jetty-el.version>    <junit.version>4.13.2</junit.version></properties></code></pre><p>第二组是各式各样的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值.</p><pre class=" language-XML"><code class="language-XML"><dependencyManagement>    <dependencies>        <dependency>            <groupId>org.hibernate</groupId>            <artifactId>hibernate-core</artifactId>            <version>$&#123;hibernate.version&#125;</version>        </dependency>        <dependency>            <groupId>junit</groupId>            <artifactId>junit</artifactId>            <version>$&#123;junit.version&#125;</version>        </dependency>    </dependencies></dependencyManagement></code></pre><p>​        <font color="#ff0000"><b>关注</b></font>：上面的依赖坐标定义是出现在<dependencyManagement>标签中的，是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组parent信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的。</p><p>​        <font color="#ff0000"><b>关注</b></font>：因为在maven中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的starter创建工程时就使用了此种形式。</p><pre class=" language-XML"><code class="language-XML"><dependencyManagement>    <dependencies>        <dependency>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-dependencies</artifactId>            <version>$&#123;spring-boot.version&#125;</version>            <type>pom</type>            <scope>import</scope>        </dependency>    </dependencies></dependencyManagement></code></pre><p><strong>总结</strong></p><ol><li>开发SpringBoot程序要继承spring-boot-starter-parent</li><li>spring-boot-starter-parent中定义了若干个依赖管理</li><li>继承parent模块可以避免多个依赖使用相同技术时出现依赖版本冲突</li><li>继承parent的形式也可以采用引入依赖的形式实现效果</li></ol><p><strong>思考</strong></p><p>​        parent中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？</p><h4 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h4><p>​        SpringBoot关注到实际开发时，开发者对于依赖坐标的使用往往都有一些固定的组合方式，比如使用spring-webmvc就一定要使用spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。</p><p>​        SpringBoot一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用每次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot给它起了个名字叫做<font color="#ff0000"><b>starter</b></font>。</p><p>​        starter定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，<font color="#ff0000"><b>使用starter可以帮助开发者减少依赖配置</b></font>。</p><p>​        这个东西其实在入门案例里面已经使用过了，入门案例中的web功能就是使用这种方式添加依赖的。可以查阅SpringBoot的配置源码，看到这些定义。</p><ul><li>项目中的pom.xml定义了使用SpringMVC技术，但是并没有写SpringMVC的坐标，而是添加了一个名字中包含starter的依赖</li></ul><pre class=" language-XML"><code class="language-XML"><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-web</artifactId></dependency></code></pre><ul><li>在spring-boot-starter-web中又定义了若干个具体依赖的坐标</li></ul><pre class=" language-XML"><code class="language-XML"><dependencies>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter</artifactId>        <version>2.5.4</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-json</artifactId>        <version>2.5.4</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-tomcat</artifactId>        <version>2.5.4</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-web</artifactId>        <version>5.3.9</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-webmvc</artifactId>        <version>5.3.9</version>        <scope>compile</scope>    </dependency></dependencies></code></pre><p>​        之前提到过开发SpringMVC程序需要导入spring-webmvc的坐标和spring整合web开发的坐标，就是上面这组坐标中的最后两个了。</p><p>​        但是我们发现除了这两个坐标，还有其他的坐标。比如第二个，叫做spring-boot-starter-json。看名称就知道，这个是与json有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有starter，打开看看里面有什么？</p><pre class=" language-XML"><code class="language-XML"><dependencies>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter</artifactId>        <version>2.5.4</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-web</artifactId>        <version>5.3.9</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>com.fasterxml.jackson.core</groupId>        <artifactId>jackson-databind</artifactId>        <version>2.12.4</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>com.fasterxml.jackson.datatype</groupId>        <artifactId>jackson-datatype-jdk8</artifactId>        <version>2.12.4</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>com.fasterxml.jackson.datatype</groupId>        <artifactId>jackson-datatype-jsr310</artifactId>        <version>2.12.4</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>com.fasterxml.jackson.module</groupId>        <artifactId>jackson-module-parameter-names</artifactId>        <version>2.12.4</version>        <scope>compile</scope>    </dependency></dependencies></code></pre><p>​        我们可以发现，这个starter中又包含了若干个坐标，其实就是使用SpringMVC开发通常都会使用到Json，使用json又离不开这里面定义的这些坐标，看来还真是方便，SpringBoot把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过maven中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。</p><p>​    到这里基本上得到了一个信息，使用starter可以帮开发者快速配置依赖关系。以前写依赖3个坐标的，现在写导入一个就搞定了，就是加速依赖配置的。</p><p><strong>starter与parent的区别</strong></p><p>​        朦朦胧胧中感觉starter与parent好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。</p><p>​        <font color="#ff0000"><b>starter</b></font>是一个坐标中定了若干个坐标，以前写多个的，现在写一个，<font color="#ff0000"><b>是用来减少依赖配置的书写量的</b></font>。</p><p>​        <font color="#ff0000"><b>parent</b></font>是定义了几百个依赖版本号，以前写依赖需要自己手工控制版本，现在由SpringBoot统一管理，这样就不存在版本冲突了，<font color="#ff0000"><b>是用来减少依赖冲突的</b></font>。</p><p><strong>实际开发应用方式</strong></p><ul><li><p>实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter</p><ul><li>如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供</li><li>如果没有对应的starter，手写坐标即可</li></ul></li><li><p>实际开发中如果发现坐标出现了冲突现象，确认你要使用的可行的版本号，使用手工书写的方式添加对应依赖，覆盖SpringBoot提供给我们的配置管理</p><ul><li>方式一：直接写坐标</li><li>方式二：覆盖<properties>中定义的版本号，就是下面这堆东西了，哪个冲突了覆盖哪个就OK了</li></ul><pre class=" language-XML"><code class="language-XML"><properties>    <activemq.version>5.16.3</activemq.version>    <aspectj.version>1.9.7</aspectj.version>    <assertj.version>3.19.0</assertj.version>    <commons-codec.version>1.15</commons-codec.version>    <commons-dbcp2.version>2.8.0</commons-dbcp2.version>    <commons-lang3.version>3.12.0</commons-lang3.version>    <commons-pool.version>1.6</commons-pool.version>    <commons-pool2.version>2.9.0</commons-pool2.version>    <h2.version>1.4.200</h2.version>    <hibernate.version>5.4.32.Final</hibernate.version>    <hibernate-validator.version>6.2.0.Final</hibernate-validator.version>    <httpclient.version>4.5.13</httpclient.version>    <jackson-bom.version>2.12.4</jackson-bom.version>    <javax-jms.version>2.0.1</javax-jms.version>    <javax-json.version>1.1.4</javax-json.version>    <javax-websocket.version>1.1</javax-websocket.version>    <jetty-el.version>9.0.48</jetty-el.version>    <junit.version>4.13.2</junit.version></properties></code></pre></li></ul><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        SpringBoot官方给出了好多个starter的定义，方便我们使用，而且名称都是如下格式</p><pre class=" language-JAVA"><code class="language-JAVA">命名规则：spring-boot-starter-技术名称</code></pre><p>​    所以后期见了spring-boot-starter-aaa这样的名字，这就是SpringBoot官方给出的starter定义。那非官方定义的也有吗？有的，具体命名方式到整合技术的章节再说。</p><p><strong>总结</strong></p><ol><li>开发SpringBoot程序需要导入坐标时通常导入对应的starter</li><li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li><li>使用starter可以实现快速配置的效果，达到简化配置的目的</li></ol><h4 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h4><p>​        配置说完了，我们发现SpringBoot确实帮助我们减少了很多配置工作，下面说一下程序是如何运行的。目前程序运行的入口就是SpringBoot工程创建时自带的那个类，也就是带有main方法的那个类，运行这个类就可以启动SpringBoot工程的运行。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot0101QuickstartApplication</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Springboot0101QuickstartApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        SpringBoot本身是为了加速Spring程序的开发的，而Spring程序运行的基础是需要创建Spring容器对象（IoC容器）并将所有的对象放置到Spring容器中管理，也就是一个一个的Bean。现在改用SpringBoot加速开发Spring程序，这个容器还在吗？这个疑问不用说，一定在。其实当前这个类运行后就会产生一个Spring容器对象，并且可以将这个对象保存起来，通过容器对象直接操作Bean。</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootApplicationpublic class QuickstartApplication &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext ctx = SpringApplication.run(QuickstartApplication.class, args);        BookController bean = ctx.getBean(BookController.class);        System.out.println("bean======>" + bean);    &#125;&#125;</code></pre><p>​        通过上述操作不难看出，其实SpringBoot程序启动还是创建了一个Spring容器对象。当前运行的这个类在SpringBoot程序中是所有功能的入口，称为<font color="#ff0000"><b>引导类</b></font>。</p><p>​        作为一个引导类最典型的特征就是当前类上方声明了一个注解<font color="#ff0000"><b>@SpringBootApplication</b></font>。</p><p><strong>总结</strong></p><ol><li>SpringBoot工程提供引导类用来启动程序</li><li>SpringBoot工程启动后创建并初始化Spring容器</li></ol><p><strong>思考</strong></p><p>​        程序现在已经运行了，通过引导类的main方法运行了起来。但是运行java程序不应该是执行完就结束了吗？但是我们现在明显是启动了一个web服务器啊，不然网页怎么能正常访问呢？这个服务器是在哪里写的呢？</p><h4 id="内嵌tomcat"><a href="#内嵌tomcat" class="headerlink" title="内嵌tomcat"></a>内嵌tomcat</h4><p>​        当前我们做的SpringBoot入门案例勾选了Spring-web的功能，并且导入了对应的starter。</p><pre class=" language-XML"><code class="language-XML"><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-web</artifactId></dependency></code></pre><p>​        SpringBoot发现，既然你要做web程序，肯定离不开使用web服务器，这样吧，帮人帮到底，送佛送到西，我帮你搞一个web服务器，你要愿意用的，直接使用就好了。SpringBoot又琢磨，提供一种服务器万一不满足开发者需要呢？干脆我再多给你几种选择，你随便切换。万一你不想用我给你提供的，也行，你可以自己搞。</p><p>​        由于这个功能不属于程序的主体功能，可用可不用，于是乎SpringBoot将其定位成辅助功能，别小看这么一个辅助功能，它可是帮我们开发者又减少了好多的设置性工作。</p><p>​        下面就围绕着这个内置的web服务器，也可以说是内置的tomcat服务器来研究几个问题：</p><ol><li>这个服务器在什么位置定义的</li><li>这个服务器是怎么运行的</li><li>这个服务器如果想换怎么换？虽然这个需求很垃圾，搞得开发者会好多web服务器一样，用别人提供好的不香么？非要自己折腾</li></ol><p><strong>内嵌Tomcat定义位置</strong></p><p>​        说到定义的位置，我们就想，如果我们不开发web程序，用的着web服务器吗？肯定用不着啊。那如果这个东西被加入到你的程序中，伴随着什么技术进来的呢？肯定是web相关的功能啊，没错，就是前面导入的web相关的starter做的这件事。</p><pre class=" language-XML"><code class="language-XML"><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter-web</artifactId></dependency></code></pre><p>​        打开web对应的starter查看导入了哪些东西。</p><pre class=" language-XML"><code class="language-XML"><dependencies>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter</artifactId>        <version>2.5.4</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-json</artifactId>        <version>2.5.4</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-tomcat</artifactId>        <version>2.5.4</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-web</artifactId>        <version>5.3.9</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-webmvc</artifactId>        <version>5.3.9</version>        <scope>compile</scope>    </dependency></dependencies></code></pre><p>​        第三个依赖就是tomcat对应的东西了，居然也是一个starter，再打开看看。</p><pre class=" language-XML"><code class="language-XML"><dependencies>    <dependency>        <groupId>jakarta.annotation</groupId>        <artifactId>jakarta.annotation-api</artifactId>        <version>1.3.5</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>org.apache.tomcat.embed</groupId>        <artifactId>tomcat-embed-core</artifactId>        <version>9.0.52</version>        <scope>compile</scope>        <exclusions>            <exclusion>                <artifactId>tomcat-annotations-api</artifactId>                <groupId>org.apache.tomcat</groupId>            </exclusion>        </exclusions>    </dependency>    <dependency>        <groupId>org.apache.tomcat.embed</groupId>        <artifactId>tomcat-embed-el</artifactId>        <version>9.0.52</version>        <scope>compile</scope>    </dependency>    <dependency>        <groupId>org.apache.tomcat.embed</groupId>        <artifactId>tomcat-embed-websocket</artifactId>        <version>9.0.52</version>        <scope>compile</scope>        <exclusions>            <exclusion>                <artifactId>tomcat-annotations-api</artifactId>                <groupId>org.apache.tomcat</groupId>            </exclusion>        </exclusions>    </dependency></dependencies></code></pre><p>​        这里面有一个核心的坐标，tomcat-embed-core，叫做tomcat内嵌核心。就是这个东西把tomcat功能引入到了我们的程序中的。目前解决了第一个问题，找到根儿了，谁把tomcat引入到程序中的？spring-boot-starter-web中的spring-boot-starter-tomcat做的。之所以你感觉很奇妙的原因就是，这个东西是默认加入到程序中了，所以感觉很神奇，居然什么都不做，就有了web服务器对应的功能。再来说第二个问题，这个服务器是怎么运行的。</p><p><strong>内嵌Tomcat运行原理</strong></p><p>​        Tomcat服务器是一款软件，而且是一款使用java语言开发的软件，熟悉tomcat的话应该知道tomcat安装目录中保存有很多jar文件。</p><p>​        下面的问题来了，既然是使用java语言开发的，运行的时候肯定符合java程序运行的原理，java程序运行靠的是什么？对象呀，一切皆对象，万物皆对象。那tomcat运行起来呢？也是对象啊。</p><p>​        如果是对象，那Spring容器是用来管理对象的，这个对象能交给Spring容器管理吗？把吗去掉，是个对象都可以交给Spring容器管理，行了，这下通了，tomcat服务器运行其实是以对象的形式在Spring容器中运行的。怪不得我们没有安装这个tomcat但是还能用，闹了白天这东西最后是以一个对象的形式存在，保存在Spring容器中悄悄运行的。具体运行的是什么呢？其实就是上前面提到的那个tomcat内嵌核心。</p><pre class=" language-XML"><code class="language-XML"><dependencies>    <dependency>        <groupId>org.apache.tomcat.embed</groupId>        <artifactId>tomcat-embed-core</artifactId>        <version>9.0.52</version>        <scope>compile</scope>    </dependency></dependencies></code></pre><p>​        那既然是个对象，如果把这个对象从Spring容器中去掉是不是就没有web服务器的功能呢？是这样的，通过依赖排除可以去掉这个web服务器功能。</p><pre class=" language-XML"><code class="language-XML"><dependencies>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-web</artifactId>        <exclusions>            <exclusion>                <groupId>org.springframework.boot</groupId>                <artifactId>spring-boot-starter-tomcat</artifactId>            </exclusion>        </exclusions>    </dependency></dependencies></code></pre><p>​        上面对web-starter做了一个操作，使用maven的排除依赖去掉了使用tomcat的starter。这下好了，容器中肯定没有这个对象了，重新启动程序可以观察到程序运行了，但是并没有像之前那样运行后是一个一直运行的服务，而是直接停掉了，就是这个原因。</p><p><strong>更换内嵌Tomcat</strong></p><p>​        那根据上面的操作我们思考是否可以换个服务器呢？必须的嘛。根据SpringBoot的工作机制，用什么技术，加入什么依赖就行了。SpringBoot提供了3款内置的服务器：</p><ul><li><p>tomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件</p></li><li><p>jetty：更轻量级，负载性能远不及tomcat</p></li><li><p>undertow：负载性能勉强跑赢tomcat</p><p>想用哪个，加个坐标就OK。前提是把tomcat排除掉，因为tomcat是默认加载的。</p></li></ul><pre class=" language-XML"><code class="language-XML"><dependencies>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-web</artifactId>        <exclusions>            <exclusion>                <groupId>org.springframework.boot</groupId>                <artifactId>spring-boot-starter-tomcat</artifactId>            </exclusion>        </exclusions>    </dependency>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-jetty</artifactId>    </dependency></dependencies></code></pre><p>​        现在就已经成功替换了web服务器，核心思想就是用什么加入对应坐标就可以了。如果有starter，优先使用starter。</p><p><strong>总结</strong></p><ol><li>内嵌Tomcat服务器是SpringBoot辅助功能之一</li><li>内嵌Tomcat工作原理是将Tomcat服务器作为对象运行，并将该对象交给Spring容器管理</li><li>变更内嵌服务器思想是去除现有服务器，添加全新的服务器</li></ol><p>​        到这里第一章快速上手SpringBoot就结束了，这一章我们学习了两大块知识</p><ol><li><p>使用了4种方式制作了SpringBoot的入门程序，不管是哪一种，其实内部都是一模一样的</p></li><li><p>学习了入门程序的工作流程，知道什么是parent，什么是starter，这两个东西是怎么配合工作的，以及我们的程序为什么启动起来是一个tomcat服务器等等</p><p>第一章到这里就结束了，再往下学习就要去基于会创建SpringBoot工程的基础上，研究SpringBoot工程的具体细节了。</p></li></ol><h2 id="JC-2-SpringBoot基础配置"><a href="#JC-2-SpringBoot基础配置" class="headerlink" title="JC-2.SpringBoot基础配置"></a>JC-2.SpringBoot基础配置</h2><p>​        入门案例做完了，下面就要研究SpringBoot的用法了。通过入门案例，各位小伙伴能够感知到一个信息，SpringBoot没有具体的功能，它是辅助加快Spring程序的开发效率的。我们发现，现在几乎不用做任何配置功能就有了，确实很好用。但是仔细想想，没有做配置意味着什么？意味着配置已经做好了，不用你自己写了。但是新的问题又来了，如果不想用已经写好的默认配置，该如何干预呢？这就是这一章咱们要研究的问题。</p><p>​        如果想修改默认的配置，这个信息应该写在什么位置呢？目前我们接触的入门案例中一共有3个文件，第一是pom.xml文件，设置项目的依赖，这个没什么好研究的，相关的高级内容咱们到原理篇再说，第二是引导类，这个是执行SpringBoot程序的入口，也不像是做功能配置的地方，其实还有一个信息，就是在resources目录下面有一个空白的文件，叫做application.properties。一看就是个配置文件，咱们这一章就来说说配置文件怎么写，能写什么，怎么覆盖SpringBoot的默认配置修改成自己的配置。</p><p>​    </p><h3 id="JC-2-1-属性配置"><a href="#JC-2-1-属性配置" class="headerlink" title="JC-2-1.属性配置"></a>JC-2-1.属性配置</h3><p>​        SpringBoot通过配置文件application.properties就可以修改默认的配置，那咱们就先找个简单的配置下手，当前访问tomcat的默认端口是8080，好熟悉的味道，但是不便于书写，我们先改成80，通过这个操作来熟悉一下SpringBoot的配置格式是什么样的。</p><p><img src="img%5Cimage-20211123165428245.png" alt="image-20211123165428245"></p><p>​        那该如何写呢？properties格式的文件书写规范是key=value</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">name</span><span class="token punctuation">=</span><span class="token attr-value">itheima</span></code></pre><p>​        这个格式肯定是不能颠覆的，那就尝试性的写就行了，改端口，写port。当你输入port后，神奇的事情就发生了，这玩意儿带提示，太好了。</p><img src="img\image-20211123165719091.png" alt="image-20211123165719091" style="zoom:80%;" /><p>​        根据提示敲回车，输入80端口，搞定。</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">80</span></code></pre><p>​        下面就可以直接运行程序，测试效果了。</p><p>​        我们惊奇的发现SpringBoot这玩意儿狠啊，以前修改端口在哪里改？tomcat服务器的配置文件中改，现在呢？SpringBoot专用的配置文件中改，是不是意味着以后所有的配置都可以写在这一个文件中呢？是的，简化开发者配置的书写位置，集中管理。妙啊，妈妈再也不用担心我找不到配置文件了。</p><p>​        其实到这里我们应该得到如下三个信息：</p><ol><li>SpringBoot程序可以在application.properties文件中进行属性配置</li><li>application.properties文件中只要输入要配置的属性关键字就可以根据提示进行设置</li><li>SpringBoot将配置信息集中在一个文件中写，不管你是服务器的配置，还是数据库的配置，总之都写在一起，逃离一个项目十几种配置文件格式的尴尬局面</li></ol><p><strong>总结</strong></p><ol><li>SpringBoot默认配置文件是application.properties</li></ol><p>​        做完了端口的配置，趁热打铁，再做几个配置，目前项目启动时会显示一些日志信息，就来改一改这里面的一些设置。</p><p><strong>关闭运行日志图表（banner)</strong></p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">spring.main.banner-mode</span><span class="token punctuation">=</span><span class="token attr-value">off</span></code></pre><p><strong>设置运行日志的显示级别</strong></p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">logging.level.root</span><span class="token punctuation">=</span><span class="token attr-value">debug</span></code></pre><p>​        你会发现，现在这么搞配置太爽了，以前你做配置怎么做？不同的技术有自己专用的配置文件，文件不同格式也不统一，现在呢？不用东奔西走的找配置文件写配置了，统一格式了，这就是大秦帝国啊，统一六国。SpringBoot比大秦狠，因为未来出现的技术还没出现呢，但是现在已经确认了，配置都写这个文件里面。</p><p>​        我们现在配置了3个信息，但是又有新的问题了。这个配置是随便写的吗？什么都能配？有没有一个东西显示所有能配置的项呢？此外这个配置和什么东西有关呢？会不会因为我写了什么东西以后才可以写什么配置呢？比如我现在没有写数据库相关的东西，能否配置数据呢？一个一个来，先说第一个问题，都能配置什么。</p><p>​        打开SpringBoot的官网，找到SpringBoot官方文档，打开查看附录中的Application Properties就可以获取到对应的配置项了，网址奉上：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties</a></p><p>​        能写什么的问题解决了，再来说第二个问题，这个配置项和什么有关。在pom中注释掉导入的spring-boot-starter-web，然后刷新工程，你会发现配置的提示消失了。闹了半天是设定使用了什么技术才能做什么配置。也合理，不然没有使用对应技术，配了也是白配。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        所有的starter中都会依赖下面这个starter，叫做spring-boot-starter。这个starter是所有的SpringBoot的starter的基础依赖，里面定义了SpringBoot相关的基础配置，关于这个starter我们到开发应用篇和原理篇中再深入讲解。</p><pre class=" language-JAVA"><code class="language-JAVA"><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-starter</artifactId>    <version>2.5.4</version>    <scope>compile</scope></dependency></code></pre><p><strong>总结</strong></p><ol><li>SpringBoot中导入对应starter后，提供对应配置属性</li><li>书写SpringBoot配置采用关键字+提示形式书写</li></ol><h3 id="JC-2-2-配置文件分类"><a href="#JC-2-2-配置文件分类" class="headerlink" title="JC-2-2.配置文件分类"></a>JC-2-2.配置文件分类</h3><p>​        现在已经能够进行SpringBoot相关的配置了，但是properties格式的配置写起来总是觉得看着不舒服，所以就期望存在一种书写起来更简便的配置格式提供给开发者使用。有吗？还真有，SpringBoot除了支持properties格式的配置文件，还支持另外两种格式的配置文件。三种配置文件格式分别如下:</p><ul><li>properties格式</li><li>yml格式</li><li>yaml格式</li></ul><p>​        一看到全新的文件格式，各位小伙伴肯定想，这下又要学习新的语法格式了。怎么说呢？从知识角度来说，要学，从开发角度来说，不用学。为什么呢？因为SpringBoot的配置在Idea工具下有提示啊，跟着提示走就行了。下面列举三种不同文件格式配置相同的属性范例，先了解一下。</p><ul><li>application.properties（properties格式）</li></ul><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">80</span></code></pre><ul><li>application.yml（yml格式）</li></ul><pre class=" language-YML"><code class="language-YML">server:  port: 81</code></pre><ul><li>application.yaml（yaml格式）</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">82</span></code></pre><p>​        仔细看会发现yml格式和yaml格式除了文件名后缀不一样，格式完全一样，是这样的，yml和yaml文件格式就是一模一样的，只是文件后缀不同，所以可以合并成一种格式来看。那对于这三种格式来说，以后用哪一种比较多呢？记清楚，以后基本上都是用yml格式的，本课程后面的所有知识都是基于yml格式来制作的，以后在企业开发过程中用这个格式的机会也最多，一定要重点掌握。</p><p><strong>总结</strong></p><ol><li>SpringBoot提供了3种配置文件的格式<ul><li>properties（传统格式/默认格式）</li><li><strong>yml</strong>（主流格式）</li><li>yaml</li></ul></li></ol><p><strong>思考</strong></p><p>​        现在我们已经知道使用三种格式都可以做配置了，好奇宝宝们就有新的灵魂拷问了，万一我三个都写了，他们三个谁说了算呢？打一架吗？</p><h4 id="配置文件优先级"><a href="#配置文件优先级" class="headerlink" title="配置文件优先级"></a>配置文件优先级</h4><p>​        其实三个文件如果共存的话，谁生效说的就是配置文件加载的优先级别。先说一点，虽然以后这种情况很少出现，但是这个知识还是可以学习一下的。我们就让三个配置文件书写同样的信息，比如都配置端口，然后我们让每个文件配置的端口号都不一样，最后启动程序后看启动端口是多少就知道谁的加载优先级比较高了。</p><ul><li>application.properties（properties格式）</li></ul><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">80</span></code></pre><ul><li>application.yml（yml格式）</li></ul><pre class=" language-YML"><code class="language-YML">server:  port: 81</code></pre><ul><li>application.yaml（yaml格式）</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">82</span></code></pre><p>​        启动后发现目前的启动端口为80，把80对应的文件删除掉，然后再启动，现在端口又改成了81。现在我们就已经知道了3个文件的加载优先顺序是什么。</p><pre class=" language-XML"><code class="language-XML">application.properties  >  application.yml  >  application.yaml</code></pre><p>​        虽然得到了一个知识结论，但是我们实际开发的时候还是要看最终的效果为准。也就是你要的最终效果是什么自己是明确的，上述结论只能帮助你分析结论产生的原因。这个知识了解一下就行了，因为以后同时写多种配置文件格式的情况实在是较少。</p><p>​        最后我们把配置文件内容给修改一下</p><ul><li>application.properties（properties格式）</li></ul><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">80</span><span class="token attr-name">spring.main.banner-mode</span><span class="token punctuation">=</span><span class="token attr-value">off</span></code></pre><ul><li>application.yml（yml格式）</li></ul><pre class=" language-YML"><code class="language-YML">server:  port: 81logging:   level:     root: debug</code></pre><ul><li>application.yaml（yaml格式）</li></ul><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">82</span></code></pre><p>​        我们发现不仅端口生效了，最终显示80，同时其他两条配置也生效了，看来每个配置文件中的项都会生效，只不过如果多个配置文件中有相同类型的配置会优先级高的文件覆盖优先级的文件中的配置。如果配置项不同的话，所有的配置项都会生效。</p><p><strong>总结</strong></p><ol><li>配置文件间的加载优先级    properties（最高）&gt;  yml  &gt;  yaml（最低）</li><li>不同配置文件中相同配置按照加载优先级相互覆盖，不同配置文件中不同配置全部保留 </li></ol><h4 id="教你一招：自动提示功能消失解决方案"><a href="#教你一招：自动提示功能消失解决方案" class="headerlink" title="教你一招：自动提示功能消失解决方案"></a>教你一招：<strong>自动提示功能消失解决方案</strong></h4><p>​        在做程序的过程中，可能有些小伙伴会基于各种各样的原因导致配置文件中没有提示，这个确实很让人头疼，所以下面给大家说一下如果自动提示功能消失了怎么解决。</p><p>​        先要明确一个核心，就是自动提示功能不是SpringBoot技术给我们提供的，是我们在Idea工具下编程，这个编程工具给我们提供的。明白了这一点后，再来说为什么会出现这种现象。其实这个自动提示功能消失的原因还是蛮多的，如果想解决这个问题，就要知道为什么会消失，大体原因有如下2种：</p><ol><li><p>Idea认为你现在写配置的文件不是个配置文件，所以拒绝给你提供提示功能</p></li><li><p>Idea认定你是合理的配置文件，但是Idea加载不到对应的提示信息</p><p>这里我们主要解决第一个现象，第二种现象到原理篇再讲解。第一种现象的解决方式如下：</p></li></ol><p><strong>步骤①</strong>：打开设置，【Files】→【Project Structure…】</p><p><img src="img%5Cimage-20211126160548690.png" alt="image-20211126160548690"></p><p><strong>步骤②</strong>：在弹出窗口中左侧选择【Facets】，右侧选中Spring路径下对应的模块名称，也就是你自动提示功能消失的那个模块</p><p><img src="img\image-20211126160726589.png" alt="image-20211126160726589" style="zoom:67%;" /><img src="img%5Cimage-20211126160844372.png" alt="image-20211126160844372"></p><p><strong>步骤③</strong>：点击Customize Spring Boot按钮，此时可以看到当前模块对应的配置文件是哪些了。如果没有你想要称为配置文件的文件格式，就有可能无法弹出提示</p><p><img src="img%5Cimage-20211126160946448.png" alt="image-20211126160946448"><img src="img\image-20211126160954338.png" alt="image-20211126160954338" style="zoom:80%;" /></p><p><strong>步骤④</strong>：选择添加配置文件，然后选中要作为配置文件的具体文件就OK了</p><p><img src="img\image-20211126161145082.png" alt="image-20211126161145082" style="zoom:80%;" /><img src="img\image-20211126161156324.png" alt="image-20211126161156324" style="zoom: 67%;" /></p><p>​        到这里就做完了，其实就是Idea的一个小功能</p><p><img src="img%5Cimage-20211126161301699.png" alt="image-20211126161301699"></p><p><strong>总结</strong></p><ol><li><p>指定SpringBoot配置文件</p><ul><li>Setting → Project Structure → Facets</li><li>选中对应项目/工程</li><li>Customize Spring Boot</li><li>选择配置文件</li></ul></li></ol><h3 id="JC-2-3-yaml文件"><a href="#JC-2-3-yaml文件" class="headerlink" title="JC-2-3.yaml文件"></a>JC-2-3.yaml文件</h3><p>​        SpringBoot的配置以后主要使用yml结尾的这种文件格式，并且在书写时可以通过提示的形式加载正确的格式。但是这种文件还是有严格的书写格式要求的。下面就来说一下具体的语法格式。</p><p>​        YAML（YAML Ain’t Markup Language），一种数据序列化格式。具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。常见的文件扩展名有两种：</p><ul><li><p>.yml格式（主流）</p></li><li><p>.yaml格式</p><p> 具体的语法格式要求如下：</p></li></ul><ol><li>大小写敏感</li><li>属性层级关系使用多行描述，<strong>每行结尾使用冒号结束</strong></li><li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li><li>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</li><li>#号 表示注释</li></ol><p>​        上述规则不要死记硬背，按照书写习惯慢慢适应，并且在Idea下由于具有提示功能，慢慢适应着写格式就行了。核心的一条规则要记住，<font color="#ff0000"><b>数据前面要加空格与冒号隔开</b></font>。</p><p>​        下面列出常见的数据书写格式，熟悉一下</p><pre class=" language-YAML"><code class="language-YAML">boolean: TRUE                          #TRUE,true,True,FALSE,false，False均可float: 3.14                            #6.8523015e+5  #支持科学计数法int: 123                               #0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制null: ~                                #使用~表示nullstring: HelloWorld                  #字符串可以直接书写string2: "Hello World"              #可以使用双引号包裹特殊字符date: 2018-02-17                    #日期必须使用yyyy-MM-dd格式datetime: 2018-02-17T15:02:31+08:00  #时间和日期之间使用T连接，最后使用+代表时区</code></pre><p>​        此外，yaml格式中也可以表示数组，在属性名书写位置的下方使用减号作为数据开始符号，每行书写一个数据，减号与数据间空格分隔。</p><pre class=" language-YAML"><code class="language-YAML">subject:    - Java    - 前端    - 大数据enterprise:    name: itcast    age: 16    subject:        - Java        - 前端        - 大数据likes: [王者荣耀,刺激战场]            #数组书写缩略格式users:                             #对象数组格式一  - name: Tom       age: 4  - name: Jerry    age: 5users:                             #对象数组格式二  -      name: Tom    age: 4  -       name: Jerry    age: 5                users2: [ &#123; name:Tom , age:4 &#125; , &#123; name:Jerry , age:5 &#125; ]    #对象数组缩略格式</code></pre><p><strong>总结</strong></p><ol><li>yaml语法规则<ul><li>大小写敏感</li><li>属性层级关系使用多行描述，每行结尾使用冒号结束</li><li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li><li>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</li><li>#号 表示注释</li></ul></li><li>注意属性名冒号后面与数据之间有一个<strong>空格</strong></li><li>字面值、对象数据格式、数组数据格式</li></ol><p><strong>思考</strong></p><p>​        现在我们已经知道了yaml具有严格的数据格式要求，并且已经可以正确的书写yaml文件了，那这些文件书写后其实是在定义一些数据。这些数据是给谁用的呢？大部分是SpringBoot框架内部使用，但是如果我们想配置一些数据自己使用，能不能用呢？答案是可以的，那如何读取yaml文件中的数据呢？咱们下一节再说。</p><h3 id="JC-2-4-yaml数据读取"><a href="#JC-2-4-yaml数据读取" class="headerlink" title="JC-2-4.yaml数据读取"></a>JC-2-4.yaml数据读取</h3><p>​        对于yaml文件中的数据，其实你就可以想象成这就是一个小型的数据库，里面保存有若干数据，每个数据都有一个独立的名字，如果你想读取里面的数据，肯定是支持的，下面就介绍3种读取数据的方式。</p><h4 id="读取单一数据"><a href="#读取单一数据" class="headerlink" title="读取单一数据"></a>读取单一数据</h4><p>​        yaml中保存的单个数据，可以使用Spring中的注解@Value读取单个数据，属性名引用方式：<font color="#ff0000"><b>${一级属性名.二级属性名……}</b></font></p><img src="img\image-20211126180433356.png" alt="image-20211126180433356" style="zoom:80%;" /><p>​        记得使用@Value注解时，要将该注解写在某一个指定的Spring管控的bean的属性名上方，这样当bean进行初始化时候就可以读取到对应的单一数据了。</p><p><strong>总结</strong></p><ol><li>使用@Value配合SpEL读取单个数据</li><li>如果数据存在多层级，依次书写层级名称即可</li></ol><h4 id="读取全部数据"><a href="#读取全部数据" class="headerlink" title="读取全部数据"></a>读取全部数据</h4><p>​        读取单一数据可以解决读取数据的问题，但是如果定义的数据量过大，这么一个一个书写肯定会累死人的，SpringBoot提供了一个对象，能够把所有的数据都封装到这一个对象中，这个对象叫做Environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中</p><img src="img\image-20211126180738569.png" alt="image-20211126180738569" style="zoom:80%;" /><p>​        数据封装到了Environment对象中，获取属性时，通过Environment的接口操作进行，具体方法是getProperties（String），参数填写属性名即可</p><p><strong>总结</strong></p><ol><li>使用Environment对象封装全部配置信息</li><li>使用@Autowired自动装配数据到Environment对象中</li></ol><h4 id="读取对象数据"><a href="#读取对象数据" class="headerlink" title="读取对象数据"></a>读取对象数据</h4><p>​        单一数据读取书写比较繁琐，全数据读取封装的太厉害了，每次拿数据还要一个一个的getProperties（）,总之用起来都不是很舒服。由于Java是一个面向对象的语言，很多情况下，我们会将一组数据封装成一个对象。SpringBoot也提供了可以将一组yaml对象数据封装一个Java对象的操作</p><p>​        首先定义一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean，然后使用注解@ConfigurationProperties指定该对象加载哪一组yaml中配置的信息。</p><img src="img\image-20211126181126382.png" alt="image-20211126181126382" style="zoom:80%;" /><p>​        这个@ConfigurationProperties必须告诉他加载的数据前缀是什么，这样指定前缀下的所有属性就封装到这个对象中。记得数据属性名要与对象的变量名一一对应啊，不然没法封装。其实以后如果你要定义一组数据自己使用，就可以先写一个对象，然后定义好属性，下面到配置中根据这个格式书写即可。</p><p>​    <img src="img\image-20211126181423432.png" alt="image-20211126181423432" style="zoom:80%;" /></p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        细心的小伙伴会发现一个问题，自定义的这种数据在yaml文件中书写时没有弹出提示，咱们到原理篇再揭秘如何弹出提示。</p><p><strong>总结</strong></p><ol><li>使用@ConfigurationProperties注解绑定配置信息到封装类中</li><li>封装类需要定义为Spring管理的bean，否则无法进行属性注入</li></ol><h4 id="yaml文件中的数据引用"><a href="#yaml文件中的数据引用" class="headerlink" title="yaml文件中的数据引用"></a>yaml文件中的数据引用</h4><p>​        如果你在书写yaml数据时，经常出现如下现象，比如很多个文件都具有相同的目录前缀</p><pre class=" language-YAML"><code class="language-YAML">center:    dataDir: /usr/local/fire/data    tmpDir: /usr/local/fire/tmp    logDir: /usr/local/fire/log    msgDir: /usr/local/fire/msgDir</code></pre><p>​        或者</p><pre class=" language-YAML"><code class="language-YAML">center:    dataDir: D:/usr/local/fire/data    tmpDir: D:/usr/local/fire/tmp    logDir: D:/usr/local/fire/log    msgDir: D:/usr/local/fire/msgDir</code></pre><p>​        这个时候你可以使用引用格式来定义数据，其实就是搞了个变量名，然后引用变量了，格式如下：</p><pre class=" language-YAML"><code class="language-YAML">baseDir: /usr/local/firecenter:    dataDir: $&#123;baseDir&#125;/data    tmpDir: $&#123;baseDir&#125;/tmp    logDir: $&#123;baseDir&#125;/log    msgDir: $&#123;baseDir&#125;/msgDir</code></pre><p>​    还有一个注意事项，在书写字符串时，如果需要使用转义字符，需要将数据字符串使用双引号包裹起来</p><pre class=" language-YAML"><code class="language-YAML">lesson: "Spring\tboot\nlesson"</code></pre><p><strong>总结</strong></p><ol><li>在配置文件中可以使用${属性名}方式引用属性值</li><li>如果属性中出现特殊字符，可以使用双引号包裹起来作为字符解析</li></ol><p>​        到这里有关yaml文件的基础使用就先告一段落，实用篇中再继续研究更深入的内容。</p><h2 id="JC-3-基于SpringBoot实现SSMP整合"><a href="#JC-3-基于SpringBoot实现SSMP整合" class="headerlink" title="JC-3.基于SpringBoot实现SSMP整合"></a>JC-3.基于SpringBoot实现SSMP整合</h2><p>​        重头戏来了，SpringBoot之所以好用，就是它能方便快捷的整合其他技术，这一部分咱们就来聊聊一些技术的整合方式，通过这一章的学习，大家能够感受到SpringBoot到底有多酷炫。这一章咱们学习如下技术的整合方式</p><ul><li><p>整合JUnit</p></li><li><p>整合MyBatis</p></li><li><p>整合MyBatis-Plus</p></li><li><p>整合Druid</p><p> 上面这些技术都整合完毕后，我们做一个小案例，也算是学有所用吧。涉及的技术比较多，综合运用一下。</p></li></ul><h3 id="JC-3-1-整合JUnit"><a href="#JC-3-1-整合JUnit" class="headerlink" title="JC-3-1.整合JUnit"></a>JC-3-1.整合JUnit</h3><p>​        SpringBoot技术的定位用于简化开发，再具体点是简化Spring程序的开发。所以在整合任意技术的时候，如果你想直观感触到简化的效果，你必须先知道使用非SpringBoot技术时对应的整合是如何做的，然后再看基于SpringBoot的整合是如何做的，才能比对出来简化在了哪里。</p><p>​        我们先来看一下不使用SpringBoot技术时，Spring整合JUnit的制作方式</p><pre class=" language-JAVA"><code class="language-JAVA">//加载spring整合junit专用的类运行器@RunWith(SpringJUnit4ClassRunner.class)//指定对应的配置信息@ContextConfiguration(classes = SpringConfig.class)public class AccountServiceTestCase &#123;    //注入你要测试的对象    @Autowired    private AccountService accountService;    @Test    public void testGetById()&#123;        //执行要测试的对象对应的方法        System.out.println(accountService.findById(2));    &#125;&#125;</code></pre><p>​        其中核心代码是前两个注解，第一个注解@RunWith是设置Spring专用的测试类运行器，简单说就是Spring程序执行程序有自己的一套独立的运行程序的方式，不能使用JUnit提供的类运行方式了，必须指定一下，但是格式是固定的，琢磨一下，<font color="#ff0000"><b>每次都指定一样的东西，这个东西写起来没有技术含量啊</b></font>，第二个注解@ContextConfiguration是用来设置Spring核心配置文件或配置类的，简单说就是加载Spring的环境你要告诉Spring具体的环境配置是在哪里写的，虽然每次加载的文件都有可能不同，但是仔细想想，如果文件名是固定的，这个貌似也是一个固定格式。既然<font color="#ff0000"><b>有可能是固定格式，那就有可能每次都写一样的东西，也是一个没有技术含量的内容书写</b></font></p><p>​        SpringBoot就抓住上述两条没有技术含量的内容书写进行开发简化，能走默认值的走默认值，能不写的就不写，具体格式如下</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootTestclass Springboot04JunitApplicationTests &#123;    //注入你要测试的对象    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        //执行要测试的对象对应的方法        bookDao.save();        System.out.println("two...");    &#125;&#125;</code></pre><p>​        看看这次简化成什么样了，一个注解就搞定了，而且还没有参数，再体会SpringBoot整合其他技术的优势在哪里，就两个字——<font color="#ff0000"><b>简化</b></font>。使用一个注解@SpringBootTest替换了前面两个注解。至于内部是怎么回事？和之前一样，只不过都走默认值。</p><p>​        这个时候有人就问了，你加载的配置类或者配置文件是哪一个？就是我们前面启动程序使用的引导类。如果想手工指定引导类有两种方式，第一种方式使用属性的形式进行，在注解@SpringBootTest中添加classes属性指定配置类</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootTest(classes = Springboot04JunitApplication.class)class Springboot04JunitApplicationTests &#123;    //注入你要测试的对象    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        //执行要测试的对象对应的方法        bookDao.save();        System.out.println("two...");    &#125;&#125;</code></pre><p>​        第二种方式回归原始配置方式，仍然使用@ContextConfiguration注解进行，效果是一样的</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootTest@ContextConfiguration(classes = Springboot04JunitApplication.class)class Springboot04JunitApplicationTests &#123;    //注入你要测试的对象    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        //执行要测试的对象对应的方法        bookDao.save();        System.out.println("two...");    &#125;&#125;</code></pre><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        使用SpringBoot整合JUnit需要保障导入test对应的starter，由于初始化项目时此项是默认导入的，所以此处没有提及，其实和之前学习的内容一样，用什么技术导入对应的starter即可。</p><p><strong>总结</strong></p><ol><li>导入测试对应的starter</li><li>测试类使用@SpringBootTest修饰</li><li>使用自动装配的形式添加要测试的对象</li><li>测试类如果存在于引导类所在包或子包中无需指定引导类</li><li>测试类如果不存在于引导类所在的包或子包中需要通过classes属性指定引导类</li></ol><h3 id="JC-3-2-整合MyBatis"><a href="#JC-3-2-整合MyBatis" class="headerlink" title="JC-3-2.整合MyBatis"></a>JC-3-2.整合MyBatis</h3><p>​        整合完JUnit下面再来说一下整合MyBatis，这个技术是大部分公司都要使用的技术，务必掌握。如果对Spring整合MyBatis不熟悉的小伙伴好好复习一下，下面列举出原始整合的全部内容，以配置类的形式为例进行</p><ul><li><p>导入坐标，MyBatis坐标不能少，Spring整合MyBatis还有自己专用的坐标，此外Spring进行数据库操作的jdbc坐标是必须的，剩下还有mysql驱动坐标，本例中使用了Druid数据源，这个倒是可以不要</p><pre class=" language-XML"><code class="language-XML"><dependencies>    <dependency>        <groupId>com.alibaba</groupId>        <artifactId>druid</artifactId>        <version>1.1.16</version>    </dependency>    <dependency>        <groupId>org.mybatis</groupId>        <artifactId>mybatis</artifactId>        <version>3.5.6</version>    </dependency>    <dependency>        <groupId>mysql</groupId>        <artifactId>mysql-connector-java</artifactId>        <version>5.1.47</version>    </dependency>    <!--1.导入mybatis与spring整合的jar包-->    <dependency>        <groupId>org.mybatis</groupId>        <artifactId>mybatis-spring</artifactId>        <version>1.3.0</version>    </dependency>    <!--导入spring操作数据库必选的包-->    <dependency>        <groupId>org.springframework</groupId>        <artifactId>spring-jdbc</artifactId>        <version>5.2.10.RELEASE</version>    </dependency></dependencies></code></pre></li><li><p>Spring核心配置</p><pre class=" language-JAVA"><code class="language-JAVA">@Configuration@ComponentScan("com.itheima")@PropertySource("jdbc.properties")public class SpringConfig &#123;&#125;</code></pre></li><li><p>MyBatis要交给Spring接管的bean</p><pre class=" language-JAVA"><code class="language-JAVA">//定义mybatis专用的配置类@Configurationpublic class MyBatisConfig &#123;//    定义创建SqlSessionFactory对应的bean    @Bean    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource)&#123;        //SqlSessionFactoryBean是由mybatis-spring包提供的，专用于整合用的对象        SqlSessionFactoryBean sfb = new SqlSessionFactoryBean();        //设置数据源替代原始配置中的environments的配置        sfb.setDataSource(dataSource);        //设置类型别名替代原始配置中的typeAliases的配置        sfb.setTypeAliasesPackage("com.itheima.domain");        return sfb;    &#125;//    定义加载所有的映射配置    @Bean    public MapperScannerConfigurer mapperScannerConfigurer()&#123;        MapperScannerConfigurer msc = new MapperScannerConfigurer();        msc.setBasePackage("com.itheima.dao");        return msc;    &#125;&#125;</code></pre></li><li><p>数据源对应的bean，此处使用Druid数据源</p><pre class=" language-JAVA"><code class="language-JAVA">@Configurationpublic class JdbcConfig &#123;    @Value("$&#123;jdbc.driver&#125;")    private String driver;    @Value("$&#123;jdbc.url&#125;")    private String url;    @Value("$&#123;jdbc.username&#125;")    private String userName;    @Value("$&#123;jdbc.password&#125;")    private String password;    @Bean("dataSource")    public DataSource dataSource()&#123;        DruidDataSource ds = new DruidDataSource();        ds.setDriverClassName(driver);        ds.setUrl(url);        ds.setUsername(userName);        ds.setPassword(password);        return ds;    &#125;&#125;</code></pre></li><li><p>数据库连接信息（properties格式）</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">jdbc.driver</span><span class="token punctuation">=</span><span class="token attr-value">com.mysql.jdbc.Driver</span><span class="token attr-name">jdbc.url</span><span class="token punctuation">=</span><span class="token attr-value">jdbc:mysql://localhost:3306/spring_db?useSSL=false</span><span class="token attr-name">jdbc.username</span><span class="token punctuation">=</span><span class="token attr-value">root</span><span class="token attr-name">jdbc.password</span><span class="token punctuation">=</span><span class="token attr-value">root</span></code></pre><p>上述格式基本上是最简格式了，要写的东西还真不少。下面看看SpringBoot整合MyBaits格式</p></li></ul><p><strong>步骤①</strong>：创建模块</p><p><img src="img%5Cimage-20211129092156020.png" alt="image-20211129092156020"></p><p><strong>步骤②</strong>：勾选要使用的技术，MyBatis，由于要操作数据库，还要勾选对应数据库</p><p><img src="img%5Cimage-20211129092210993.png" alt="image-20211129092210993"></p><p>​    或者手工导入对应技术的starter，和对应数据库的坐标</p><pre class=" language-XML"><code class="language-XML"><dependencies>    <!--1.导入对应的starter-->    <dependency>        <groupId>org.mybatis.spring.boot</groupId>        <artifactId>mybatis-spring-boot-starter</artifactId>        <version>2.2.0</version>    </dependency>    <dependency>        <groupId>mysql</groupId>        <artifactId>mysql-connector-java</artifactId>        <scope>runtime</scope>    </dependency></dependencies></code></pre><p><strong>步骤③</strong>：配置数据源相关信息，没有这个信息你连接哪个数据库都不知道</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#2.配置相关信息</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/ssm_db    <span class="token key atrule">username</span><span class="token punctuation">:</span> root    <span class="token key atrule">password</span><span class="token punctuation">:</span> root</code></pre><p>​        结束了，就这么多，没了。有人就很纳闷，这就结束了？对，这就结束了，SpringBoot把配置中所有可能出现的通用配置都简化了。下面写一个MyBatis程序运行需要的Dao（或者Mapper）就可以运行了</p><p><strong>实体类</strong></p><pre class=" language-JAVA"><code class="language-JAVA">public class Book &#123;    private Integer id;    private String type;    private String name;    private String description;&#125;</code></pre><p><strong>映射接口（Dao）</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@Mapperpublic interface BookDao &#123;    @Select("select * from tbl_book where id = #&#123;id&#125;")    public Book getById(Integer id);&#125;</code></pre><p><strong>测试类</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootTestclass Springboot05MybatisApplicationTests &#123;    @Autowired    private BookDao bookDao;    @Test    void contextLoads() &#123;        System.out.println(bookDao.getById(1));    &#125;&#125;</code></pre><p>​        完美，开发从此变的就这么简单。再体会一下SpringBoot如何进行第三方技术整合的，是不是很优秀？具体内部的原理到原理篇再展开讲解</p><p>​        <font color="#ff0000"><b>注意</b></font>：当前使用的SpringBoot版本是2.5.4，对应的坐标设置中Mysql驱动使用的是8x版本。使用SpringBoot2.4.3（不含）之前版本会出现一个小BUG，就是MySQL驱动升级到8以后要求强制配置时区，如果不设置会出问题。解决方案很简单，驱动url上面添加上对应设置就行了</p><pre class=" language-YAML"><code class="language-YAML">#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    username: root    password: root</code></pre><p>​        这里设置的UTC是全球标准时间，你也可以理解为是英国时间，中国处在东八区，需要在这个基础上加上8小时，这样才能和中国地区的时间对应的，也可以修改配置为Asia/Shanghai，同样可以解决这个问题。</p><pre class=" language-YAML"><code class="language-YAML">#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai    username: root    password: root</code></pre><p>​        如果不想每次都设置这个东西，也可以去修改mysql中的配置文件mysql.ini，在mysqld项中添加default-time-zone=+8:00也可以解决这个问题。其实方式方法很多，这里就说这么多吧。</p><p>​        此外在运行程序时还会给出一个提示，说数据库驱动过时的警告，根据提示修改配置即可，弃用<strong>com.mysql.jdbc.Driver</strong>，换用<font color="#ff0000"><b>com.mysql.cj.jdbc.Driver</b></font>。前面的例子中已经更换了驱动了，在此说明一下。</p><pre class=" language-tex"><code class="language-tex">Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.</code></pre><p><strong>总结</strong></p><ol><li><p>整合操作需要勾选MyBatis技术，也就是导入MyBatis对应的starter</p></li><li><p>数据库连接相关信息转换成配置</p></li><li><p>数据库SQL映射需要添加@Mapper被容器识别到</p></li><li><p>MySQL 8.X驱动强制要求设置时区</p><ul><li>修改url，添加serverTimezone设定</li><li>修改MySQL数据库配置</li></ul></li><li><p>驱动类过时，提醒更换为com.mysql.cj.jdbc.Driver</p></li></ol><h3 id="JC-3-3-整合MyBatis-Plus"><a href="#JC-3-3-整合MyBatis-Plus" class="headerlink" title="JC-3-3.整合MyBatis-Plus"></a>JC-3-3.整合MyBatis-Plus</h3><p>​        做完了两种技术的整合了，各位小伙伴要学会总结，我们做这个整合究竟哪些是核心？总结下来就两句话</p><ul><li><p>导入对应技术的starter坐标</p></li><li><p>根据对应技术的要求做配置</p><p>虽然看起来有点虚，但是确实是这个理儿，下面趁热打铁，再换一个技术，看看是不是上面这两步。</p></li></ul><p>​        接下来在MyBatis的基础上再升级一下，整合MyBaitsPlus（简称MP），国人开发的技术，符合中国人开发习惯，谁用谁知道。来吧，一起做整合</p><p><strong>步骤①</strong>：导入对应的starter</p><pre class=" language-XML"><code class="language-XML"><dependency>    <groupId>com.baomidou</groupId>    <artifactId>mybatis-plus-boot-starter</artifactId>    <version>3.4.3</version></dependency></code></pre><p>​        关于这个坐标，此处要说明一点，之前我们看的starter都是spring-boot-starter-？？？，也就是说都是下面的格式</p><pre class=" language-tex"><code class="language-tex">Spring-boot-start-***</code></pre><p>​    而MyBatis与MyBatisPlus这两个坐标的名字书写比较特殊，是第三方技术名称在前，boot和starter在后。此处简单提一下命名规范，后期原理篇会再详细讲解</p><table><thead><tr><th>starter所属</th><th>命名规则</th><th>示例</th></tr></thead><tbody><tr><td>官方提供</td><td>spring-boot-starter-技术名称</td><td>spring-boot-starter-web <br/>spring-boot-starter-test</td></tr><tr><td>第三方提供</td><td>第三方技术名称-spring-boot-starter</td><td>mybatis-spring-boot-starter<br/>druid-spring-boot-starter</td></tr><tr><td>第三方提供</td><td>第三方技术名称-boot-starter（第三方技术名称过长，简化命名）</td><td>mybatis-plus-boot-starter</td></tr></tbody></table><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        有些小伙伴在创建项目时想通过勾选的形式找到这个名字，别翻了，没有。截止目前，SpringBoot官网还未收录此坐标，而我们Idea创建模块时读取的是SpringBoot官网的Spring Initializr，所以也没有。如果换用阿里云的url创建项目可以找到对应的坐标。</p><p><strong>步骤②</strong>：配置数据源相关信息</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true">#2.配置相关信息</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/ssm_db    <span class="token key atrule">username</span><span class="token punctuation">:</span> root    <span class="token key atrule">password</span><span class="token punctuation">:</span> root</code></pre><p>​    没了，就这么多，剩下的就是写MyBaitsPlus的程序了</p><p><strong>映射接口（Dao）</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@Mapperpublic interface BookDao extends BaseMapper<Book> &#123;&#125;</code></pre><p>​    核心在于Dao接口继承了一个BaseMapper的接口，这个接口中帮助开发者预定了若干个常用的API接口，简化了通用API接口的开发工作。</p><img src="img\image-20211129100313919.png" alt="image-20211129100313919" style="zoom:80%;" /><p>​    下面就可以写一个测试类进行测试了，此处省略。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        目前数据库的表名定义规则是tbl_模块名称，为了能和实体类相对应，需要做一个配置，相关知识各位小伙伴可以到MyBatisPlus课程中去学习，此处仅给出解决方案。配置application.yml文件，添加如下配置即可，设置所有表名的通用前缀名</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>      <span class="token key atrule">table-prefix</span><span class="token punctuation">:</span> tbl_        <span class="token comment" spellcheck="true">#设置所有表的通用前缀名称为tbl_</span></code></pre><p><strong>总结</strong></p><ol><li>手工添加MyBatis-Plus对应的starter</li><li>数据层接口使用BaseMapper简化开发</li><li>需要使用的第三方技术无法通过勾选确定时，需要手工添加坐标</li></ol><h3 id="JC-3-4-整合Druid"><a href="#JC-3-4-整合Druid" class="headerlink" title="JC-3-4.整合Druid"></a>JC-3-4.整合Druid</h3><p>​        使用SpringBoot整合了3个技术了，发现套路基本相同，导入对应的starter，然后做配置，各位小伙伴需要一直强化这套思想。下面再整合一个技术，继续深入强化此思想。</p><p>​        前面整合MyBatis和MyBatisPlus的时候，使用的数据源对象都是SpringBoot默认的数据源对象，下面我们手工控制一下，自己指定了一个数据源对象，Druid。</p><p>​        在没有指定数据源时，我们的配置如下：</p><pre class=" language-YAML"><code class="language-YAML">#2.配置相关信息spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=Asia/Shanghai    username: root    password: root</code></pre><p>​        此时虽然没有指定数据源，但是根据SpringBoot的德行，肯定帮我们选了一个它认为最好的数据源对象，这就是HiKari。通过启动日志可以查看到对应的身影。</p><pre class=" language-tex"><code class="language-tex">2021-11-29 09:39:15.202  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...2021-11-29 09:39:15.208  WARN 12260 --- [           main] com.zaxxer.hikari.util.DriverDataSource  : Registered driver with driverClassName=com.mysql.jdbc.Driver was not found, trying direct instantiation.2021-11-29 09:39:15.551  INFO 12260 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</code></pre><p>​        上述信息中每一行都有HiKari的身影，如果需要更换数据源，其实只需要两步即可。</p><ol><li><p>导入对应的技术坐标</p></li><li><p>配置使用指定的数据源类型</p><p> 下面就切换一下数据源对象</p></li></ol><p><strong>步骤①</strong>：导入对应的坐标（注意，是坐标，此处不是starter）</p><pre class=" language-XML"><code class="language-XML"><dependencies>    <dependency>        <groupId>com.alibaba</groupId>        <artifactId>druid</artifactId>        <version>1.1.16</version>    </dependency></dependencies></code></pre><p><strong>步骤②</strong>：修改配置，在数据源配置中有一个type属性，专用于指定数据源类型</p><pre class=" language-YAML"><code class="language-YAML">spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    username: root    password: root    type: com.alibaba.druid.pool.DruidDataSource</code></pre><p>​        这里其实要提出一个问题的，目前的数据源配置格式是一个通用格式，不管你换什么数据源都可以用这种形式进行配置。但是新的问题又来了，如果对数据源进行个性化的配置，例如配置数据源对应的连接数量，这个时候就有新的问题了。每个数据源技术对应的配置名称都一样吗？肯定不是啊，各个厂商不可能提前商量好都写一样的名字啊，怎么办？就要使用专用的配置格式了。这个时候上面这种通用格式就不能使用了，怎么办？还能怎么办？按照SpringBoot整合其他技术的通用规则来套啊，导入对应的starter，进行相应的配置即可。</p><p><strong>步骤①</strong>：导入对应的starter</p><pre class=" language-XML"><code class="language-XML"><dependencies>    <dependency>        <groupId>com.alibaba</groupId>        <artifactId>druid-spring-boot-starter</artifactId>        <version>1.2.6</version>    </dependency></dependencies></code></pre><p><strong>步骤②</strong>：修改配置</p><pre class=" language-YAML"><code class="language-YAML">spring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC      username: root      password: root</code></pre><p>​        注意观察，配置项中，在datasource下面并不是直接配置url这些属性的，而是先配置了一个druid节点，然后再配置的url这些东西。言外之意，url这个属性是druid下面的属性，那你能想到什么？除了这4个常规配置外，还有druid专用的其他配置。通过提示功能可以打开druid相关的配置查阅</p><img src="img\image-20211129112610729.png" alt="image-20211129112610729" style="zoom:80%;" /><p>​    与druid相关的配置超过200条以上，这就告诉你，如果想做druid相关的配置，使用这种格式就可以了，这里就不展开描述了，太多了。</p><p>​    这是我们做的第4个技术的整合方案，还是那两句话：<font color="#ff0000"><b>导入对应starter，使用对应配置</b></font>。没了，SpringBoot整合其他技术就这么简单粗暴。</p><p><strong>总结</strong></p><ol><li>整合Druid需要导入Druid对应的starter</li><li>根据Druid提供的配置方式进行配置</li><li>整合第三方技术通用方式<ul><li>导入对应的starter</li><li>根据提供的配置格式，配置非默认值对应的配置项</li></ul></li></ol><h3 id="JC-3-5-SSMP整合综合案例"><a href="#JC-3-5-SSMP整合综合案例" class="headerlink" title="JC-3-5.SSMP整合综合案例"></a>JC-3-5.SSMP整合综合案例</h3><p>​        SpringBoot能够整合的技术太多太多了，对于初学者来说慢慢来，一点点掌握。前面咱们做了4个整合了，下面就通过一个稍微综合一点的案例，将所有知识贯穿起来，同时做一个小功能，体会一下。不过有言在先，这个案例制作的时候，你可能会有这种感觉，说好的SpringBoot整合其他技术的案例，为什么感觉SpringBoot整合其他技术的身影不多呢？因为这东西书写太简单了，简单到瞬间写完，大量的时间做的不是这些整合工作。</p><p>​        先看一下这个案例的最终效果</p><p><strong>主页面</strong></p><p><img src="img%5Cimage-20211129113447844.png" alt="image-20211129113447844"></p><p><strong>添加</strong></p><p><img src="img%5Cimage-20211129113522459.png" alt="image-20211129113522459"></p><p><strong>删除</strong></p><p><img src="img%5Cimage-20211129113550829.png" alt="image-20211129113550829"></p><p><strong>修改</strong></p><p><img src="img%5Cimage-20211129113610966.png" alt="image-20211129113610966"></p><p><strong>分页</strong></p><p><img src="img%5Cimage-20211129113628969.png" alt="image-20211129113628969"></p><p><strong>条件查询</strong></p><p><img src="img%5Cimage-20211129113650369.png" alt="image-20211129113650369"></p><p>​    整体案例中需要采用的技术如下，先了解一下，做到哪一个说哪一个</p><ol><li>实体类开发————使用Lombok快速制作实体类</li><li>Dao开发————整合MyBatisPlus，制作数据层测试</li><li>Service开发————基于MyBatisPlus进行增量开发，制作业务层测试类</li><li>Controller开发————基于Restful开发，使用PostMan测试接口功能</li><li>Controller开发————前后端开发协议制作</li><li>页面开发————基于VUE+ElementUI制作，前后端联调，页面数据处理，页面消息处理<ul><li>列表</li><li>新增</li><li>修改</li><li>删除</li><li>分页</li><li>查询</li></ul></li><li>项目异常处理</li><li>按条件查询————页面功能调整、Controller修正功能、Service修正功能</li></ol><p>​        可以看的出来，东西还是很多的，希望通过这个案例，各位小伙伴能够完成基础开发的技能训练。整体开发过程采用做一层测一层的形式进行，过程完整，战线较长，希望各位能跟紧进度，完成这个小案例的制作。</p><h4 id="0-模块创建"><a href="#0-模块创建" class="headerlink" title="0.模块创建"></a>0.模块创建</h4><p>​        对于这个案例如果按照企业开发的形式进行应该制作后台微服务，前后端分离的开发。</p><img src="img\image-20211129114306062.png" alt="image-20211129114306062" style="zoom:80%;" /><p>​        我知道这个对初学的小伙伴要求太高了，咱们简化一下。后台做单体服务器，前端不使用前后端分离的制作了。</p><img src="img\image-20211129114328967.png" alt="image-20211129114328967" style="zoom:80%;" /><p>​        一个服务器即充当后台服务调用，又负责前端页面展示，降低学习的门槛。</p><p>​        下面我们创建一个新的模块，加载要使用的技术对应的starter，修改配置文件格式为yml格式，并把web访问端口先设置成80。</p><p><strong>pom.xml</strong></p><pre class=" language-XML"><code class="language-XML"><dependencies>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-web</artifactId>    </dependency>    <dependency>        <groupId>org.springframework.boot</groupId>        <artifactId>spring-boot-starter-test</artifactId>        <scope>test</scope>    </dependency></dependencies></code></pre><p><strong>application.yml</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><h4 id="1-实体类开发"><a href="#1-实体类开发" class="headerlink" title="1.实体类开发"></a>1.实体类开发</h4><p>​        本案例对应的模块表结构如下：</p><pre class=" language-tex"><code class="language-tex">-- ------------------------------ Table structure for tbl_book-- ----------------------------DROP TABLE IF EXISTS `tbl_book`;CREATE TABLE `tbl_book`  (  `id` int(11) NOT NULL AUTO_INCREMENT,  `type` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  `name` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,  PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 51 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;-- ------------------------------ Records of tbl_book-- ----------------------------INSERT INTO `tbl_book` VALUES (1, '计算机理论', 'Spring实战 第5版', 'Spring入门经典教程，深入理解Spring原理技术内幕');INSERT INTO `tbl_book` VALUES (2, '计算机理论', 'Spring 5核心原理与30个类手写实战', '十年沉淀之作，手写Spring精华思想');INSERT INTO `tbl_book` VALUES (3, '计算机理论', 'Spring 5 设计模式', '深入Spring源码剖析Spring源码中蕴含的10大设计模式');INSERT INTO `tbl_book` VALUES (4, '计算机理论', 'Spring MVC+MyBatis开发从入门到项目实战', '全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手');INSERT INTO `tbl_book` VALUES (5, '计算机理论', '轻量级Java Web企业应用实战', '源码级剖析Spring框架，适合已掌握Java基础的读者');INSERT INTO `tbl_book` VALUES (6, '计算机理论', 'Java核心技术 卷I 基础知识（原书第11版）', 'Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新');INSERT INTO `tbl_book` VALUES (7, '计算机理论', '深入理解Java虚拟机', '5个维度全面剖析JVM，大厂面试知识点全覆盖');INSERT INTO `tbl_book` VALUES (8, '计算机理论', 'Java编程思想（第4版）', 'Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉');INSERT INTO `tbl_book` VALUES (9, '计算机理论', '零基础学Java（全彩版）', '零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术');INSERT INTO `tbl_book` VALUES (10, '市场营销', '直播就该这么做：主播高效沟通实战指南', '李子柒、李佳琦、薇娅成长为网红的秘密都在书中');INSERT INTO `tbl_book` VALUES (11, '市场营销', '直播销讲实战一本通', '和秋叶一起学系列网络营销书籍');INSERT INTO `tbl_book` VALUES (12, '市场营销', '直播带货：淘宝、天猫直播从新手到高手', '一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+');</code></pre><p>​        根据上述表结构，制作对应的实体类</p><p><strong>实体类</strong></p><pre class=" language-JAVA"><code class="language-JAVA">public class Book &#123;    private Integer id;    private String type;    private String name;    private String description;&#125;</code></pre><p>​        实体类的开发可以自动通过工具手工生成get/set方法，然后覆盖toString()方法，方便调试，等等。不过这一套操作书写很繁琐，有对应的工具可以帮助我们简化开发，介绍一个小工具，lombok。</p><p>​        Lombok，一个Java类库，提供了一组注解，简化POJO实体类开发，SpringBoot目前默认集成了lombok技术，并提供了对应的版本控制，所以只需要提供对应的坐标即可，在pom.xml中添加lombok的坐标。</p><pre class=" language-XML"><code class="language-XML"><dependencies>    <!--lombok-->    <dependency>        <groupId>org.projectlombok</groupId>        <artifactId>lombok</artifactId>    </dependency></dependencies></code></pre><p>​        使用lombok可以通过一个注解@Data完成一个实体类对应的getter，setter，toString，equals，hashCode等操作的快速添加</p><pre class=" language-JAVA"><code class="language-JAVA">import lombok.Data;@Datapublic class Book &#123;    private Integer id;    private String type;    private String name;    private String description;&#125;</code></pre><p>​        到这里实体类就做好了，是不是比不使用lombok简化好多，这种工具在Java开发中还有N多，后面遇到了能用的实用开发技术时，在不增加各位小伙伴大量的学习时间的情况下，尽量多给大家介绍一些。</p><p><strong>总结</strong></p><ol><li>实体类制作</li><li>使用lombok简化开发<ul><li>导入lombok无需指定版本，由SpringBoot提供版本</li><li>@Data注解</li></ul></li></ol><h4 id="2-数据层开发——基础CRUD"><a href="#2-数据层开发——基础CRUD" class="headerlink" title="2.数据层开发——基础CRUD"></a>2.数据层开发——基础CRUD</h4><p>​        数据层开发本次使用MyBatisPlus技术，数据源使用前面学习的Druid，学都学了都用上。</p><p><strong>步骤①</strong>：导入MyBatisPlus与Druid对应的starter，当然mysql的驱动不能少</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.baomidou<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mybatis-plus-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.4.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>druid-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.2.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：配置数据库连接相关的数据源配置</p><pre class=" language-YAML"><code class="language-YAML">server:  port: 80spring:  datasource:    druid:      driver-class-name: com.mysql.cj.jdbc.Driver      url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC      username: root      password: root</code></pre><p><strong>步骤③</strong>：使用MyBatisPlus的标准通用接口BaseMapper加速开发，别忘了@Mapper和泛型的指定</p><pre class=" language-JAVA"><code class="language-JAVA">@Mapperpublic interface BookDao extends BaseMapper<Book> &#123;&#125;</code></pre><p><strong>步骤④</strong>：制作测试类测试结果，这个测试类制作是个好习惯，不过在企业开发中往往都为加速开发跳过此步，且行且珍惜吧</p><pre class=" language-JAVA"><code class="language-JAVA">package com.itheima.dao;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.core.metadata.IPage;import com.baomidou.mybatisplus.extension.plugins.pagination.Page;import com.itheima.domain.Book;import org.junit.jupiter.api.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;@SpringBootTestpublic class BookDaoTestCase &#123;    @Autowired    private BookDao bookDao;    @Test    void testGetById()&#123;        System.out.println(bookDao.selectById(1));    &#125;    @Test    void testSave()&#123;        Book book = new Book();        book.setType("测试数据123");        book.setName("测试数据123");        book.setDescription("测试数据123");        bookDao.insert(book);    &#125;    @Test    void testUpdate()&#123;        Book book = new Book();        book.setId(17);        book.setType("测试数据abcdefg");        book.setName("测试数据123");        book.setDescription("测试数据123");        bookDao.updateById(book);    &#125;    @Test    void testDelete()&#123;        bookDao.deleteById(16);    &#125;    @Test    void testGetAll()&#123;        bookDao.selectList(null);    &#125;&#125;</code></pre><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        MyBatisPlus技术默认的主键生成策略为雪花算法，生成的主键ID长度较大，和目前的数据库设定规则不相符，需要配置一下使MyBatisPlus使用数据库的主键生成策略，方式嘛还是老一套，做配置。在application.yml中添加对应配置即可，具体如下</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">druid</span><span class="token punctuation">:</span>      <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver      <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/ssm_db<span class="token punctuation">?</span>serverTimezone=UTC      <span class="token key atrule">username</span><span class="token punctuation">:</span> root      <span class="token key atrule">password</span><span class="token punctuation">:</span> root<span class="token key atrule">mybatis-plus</span><span class="token punctuation">:</span>  <span class="token key atrule">global-config</span><span class="token punctuation">:</span>    <span class="token key atrule">db-config</span><span class="token punctuation">:</span>      <span class="token key atrule">table-prefix</span><span class="token punctuation">:</span> tbl_        <span class="token comment" spellcheck="true">#设置表名通用前缀</span>      <span class="token key atrule">id-type</span><span class="token punctuation">:</span> auto                <span class="token comment" spellcheck="true">#设置主键id字段的生成策略为参照数据库设定的策略，当前数据库设置id生成策略为自增</span></code></pre><h5 id="查看MyBatisPlus运行日志"><a href="#查看MyBatisPlus运行日志" class="headerlink" title="查看MyBatisPlus运行日志"></a>查看MyBatisPlus运行日志</h5><p>​        在进行数据层测试的时候，因为基础的CRUD操作均由MyBatisPlus给我们提供了，所以就出现了一个局面，开发者不需要书写SQL语句了，这样程序运行的时候总有一种感觉，一切的一切都是黑盒的，作为开发者我们啥也不知道就完了。如果程序正常运行还好，如果报错了，这个时候就很崩溃，你甚至都不知道从何下手，因为传递参数、封装SQL语句这些操作完全不是你开发出来的，所以查看执行期运行的SQL语句就成为当务之急。</p><p>​        SpringBoot整合MyBatisPlus的时候充分考虑到了这点，通过配置的形式就可以查阅执行期SQL语句，配置如下</p><pre class=" language-YAML"><code class="language-YAML">mybatis-plus:  global-config:    db-config:      table-prefix: tbl_      id-type: auto  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><p>​        再来看运行结果，此时就显示了运行期执行SQL的情况。</p><pre class=" language-tex"><code class="language-tex">Creating a new SqlSessionSqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@2c9a6717] was not registered for synchronization because synchronization is not activeJDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@6ca30b8a] will not be managed by Spring==>  Preparing: SELECT id,type,name,description FROM tbl_book==> Parameters: <==    Columns: id, type, name, description<==        Row: 1, 计算机理论, Spring实战 第5版, Spring入门经典教程，深入理解Spring原理技术内幕<==        Row: 2, 计算机理论, Spring 5核心原理与30个类手写实战, 十年沉淀之作，手写Spring精华思想<==        Row: 3, 计算机理论, Spring 5 设计模式, 深入Spring源码剖析Spring源码中蕴含的10大设计模式<==        Row: 4, 计算机理论, Spring MVC+MyBatis开发从入门到项目实战, 全方位解析面向Web应用的轻量级框架，带你成为Spring MVC开发高手<==        Row: 5, 计算机理论, 轻量级Java Web企业应用实战, 源码级剖析Spring框架，适合已掌握Java基础的读者<==        Row: 6, 计算机理论, Java核心技术 卷I 基础知识（原书第11版）, Core Java 第11版，Jolt大奖获奖作品，针对Java SE9、10、11全面更新<==        Row: 7, 计算机理论, 深入理解Java虚拟机, 5个维度全面剖析JVM，大厂面试知识点全覆盖<==        Row: 8, 计算机理论, Java编程思想（第4版）, Java学习必读经典,殿堂级著作！赢得了全球程序员的广泛赞誉<==        Row: 9, 计算机理论, 零基础学Java（全彩版）, 零基础自学编程的入门图书，由浅入深，详解Java语言的编程思想和核心技术<==        Row: 10, 市场营销, 直播就该这么做：主播高效沟通实战指南, 李子柒、李佳琦、薇娅成长为网红的秘密都在书中<==        Row: 11, 市场营销, 直播销讲实战一本通, 和秋叶一起学系列网络营销书籍<==        Row: 12, 市场营销, 直播带货：淘宝、天猫直播从新手到高手, 一本教你如何玩转直播的书，10堂课轻松实现带货月入3W+<==        Row: 13, 测试类型, 测试数据, 测试描述数据<==        Row: 14, 测试数据update, 测试数据update, 测试数据update<==        Row: 15, -----------------, 测试数据123, 测试数据123<==      Total: 15</code></pre><p>​        其中清晰的标注了当前执行的SQL语句是什么，携带了什么参数，对应的执行结果是什么，所有信息应有尽有。</p><p>​        此处设置的是日志的显示形式，当前配置的是控制台输出，当然还可以由更多的选择，根据需求切换即可</p><img src="img\image-20211129143207295.png" alt="image-20211129143207295" style="zoom:80%;" /><p><strong>总结</strong></p><ol><li><p>手工导入starter坐标（2个），mysql驱动（1个）</p></li><li><p>配置数据源与MyBatisPlus对应的配置</p></li><li><p>开发Dao接口（继承BaseMapper）</p></li><li><p>制作测试类测试Dao功能是否有效</p></li><li><p>使用配置方式开启日志，设置日志输出方式为标准输出即可查阅SQL执行日志</p></li></ol><h4 id="3-数据层开发——分页功能制作"><a href="#3-数据层开发——分页功能制作" class="headerlink" title="3.数据层开发——分页功能制作"></a>3.数据层开发——分页功能制作</h4><p>​        前面仅仅是使用了MyBatisPlus提供的基础CRUD功能，实际上MyBatisPlus给我们提供了几乎所有的基础操作，这一节说一下如何实现数据库端的分页操作。</p><p>​        MyBatisPlus提供的分页操作API如下：</p><pre class=" language-JAVA"><code class="language-JAVA">@Testvoid testGetPage()&#123;    IPage page = new Page(2,5);    bookDao.selectPage(page, null);    System.out.println(page.getCurrent());    System.out.println(page.getSize());    System.out.println(page.getTotal());    System.out.println(page.getPages());    System.out.println(page.getRecords());&#125;</code></pre><p>​        其中selectPage方法需要传入一个封装分页数据的对象，可以通过new的形式创建这个对象，当然这个对象也是MyBatisPlus提供的，别选错包了。创建此对象时需要指定两个分页的基本数据</p><ul><li>当前显示第几页</li><li>每页显示几条数据</li></ul><p>​        可以通过创建Page对象时利用构造方法初始化这两个数据。</p><pre class=" language-JAVA"><code class="language-JAVA">IPage page = new Page(2,5);</code></pre><p>​        将该对象传入到查询方法selectPage后，可以得到查询结果，但是我们会发现当前操作查询结果返回值仍然是一个IPage对象，这又是怎么回事？</p><pre class=" language-JAVA"><code class="language-JAVA">IPage page = bookDao.selectPage(page, null);</code></pre><p>​        原来这个IPage对象中封装了若干个数据，而查询的结果作为IPage对象封装的一个数据存在的，可以理解为查询结果得到后，又塞到了这个IPage对象中，其实还是为了高度的封装，一个IPage描述了分页所有的信息。下面5个操作就是IPage对象中封装的所有信息了。</p><pre class=" language-JAVA"><code class="language-JAVA">@Testvoid testGetPage()&#123;    IPage page = new Page(2,5);    bookDao.selectPage(page, null);    System.out.println(page.getCurrent());        //当前页码值    System.out.println(page.getSize());            //每页显示数    System.out.println(page.getTotal());        //数据总量    System.out.println(page.getPages());        //总页数    System.out.println(page.getRecords());        //详细数据&#125;</code></pre><p>​        到这里就知道这些数据如何获取了，但是当你去执行这个操作时，你会发现并不像我们分析的这样，实际上这个分页功能当前是无效的。为什么这样呢？这个要源于MyBatisPlus的内部机制。</p><p>​        对于MySQL的分页操作使用limit关键字进行，而并不是所有的数据库都使用limit关键字实现的，这个时候MyBatisPlus为了制作的兼容性强，将分页操作设置为基础查询操作的升级版，你可以理解为IPhone6与IPhone6S-PLUS的关系。</p><p>​        基础操作中有查询全部的功能，而在这个基础上只需要升级一下（PLUS）就可以得到分页操作。所以MyBatisPlus将分页操作做成了一个开关，你用分页功能就把开关开启，不用就不需要开启这个开关。而我们现在没有开启这个开关，所以分页操作是没有的。这个开关是通过MyBatisPlus的拦截器的形式存在的，其中的原理这里不分析了，有兴趣的小伙伴可以学习MyBatisPlus这门课程进行详细解读。具体设置方式如下：</p><p><strong>定义MyBatisPlus拦截器并将其设置为Spring管控的bean</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@Configurationpublic class MPConfig &#123;    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor()&#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());        return interceptor;    &#125;&#125;</code></pre><p>​        上述代码第一行是创建MyBatisPlus的拦截器栈，这个时候拦截器栈中没有具体的拦截器，第二行是初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。</p><p><strong>总结</strong></p><ol><li>使用IPage封装分页数据</li><li>分页操作依赖MyBatisPlus分页拦截器实现功能</li><li>借助MyBatisPlus日志查阅执行SQL语句</li></ol><h4 id="4-数据层开发——条件查询功能制作"><a href="#4-数据层开发——条件查询功能制作" class="headerlink" title="4.数据层开发——条件查询功能制作"></a>4.数据层开发——条件查询功能制作</h4><p>​        除了分页功能，MyBatisPlus还提供有强大的条件查询功能。以往我们写条件查询要自己动态拼写复杂的SQL语句，现在简单了，MyBatisPlus将这些操作都制作成API接口，调用一个又一个的方法就可以实现各种条件的拼装。这里给大家普及一下基本格式，详细的操作还是到MyBatisPlus的课程中查阅吧。</p><p>​        下面的操作就是执行一个模糊匹配对应的操作，由like条件书写变为了like方法的调用。</p><pre class=" language-JAVA"><code class="language-JAVA">@Testvoid testGetBy()&#123;    QueryWrapper<Book> qw = new QueryWrapper<>();    qw.like("name","Spring");    bookDao.selectList(qw);&#125;</code></pre><p>​        其中第一句QueryWrapper对象是一个用于封装查询条件的对象，该对象可以动态使用API调用的方法添加条件，最终转化成对应的SQL语句。第二句就是一个条件了，需要什么条件，使用QueryWapper对象直接调用对应操作即可。比如做大于小于关系，就可以使用lt或gt方法，等于使用eq方法，等等，此处不做更多的解释了。</p><p>​        这组API使用还是比较简单的，但是关于属性字段名的书写存在着安全隐患，比如查询字段name，当前是以字符串的形态书写的，万一写错，编译器还没有办法发现，只能将问题抛到运行器通过异常堆栈告诉开发者，不太友好。</p><p>​        MyBatisPlus针对字段检查进行了功能升级，全面支持Lambda表达式，就有了下面这组API。由QueryWrapper对象升级为LambdaQueryWrapper对象，这下就避免了上述问题的出现。</p><pre class=" language-JAVA"><code class="language-JAVA">@Testvoid testGetBy2()&#123;    String name = "1";    LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();    lqw.like(Book::getName,name);    bookDao.selectList(lqw);&#125;</code></pre><p>​        为了便于开发者动态拼写SQL，防止将null数据作为条件使用，MyBatisPlus还提供了动态拼装SQL的快捷书写方式。</p><pre class=" language-JAVA"><code class="language-JAVA">@Testvoid testGetBy2()&#123;    String name = "1";    LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();    //if(name != null) lqw.like(Book::getName,name);        //方式一：JAVA代码控制    lqw.like(name != null,Book::getName,name);                //方式二：API接口提供控制开关    bookDao.selectList(lqw);&#125;</code></pre><p>​        其实就是个格式，没有区别。关于MyBatisPlus的基础操作就说到这里吧，如果这一块知识不太熟悉的小伙伴建议还是完整的学习一下MyBatisPlus的知识吧，这里只是蜻蜓点水的用了几个操作而已。</p><p><strong>总结</strong></p><ol><li><p>使用QueryWrapper对象封装查询条件</p></li><li><p>推荐使用LambdaQueryWrapper对象</p></li><li><p>所有查询操作封装成方法调用</p></li><li><p>查询条件支持动态条件拼装</p></li></ol><h4 id="5-业务层开发"><a href="#5-业务层开发" class="headerlink" title="5.业务层开发"></a>5.业务层开发</h4><p>​        数据层开发告一段落，下面进行业务层开发，其实标准业务层开发很多初学者认为就是调用数据层，怎么说呢？这个理解是没有大问题的，更精准的说法应该是<font color="#ff0000"><b>组织业务逻辑功能，并根据业务需求，对数据持久层发起调用</b></font>。有什么差别呢？目标是为了组织出符合需求的业务逻辑功能，至于调不调用数据层还真不好说，有需求就调用，没有需求就不调用。</p><p>​        一个常识性的知识普及一下，业务层的方法名定义一定要与业务有关，例如登录操作</p><pre class=" language-JAVA"><code class="language-JAVA">login(String username,String password);</code></pre><p>​        而数据层的方法名定义一定与业务无关，是一定，不是可能，也不是有可能，例如根据用户名密码查询</p><pre class=" language-JAVA"><code class="language-JAVA">selectByUserNameAndPassword(String username,String password);</code></pre><p>​        我们在开发的时候是可以根据完成的工作不同划分成不同职能的开发团队的。比如一个哥们制作数据层，他就可以不知道业务是什么样子，拿到的需求文档要求可能是这样的</p><pre class=" language-tex"><code class="language-tex">接口：传入用户名与密码字段，查询出对应结果，结果是单条数据接口：传入ID字段，查询出对应结果，结果是单条数据接口：传入离职字段，查询出对应结果，结果是多条数据</code></pre><p>​        但是进行业务功能开发的哥们，拿到的需求文档要求差别就很大</p><pre class=" language-tex"><code class="language-tex">接口：传入用户名与密码字段，对用户名字段做长度校验，4-15位，对密码字段做长度校验，8到24位，对密码字段做特殊字符校验，不允许存在空格，查询结果为对象。如果为null，返回BusinessException，封装消息码INFO_LOGON_USERNAME_PASSWORD_ERROR</code></pre><p>​        你比较一下，能是一回事吗？差别太大了，所以说业务层方法定义与数据层方法定义差异化很大，只不过有些入门级的开发者手懒或者没有使用过公司相关的ISO标准化文档而已。</p><p>​        多余的话不说了，咱们做案例就简单制作了，业务层接口定义如下：</p><pre class=" language-JAVA"><code class="language-JAVA">public interface BookService &#123;    Boolean save(Book book);    Boolean update(Book book);    Boolean delete(Integer id);    Book getById(Integer id);    List<Book> getAll();    IPage<Book> getPage(int currentPage,int pageSize);&#125;</code></pre><p>​        业务层实现类如下，转调数据层即可：</p><pre class=" language-JAVA"><code class="language-JAVA">@Servicepublic class BookServiceImpl implements BookService &#123;    @Autowired    private BookDao bookDao;    @Override    public Boolean save(Book book) &#123;        return bookDao.insert(book) > 0;    &#125;    @Override    public Boolean update(Book book) &#123;        return bookDao.updateById(book) > 0;    &#125;    @Override    public Boolean delete(Integer id) &#123;        return bookDao.deleteById(id) > 0;    &#125;    @Override    public Book getById(Integer id) &#123;        return bookDao.selectById(id);    &#125;    @Override    public List<Book> getAll() &#123;        return bookDao.selectList(null);    &#125;    @Override    public IPage<Book> getPage(int currentPage, int pageSize) &#123;        IPage page = new Page(currentPage,pageSize);        bookDao.selectPage(page,null);        return page;    &#125;&#125;</code></pre><p>​        别忘了对业务层接口进行测试，测试类如下：</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootTestpublic class BookServiceTest &#123;    @Autowired    private IBookService bookService;    @Test    void testGetById()&#123;        System.out.println(bookService.getById(4));    &#125;    @Test    void testSave()&#123;        Book book = new Book();        book.setType("测试数据123");        book.setName("测试数据123");        book.setDescription("测试数据123");        bookService.save(book);    &#125;    @Test    void testUpdate()&#123;        Book book = new Book();        book.setId(17);        book.setType("-----------------");        book.setName("测试数据123");        book.setDescription("测试数据123");        bookService.updateById(book);    &#125;    @Test    void testDelete()&#123;        bookService.removeById(18);    &#125;    @Test    void testGetAll()&#123;        bookService.list();    &#125;    @Test    void testGetPage()&#123;        IPage<Book> page = new Page<Book>(2,5);        bookService.page(page);        System.out.println(page.getCurrent());        System.out.println(page.getSize());        System.out.println(page.getTotal());        System.out.println(page.getPages());        System.out.println(page.getRecords());    &#125;&#125;</code></pre><p><strong>总结</strong></p><ol><li>Service接口名称定义成业务名称，并与Dao接口名称进行区分</li><li>制作测试类测试Service功能是否有效</li></ol><h5 id="业务层快速开发"><a href="#业务层快速开发" class="headerlink" title="业务层快速开发"></a>业务层快速开发</h5><p>​        其实MyBatisPlus技术不仅提供了数据层快速开发方案，业务层MyBatisPlus也给了一个通用接口，个人观点不推荐使用，凑合能用吧，其实就是一个封装+继承的思想，代码给出，实际开发慎用。</p><p>​        业务层接口快速开发</p><pre class=" language-JAVA"><code class="language-JAVA">public interface IBookService extends IService<Book> &#123;    //添加非通用操作API接口&#125;</code></pre><p>​        业务层接口实现类快速开发，关注继承的类需要传入两个泛型，一个是数据层接口，另一个是实体类。</p><pre class=" language-JAVA"><code class="language-JAVA">@Servicepublic class BookServiceImpl extends ServiceImpl<BookDao, Book> implements IBookService &#123;    @Autowired    private BookDao bookDao;    //添加非通用操作API&#125;</code></pre><p>​        如果感觉MyBatisPlus提供的功能不足以支撑你的使用需要（其实是一定不能支撑的，因为需求不可能是通用的），在原始接口基础上接着定义新的API接口就行了，此处不再说太多了，就是自定义自己的操作了，但是不要和已有的API接口名冲突即可。</p><p><strong>总结</strong></p><ol><li>使用通用接口（ISerivce<T>）快速开发Service</li><li>使用通用实现类（ServiceImpl&lt;M,T&gt;）快速开发ServiceImpl</li><li>可以在通用接口基础上做功能重载或功能追加</li><li>注意重载时不要覆盖原始操作，避免原始提供的功能丢失</li></ol><h4 id="6-表现层开发"><a href="#6-表现层开发" class="headerlink" title="6.表现层开发"></a>6.表现层开发</h4><p>​        终于做到表现层了，做了这么多都是基础工作。其实你现在回头看看，哪里还有什么SpringBoot的影子？前面1,2步就搞完了。继续完成表现层制作吧，咱们表现层的开发使用基于Restful的表现层接口开发，功能测试通过Postman工具进行。</p><p>​        表现层接口如下:</p><pre class=" language-JAVA"><code class="language-JAVA">@RestController@RequestMapping("/books")public class BookController2 &#123;    @Autowired    private IBookService bookService;    @GetMapping    public List<Book> getAll()&#123;        return bookService.list();    &#125;    @PostMapping    public Boolean save(@RequestBody Book book)&#123;        return bookService.save(book);    &#125;    @PutMapping    public Boolean update(@RequestBody Book book)&#123;        return bookService.modify(book);    &#125;    @DeleteMapping("&#123;id&#125;")    public Boolean delete(@PathVariable Integer id)&#123;        return bookService.delete(id);    &#125;    @GetMapping("&#123;id&#125;")    public Book getById(@PathVariable Integer id)&#123;        return bookService.getById(id);    &#125;    @GetMapping("&#123;currentPage&#125;/&#123;pageSize&#125;")    public IPage<Book> getPage(@PathVariable int currentPage,@PathVariable int pageSize)&#123;        return bookService.getPage(currentPage,pageSize, null);    &#125;&#125;</code></pre><p>​        在使用Postman测试时关注提交类型，对应上即可，不然就会报405的错误码了。</p><p><strong>普通GET请求</strong></p><p><img src="img%5Cimage-20211129152237371.png" alt="image-20211129152237371"></p><p><strong>PUT请求传递json数据，后台实用@RequestBody接收数据</strong></p><p><img src="img%5Cimage-20211129152300177.png" alt="image-20211129152300177"></p><p><strong>GET请求传递路径变量，后台实用@PathVariable接收数据</strong></p><p><img src="img%5Cimage-20211129152320073.png" alt="image-20211129152320073"></p><p><strong>总结</strong></p><ol><li>基于Restful制作表现层接口<ul><li>新增：POST</li><li>删除：DELETE</li><li>修改：PUT</li><li>查询：GET</li></ul></li><li>接收参数<ul><li>实体数据：@RequestBody</li><li>路径变量：@PathVariable</li></ul></li></ol><h4 id="7-表现层消息一致性处理"><a href="#7-表现层消息一致性处理" class="headerlink" title="7.表现层消息一致性处理"></a>7.表现层消息一致性处理</h4><p>​        目前我们通过Postman测试后业务层接口功能是通的，但是这样的结果给到前端开发者会出现一个小问题。不同的操作结果所展示的数据格式差异化严重。</p><p>​    <strong>增删改操作结果</strong></p><pre class=" language-tex"><code class="language-tex">true</code></pre><p>​    <strong>查询单个数据操作结果</strong></p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"计算机理论"</span><span class="token punctuation">,</span>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Spring实战 第5版"</span><span class="token punctuation">,</span>    <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"Spring入门经典教程"</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​    <strong>查询全部数据操作结果</strong></p><pre class=" language-json"><code class="language-json"><span class="token punctuation">[</span>    &amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"计算机理论"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Spring实战 第5版"</span><span class="token punctuation">,</span>        <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"Spring入门经典教程"</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    &amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"计算机理论"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Spring 5核心原理与30个类手写实战"</span><span class="token punctuation">,</span>        <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"十年沉淀之作"</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">]</span></code></pre><p>​        每种不同操作返回的数据格式都不一样，而且还不知道以后还会有什么格式，这样的结果让前端人员看了是很容易让人崩溃的，必须将所有操作的操作结果数据格式统一起来，需要设计表现层返回结果的模型类，用于后端与前端进行数据格式统一，也称为<strong>前后端数据协议</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@Datapublic class R &#123;    private Boolean flag;    private Object data;&#125;</code></pre><p>​        其中flag用于标识操作是否成功，data用于封装操作数据，现在的数据格式就变了</p><pre class=" language-JSON"><code class="language-JSON">&#123;    "flag": true,    "data":&#123;        "id": 1,        "type": "计算机理论",        "name": "Spring实战 第5版",        "description": "Spring入门经典教程"    &#125;&#125;</code></pre><p>​        表现层开发格式也需要转换一下</p><img src="img\image-20211129153301262.png" alt="image-20211129153301262" style="zoom:80%;" /><img src="img\image-20211129153319052.png" alt="image-20211129153319052" style="zoom:80%;" /><img src="img\image-20211129153332499.png" alt="image-20211129153332499" style="zoom:80%;" /><p>​        结果这么一折腾，全格式统一，现在后端发送给前端的数据格式就统一了，免去了不少前端解析数据的烦恼。</p><p><strong>总结</strong></p><ol><li><p>设计统一的返回值结果类型便于前端开发读取数据</p></li><li><p>返回值结果类型可以根据需求自行设定，没有固定格式</p></li><li><p>返回值结果模型类用于后端与前端进行数据格式统一，也称为前后端数据协议</p></li></ol><h4 id="8-前后端联通性测试"><a href="#8-前后端联通性测试" class="headerlink" title="8.前后端联通性测试"></a>8.前后端联通性测试</h4><p>​        后端的表现层接口开发完毕，就可以进行前端的开发了。</p><p>​        将前端人员开发的页面保存到lresources目录下的static目录中，建议执行maven的clean生命周期，避免缓存的问题出现。</p><p>​    <img src="img\image-20211129153831990.png" alt="image-20211129153831990" style="zoom:67%;" /></p><p>​        在进行具体的功能开发之前，先做联通性的测试，通过页面发送异步提交（axios），这一步调试通过后再进行进一步的功能开发。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//列表</span><span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span></code></pre><p>​        只要后台代码能够正常工作，前端能够在日志中接收到数据，就证明前后端是通的，也就可以进行下一步的功能开发了。</p><p><strong>总结</strong></p><ol><li>单体项目中页面放置在resources/static目录下</li><li>created钩子函数用于初始化页面时发起调用</li><li>页面使用axios发送异步请求获取数据后确认前后端是否联通</li></ol><h4 id="9-页面基础功能开发"><a href="#9-页面基础功能开发" class="headerlink" title="9.页面基础功能开发"></a>9.页面基础功能开发</h4><h5 id="F-1-列表功能（非分页版）"><a href="#F-1-列表功能（非分页版）" class="headerlink" title="F-1.列表功能（非分页版）"></a>F-1.列表功能（非分页版）</h5><p>​        列表功能主要操作就是加载完数据，将数据展示到页面上，此处要利用VUE的数据模型绑定，发送请求得到数据，然后页面上读取指定数据即可。</p><p>​        <strong>页面数据模型定义</strong></p><pre class=" language-js"><code class="language-js">data<span class="token punctuation">:</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    dataList<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//当前页要展示的列表数据</span>    <span class="token operator">...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span></code></pre><p>​        异步请求获取数据</p><pre class=" language-JS"><code class="language-JS">//列表getAll() &#123;    axios.get("/books").then((res)=>&#123;        this.dataList = res.data.data;    &#125;);&#125;,</code></pre><p>​        这样在页面加载时就可以获取到数据，并且由VUE将数据展示到页面上了。</p><p>总结：</p><ol><li>将查询数据返回到页面，利用前端数据绑定进行数据展示</li></ol><h5 id="F-2-添加功能"><a href="#F-2-添加功能" class="headerlink" title="F-2.添加功能"></a>F-2.添加功能</h5><p>​        添加功能用于收集数据的表单是通过一个弹窗展示的，因此在添加操作前首先要进行弹窗的展示，添加后隐藏弹窗即可。因为这个弹窗一直存在，因此当页面加载时首先设置这个弹窗为不可显示状态，需要展示，切换状态即可。</p><p>​        <strong>默认状态</strong></p><pre class=" language-js"><code class="language-js">data<span class="token punctuation">:</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    dialogFormVisible<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//添加表单是否可见</span>    <span class="token operator">...</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span></code></pre><p>​        <strong>切换为显示状态</strong></p><pre class=" language-JS"><code class="language-JS">//弹出添加窗口handleCreate() &#123;    this.dialogFormVisible = true;&#125;,</code></pre><p>​        由于每次添加数据都是使用同一个弹窗录入数据，所以每次操作的痕迹将在下一次操作时展示出来，需要在每次操作之前清理掉上次操作的痕迹。</p><p>​        <strong>定义清理数据操作</strong></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//重置表单</span><span class="token function">resetForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>formData <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span></code></pre><p>​        <strong>切换弹窗状态时清理数据</strong></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//弹出添加窗口</span><span class="token function">handleCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dialogFormVisible <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">resetForm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span></code></pre><p>​        至此准备工作完成，下面就要调用后台完成添加操作了。</p><p>​        <strong>添加操作</strong></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//添加</span>handleAdd <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//发送异步请求</span>    axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>formData<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//如果操作成功，关闭弹层，显示数据</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>flag<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>dialogFormVisible <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$message<span class="token punctuation">.</span><span class="token function">success</span><span class="token punctuation">(</span><span class="token string">"添加成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>$message<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"添加失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">finally</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span></code></pre><ol><li>将要保存的数据传递到后台，通过post请求的第二个参数传递json数据到后台</li><li>根据返回的操作结果决定下一步操作<ul><li>如何是true就关闭添加窗口，显示添加成功的消息</li><li>如果是false保留添加窗口，显示添加失败的消息</li></ul></li><li>无论添加是否成功，页面均进行刷新，动态加载数据（对getAll操作发起调用）</li></ol><p>​        <strong>取消添加操作</strong></p><pre class=" language-JS"><code class="language-JS">//取消cancel()&#123;    this.dialogFormVisible = false;    this.$message.info("操作取消");&#125;,</code></pre><p><strong>总结</strong></p><ol><li>请求方式使用POST调用后台对应操作</li><li>添加操作结束后动态刷新页面加载数据</li><li>根据操作结果不同，显示对应的提示信息</li><li>弹出添加Div时清除表单数据</li></ol><h5 id="F-3-删除功能"><a href="#F-3-删除功能" class="headerlink" title="F-3.删除功能"></a>F-3.删除功能</h5><p>​        模仿添加操作制作删除功能，差别之处在于删除操作仅传递一个待删除的数据id到后台即可。</p><p>​        <strong>删除操作</strong></p><pre class=" language-JS"><code class="language-JS">// 删除handleDelete(row) &#123;    axios.delete("/books/"+row.id).then((res)=>&#123;        if(res.data.flag)&#123;            this.$message.success("删除成功");        &#125;else&#123;            this.$message.error("删除失败");        &#125;    &#125;).finally(()=>&#123;        this.getAll();    &#125;);&#125;,</code></pre><p>​        <strong>删除操作提示信息</strong></p><pre class=" language-JS"><code class="language-JS">// 删除handleDelete(row) &#123;    //1.弹出提示框    this.$confirm("此操作永久删除当前数据，是否继续？","提示",&#123;        type:'info'    &#125;).then(()=>&#123;        //2.做删除业务        axios.delete("/books/"+row.id).then((res)=>&#123;               if(res.data.flag)&#123;                this.$message.success("删除成功");            &#125;else&#123;                this.$message.error("删除失败");            &#125;        &#125;).finally(()=>&#123;            this.getAll();        &#125;);    &#125;).catch(()=>&#123;        //3.取消删除        this.$message.info("取消删除操作");    &#125;);&#125;，    </code></pre><p><strong>总结</strong></p><ol><li>请求方式使用Delete调用后台对应操作</li><li>删除操作需要传递当前行数据对应的id值到后台</li><li>删除操作结束后动态刷新页面加载数据</li><li>根据操作结果不同，显示对应的提示信息</li><li>删除操作前弹出提示框避免误操作</li></ol><h5 id="F-4-修改功能"><a href="#F-4-修改功能" class="headerlink" title="F-4.修改功能"></a>F-4.修改功能</h5><p>​        修改功能可以说是列表功能、删除功能与添加功能的合体。几个相似点如下：</p><ol><li><p>页面也需要有一个弹窗用来加载修改的数据，这一点与添加相同，都是要弹窗</p></li><li><p>弹出窗口中要加载待修改的数据，而数据需要通过查询得到，这一点与查询全部相同，都是要查数据</p></li><li><p>查询操作需要将要修改的数据id发送到后台，这一点与删除相同，都是传递id到后台</p></li><li><p>查询得到数据后需要展示到弹窗中，这一点与查询全部相同，都是要通过数据模型绑定展示数据</p></li><li><p>修改数据时需要将被修改的数据传递到后台，这一点与添加相同，都是要传递数据</p><p>所以整体上来看，修改功能就是前面几个功能的大合体</p><p><strong>查询并展示数据</strong></p></li></ol><pre class=" language-JS"><code class="language-JS">//弹出编辑窗口handleUpdate(row) &#123;    axios.get("/books/"+row.id).then((res)=>&#123;        if(res.data.flag)&#123;            //展示弹层，加载数据            this.formData = res.data.data;            this.dialogFormVisible4Edit = true;        &#125;else&#123;            this.$message.error("数据同步失败，自动刷新");        &#125;    &#125;);&#125;,</code></pre><p>​        <strong>修改操作</strong></p><pre class=" language-JS"><code class="language-JS">//修改handleEdit() &#123;    axios.put("/books",this.formData).then((res)=>&#123;        //如果操作成功，关闭弹层并刷新页面        if(res.data.flag)&#123;            this.dialogFormVisible4Edit = false;            this.$message.success("修改成功");        &#125;else &#123;            this.$message.error("修改失败，请重试");        &#125;    &#125;).finally(()=>&#123;        this.getAll();    &#125;);&#125;,</code></pre><p><strong>总结</strong></p><ol><li>加载要修改数据通过传递当前行数据对应的id值到后台查询数据（同删除与查询全部）</li><li>利用前端双向数据绑定将查询到的数据进行回显（同查询全部）</li><li>请求方式使用PUT调用后台对应操作（同新增传递数据）</li><li>修改操作结束后动态刷新页面加载数据（同新增）</li><li>根据操作结果不同，显示对应的提示信息（同新增）</li></ol><p>​    </p><h4 id="10-业务消息一致性处理"><a href="#10-业务消息一致性处理" class="headerlink" title="10.业务消息一致性处理"></a>10.业务消息一致性处理</h4><p>​        目前的功能制作基本上达成了正常使用的情况，什么叫正常使用呢？也就是这个程序不出BUG，如果我们搞一个BUG出来，你会发现程序马上崩溃掉。比如后台手工抛出一个异常，看看前端接收到的数据什么样子。</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"timestamp"</span><span class="token operator">:</span> <span class="token string">"2021-09-15T03:27:31.038+00:00"</span><span class="token punctuation">,</span>    <span class="token property">"status"</span><span class="token operator">:</span> <span class="token number">500</span><span class="token punctuation">,</span>    <span class="token property">"error"</span><span class="token operator">:</span> <span class="token string">"Internal Server Error"</span><span class="token punctuation">,</span>    <span class="token property">"path"</span><span class="token operator">:</span> <span class="token string">"/books"</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        面对这种情况，前端的同学又不会了，这又是什么格式？怎么和之前的格式不一样？</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"flag"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"data"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"计算机理论"</span><span class="token punctuation">,</span>        <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"Spring实战 第5版"</span><span class="token punctuation">,</span>        <span class="token property">"description"</span><span class="token operator">:</span> <span class="token string">"Spring入门经典教程"</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        看来不仅要对正确的操作数据格式做处理，还要对错误的操作数据格式做同样的格式处理。</p><p>​        首先在当前的数据结果中添加消息字段，用来兼容后台出现的操作消息。</p><pre class=" language-JAVA"><code class="language-JAVA">@Datapublic class R&#123;    private Boolean flag;    private Object data;    private String msg;        //用于封装消息&#125;</code></pre><p>​        后台代码也要根据情况做处理，当前是模拟的错误。</p><pre class=" language-JAVA"><code class="language-JAVA">@PostMappingpublic R save(@RequestBody Book book) throws IOException &#123;    Boolean flag = bookService.insert(book);    return new R(flag , flag ? "添加成功^_^" : "添加失败-_-!");&#125;</code></pre><p>​        然后在表现层做统一的异常处理，使用SpringMVC提供的异常处理器做统一的异常处理。</p><pre class=" language-JAVA"><code class="language-JAVA">@RestControllerAdvicepublic class ProjectExceptionAdvice &#123;    @ExceptionHandler(Exception.class)    public R doOtherException(Exception ex)&#123;        //记录日志        //发送消息给运维        //发送邮件给开发人员,ex对象发送给开发人员        ex.printStackTrace();        return new R(false,null,"系统错误，请稍后再试！");    &#125;&#125;</code></pre><p>​        页面上得到数据后，先判定是否有后台传递过来的消息，标志就是当前操作是否成功，如果返回操作结果false，就读取后台传递的消息。</p><pre class=" language-JS"><code class="language-JS">//添加handleAdd () &#123;    //发送ajax请求    axios.post("/books",this.formData).then((res)=>&#123;        //如果操作成功，关闭弹层，显示数据        if(res.data.flag)&#123;            this.dialogFormVisible = false;            this.$message.success("添加成功");        &#125;else &#123;            this.$message.error(res.data.msg);            //消息来自于后台传递过来，而非固定内容        &#125;    &#125;).finally(()=>&#123;        this.getAll();    &#125;);&#125;,</code></pre><p><strong>总结</strong></p><ol><li>使用注解@RestControllerAdvice定义SpringMVC异常处理器用来处理异常的</li><li>异常处理器必须被扫描加载，否则无法生效</li><li>表现层返回结果的模型类中添加消息属性用来传递消息到页面</li></ol><p>​    </p><h4 id="11-页面功能开发"><a href="#11-页面功能开发" class="headerlink" title="11.页面功能开发"></a>11.页面功能开发</h4><h5 id="F-5-分页功能"><a href="#F-5-分页功能" class="headerlink" title="F-5.分页功能"></a>F-5.分页功能</h5><p>​        分页功能的制作用于替换前面的查询全部，其中要使用到elementUI提供的分页组件。</p><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>分页组件<span class="token operator">--</span><span class="token operator">></span><span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"pagination-container"</span><span class="token operator">></span>    <span class="token operator">&lt;</span>el<span class="token operator">-</span>pagination        <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"pagiantion"</span>        @current<span class="token operator">-</span>change<span class="token operator">=</span><span class="token string">"handleCurrentChange"</span>        <span class="token punctuation">:</span>current<span class="token operator">-</span>page<span class="token operator">=</span><span class="token string">"pagination.currentPage"</span>        <span class="token punctuation">:</span>page<span class="token operator">-</span>size<span class="token operator">=</span><span class="token string">"pagination.pageSize"</span>        layout<span class="token operator">=</span><span class="token string">"total, prev, pager, next, jumper"</span>        <span class="token punctuation">:</span>total<span class="token operator">=</span><span class="token string">"pagination.total"</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>el<span class="token operator">-</span>pagination<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span></code></pre><p>​        为了配合分页组件，封装分页对应的数据模型。</p><pre class=" language-js"><code class="language-js">data<span class="token punctuation">:</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    pagination<span class="token punctuation">:</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//分页相关模型数据</span>        currentPage<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//当前页码</span>        pageSize<span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//每页显示的记录数</span>        total<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">//总记录数</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span></code></pre><p>​        修改查询全部功能为分页查询，通过路径变量传递页码信息参数。</p><pre class=" language-JS"><code class="language-JS">getAll() &#123;    axios.get("/books/"+this.pagination.currentPage+"/"+this.pagination.pageSize).then((res) => &#123;    &#125;);&#125;,</code></pre><p>​        后台提供对应的分页功能。</p><pre class=" language-JAVA"><code class="language-JAVA">@GetMapping("/&#123;currentPage&#125;/&#123;pageSize&#125;")public R getAll(@PathVariable Integer currentPage,@PathVariable Integer pageSize)&#123;    IPage<Book> pageBook = bookService.getPage(currentPage, pageSize);    return new R(null != pageBook ,pageBook);&#125;</code></pre><p>​        页面根据分页操作结果读取对应数据，并进行数据模型绑定。</p><pre class=" language-JS"><code class="language-JS">getAll() &#123;    axios.get("/books/"+this.pagination.currentPage+"/"+this.pagination.pageSize).then((res) => &#123;        this.pagination.total = res.data.data.total;        this.pagination.currentPage = res.data.data.current;        this.pagination.pagesize = res.data.data.size;        this.dataList = res.data.data.records;    &#125;);&#125;,</code></pre><p>​        对切换页码操作设置调用当前分页操作。</p><pre class=" language-JS"><code class="language-JS">//切换页码handleCurrentChange(currentPage) &#123;    this.pagination.currentPage = currentPage;    this.getAll();&#125;,</code></pre><p><strong>总结</strong></p><ol><li>使用el分页组件</li><li>定义分页组件绑定的数据模型</li><li>异步调用获取分页数据</li><li>分页数据页面回显</li></ol><h5 id="F-6-删除功能维护"><a href="#F-6-删除功能维护" class="headerlink" title="F-6.删除功能维护"></a>F-6.删除功能维护</h5><p>​        由于使用了分页功能，当最后一页只有一条数据时，删除操作就会出现BUG，最后一页无数据但是独立展示，对分页查询功能进行后台功能维护，如果当前页码值大于最大页码值，重新执行查询。其实这个问题解决方案很多，这里给出比较简单的一种处理方案。</p><pre class=" language-JAVA"><code class="language-JAVA">@GetMapping("&#123;currentPage&#125;/&#123;pageSize&#125;")public R getPage(@PathVariable int currentPage,@PathVariable int pageSize)&#123;    IPage<Book> page = bookService.getPage(currentPage, pageSize);    //如果当前页码值大于了总页码值，那么重新执行查询操作，使用最大页码值作为当前页码值    if( currentPage > page.getPages())&#123;        page = bookService.getPage((int)page.getPages(), pageSize);    &#125;    return new R(true, page);&#125;</code></pre><h5 id="F-7-条件查询功能"><a href="#F-7-条件查询功能" class="headerlink" title="F-7.条件查询功能"></a>F-7.条件查询功能</h5><p>​        最后一个功能来做条件查询，其实条件查询可以理解为分页查询的时候除了携带分页数据再多带几个数据的查询。这些多带的数据就是查询条件。比较一下不带条件的分页查询与带条件的分页查询差别之处，这个功能就好做了</p><ul><li><p>页面封装的数据：带不带条件影响的仅仅是一次性传递到后台的数据总量，由传递2个分页相关数据转换成2个分页数据加若干个条件</p></li><li><p>后台查询功能：查询时由不带条件，转换成带条件，反正不带条件的时候查询条件对象使用的是null，现在换成具体条件，差别不大</p></li><li><p>查询结果：不管带不带条件，出来的数据只是有数量上的差别，其他都差别，这个可以忽略</p><p>经过上述分析，看来需要在页面发送请求的格式方面做一定的修改，后台的调用数据层操作时发送修改，其他没有区别。</p><p>页面发送请求时，两个分页数据仍然使用路径变量，其他条件采用动态拼装url参数的形式传递。</p><p><strong>页面封装查询条件字段</strong></p><pre class=" language-vue"><code class="language-vue">pagination: &#123;        //分页相关模型数据    currentPage: 1,        //当前页码    pageSize:10,        //每页显示的记录数    total:0,            //总记录数    name: "",    type: "",    description: ""&#125;,</code></pre><p>页面添加查询条件字段对应的数据模型绑定名称</p><pre class=" language-HTML"><code class="language-HTML"><div class="filter-container">    <el-input placeholder="图书类别" v-model="pagination.type" class="filter-item"/>    <el-input placeholder="图书名称" v-model="pagination.name" class="filter-item"/>    <el-input placeholder="图书描述" v-model="pagination.description" class="filter-item"/>    <el-button @click="getAll()" class="dalfBut">查询</el-button>    <el-button type="primary" class="butT" @click="handleCreate()">新建</el-button></div></code></pre><p>将查询条件组织成url参数，添加到请求url地址中，这里可以借助其他类库快速开发，当前使用手工形式拼接，降低学习要求</p><pre class=" language-JS"><code class="language-JS">getAll() &#123;    //1.获取查询条件,拼接查询条件    param = "?name="+this.pagination.name;    param += "&type="+this.pagination.type;    param += "&description="+this.pagination.description;    console.log("-----------------"+ param);    axios.get("/books/"+this.pagination.currentPage+"/"+this.pagination.pageSize+param).then((res) => &#123;        this.dataList = res.data.data.records;    &#125;);&#125;,</code></pre><p>后台代码中定义实体类封查询条件</p><pre class=" language-JAVA"><code class="language-JAVA">@GetMapping("&#123;currentPage&#125;/&#123;pageSize&#125;")public R getAll(@PathVariable int currentPage,@PathVariable int pageSize,Book book) &#123;    System.out.println("参数=====>"+book);    IPage<Book> pageBook = bookService.getPage(currentPage,pageSize);    return new R(null != pageBook ,pageBook);&#125;</code></pre><p>对应业务层接口与实现类进行修正</p><pre class=" language-JAVA"><code class="language-JAVA">public interface IBookService extends IService<Book> &#123;    IPage<Book> getPage(Integer currentPage,Integer pageSize,Book queryBook);&#125;</code></pre><pre class=" language-JAVA"><code class="language-JAVA">@Servicepublic class BookServiceImpl2 extends ServiceImpl<BookDao,Book> implements IBookService &#123;    public IPage<Book> getPage(Integer currentPage,Integer pageSize,Book queryBook)&#123;        IPage page = new Page(currentPage,pageSize);        LambdaQueryWrapper<Book> lqw = new LambdaQueryWrapper<Book>();        lqw.like(Strings.isNotEmpty(queryBook.getName()),Book::getName,queryBook.getName());        lqw.like(Strings.isNotEmpty(queryBook.getType()),Book::getType,queryBook.getType());        lqw.like(Strings.isNotEmpty(queryBook.getDescription()),Book::getDescription,queryBook.getDescription());        return bookDao.selectPage(page,lqw);    &#125;&#125;</code></pre><p>页面回显数据</p><pre class=" language-js"><code class="language-js"><span class="token function">getAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//1.获取查询条件,拼接查询条件</span>    param <span class="token operator">=</span> <span class="token string">"?name="</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>name<span class="token punctuation">;</span>    param <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"&amp;type="</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>type<span class="token punctuation">;</span>    param <span class="token operator">+</span><span class="token operator">=</span> <span class="token string">"&amp;description="</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>description<span class="token punctuation">;</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"-----------------"</span><span class="token operator">+</span> param<span class="token punctuation">)</span><span class="token punctuation">;</span>    axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"/books/"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>currentPage<span class="token operator">+</span><span class="token string">"/"</span><span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>pageSize<span class="token operator">+</span>param<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>total <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data<span class="token punctuation">.</span>total<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>currentPage <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data<span class="token punctuation">.</span>current<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pagination<span class="token punctuation">.</span>pagesize <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data<span class="token punctuation">.</span>size<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>dataList <span class="token operator">=</span> res<span class="token punctuation">.</span>data<span class="token punctuation">.</span>data<span class="token punctuation">.</span>records<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span></code></pre></li></ul><p><strong>总结</strong></p><ol><li>定义查询条件数据模型（当前封装到分页数据模型中）</li><li>异步调用分页功能并通过请求参数传递数据到后台</li></ol><h2 id="基础篇完结"><a href="#基础篇完结" class="headerlink" title="基础篇完结"></a>基础篇完结</h2><p>​        基础篇到这里就全部结束了，在基础篇中带着大家学习了如何创建一个SpringBoot工程，然后学习了SpringBoot的基础配置语法格式，接下来对常见的市面上的实用技术做了整合，最后通过一个小的案例对前面学习的内容做了一个综合应用。整体来说就是一个最基本的入门，关于SpringBoot的实际开发其实接触的还是很少的，我们到实用篇和原理篇中继续吧，各位小伙伴，加油学习，再见。</p><h1 id="SpringBoot运维实用篇"><a href="#SpringBoot运维实用篇" class="headerlink" title="SpringBoot运维实用篇"></a>SpringBoot运维实用篇</h1><p>​        基础篇发布以后，看到了很多小伙伴在网上的留言，也帮助超过100位小伙伴解决了一些遇到的问题，并且已经发现了部分问题具有典型性，预计将有些问题在后面篇章的合适位置添加到本套课程中，作为解决方案提供给大家。</p><p>​        从此刻开始，咱们就要进入到实用篇的学习了。实用篇是在基础篇的根基之上，补全SpringBoot的知识图谱。比如在基础篇中只给大家讲了yaml的语法格式，但是具体写yaml文件的时候还有很多实用开发过程中的坑，这些在实用篇中都要进行学习。</p><p>​        实用篇共分为两块内容，分别是运维实用篇和开发实用篇。其实划分的标准是我自己制定的，因为这里面的知识有一些还是比较散的，做两个阶段的划分是为了更好的将同类知识点进行归类，帮助学习者找到知识之间的关联性，这样有助于知识的记忆存储转换，经过一系列的知识反复出现与强化练习，将临时记忆转换成永久性记忆。做课程嘛，不能仅以讲完为目标，要以学习者的学习收获为目标，这也是我这么多年教学秉承的基本理念。</p><p>​        下面就从运维实用篇开始讲，在运维实用篇中，我给学习者的定位是玩转配置，为开发实用篇中做各种技术的整合做好准备工作。与开发实用篇相比，运维实用篇的内容显得略微单薄，并且有部分知识模块在运维实用篇和开发实用篇中都要讲一部分，这些内容都后置到开发实用篇中了。废话不说了，先看看运维实用篇中都包含哪些内容：</p><ul><li>SpringBoot程序的打包与运行</li><li>配置高级</li><li>多环境开发</li><li>日志</li></ul><p>​        下面开启第一部分SpringBoot程序打包与运行的学习</p><h2 id="YW-1-SpringBoot程序的打包与运行"><a href="#YW-1-SpringBoot程序的打包与运行" class="headerlink" title="YW-1.SpringBoot程序的打包与运行"></a>YW-1.SpringBoot程序的打包与运行</h2><p>​        刚开始做开发学习的小伙伴可能在有一个知识上面有错误的认知，我们天天写程序是在Idea下写的，运行也是在Idea下运行的。</p><img src="img\image-20211201091317258.png" alt="image-20211201091317258" style="zoom:67%;" /><p>​        但是实际开发完成后，我们的项目是不可能运行在自己的电脑上的。</p><img src="img\image-20211201091341645.png" alt="image-20211201091341645" style="zoom:67%;" /><p>​        我们以后制作的程序是运行在专用的服务器上的，简单说就是将你做的程序放在一台独立运行的电脑上，这台电脑要比你开发使用的计算机更专业，并且安全等级各个方面要远超过你现在的电脑。</p><img src="img\image-20211201091502040.png" alt="image-20211201091502040" style="zoom:67%;" /><p>​        那我们的程序如何放置在这台专用的电脑上呢，这就要将我们的程序先组织成一个文件，然后将这个文件传输到这台服务器上。这里面就存在两个过程，一个是打包的过程，另一个是运行的过程。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        企业项目上线为了保障环境适配性会采用下面流程发布项目，这里不讨论此过程。</p><ol><li>开发部门使用Git、SVN等版本控制工具上传工程到版本服务器</li><li>服务器使用版本控制工具下载工程</li><li>服务器上使用Maven工具在当前真机环境下重新构建项目</li><li>启动服务</li></ol><p>​        继续说我们的打包和运行过程。所谓打包指将程序转换成一个可执行的文件，所谓运行指不依赖开发环境执行打包产生的文件。上述两个操作都有对应的命令可以快速执行。</p><h3 id="程序打包"><a href="#程序打包" class="headerlink" title="程序打包"></a><strong>程序打包</strong></h3><p>​        SpringBoot程序是基于Maven创建的，在Maven中提供有打包的指令，叫做package。本操作可以在Idea环境下执行。</p><pre class=" language-JAVA"><code class="language-JAVA">mvn package</code></pre><p>​        打包后会产生一个与工程名类似的jar文件，其名称是由模块名+版本号+.jar组成的。</p><h3 id="程序运行"><a href="#程序运行" class="headerlink" title="程序运行"></a><strong>程序运行</strong></h3><p>​        程序包打好以后，就可以直接执行了。在程序包所在路径下，执行指令。</p><pre class=" language-JAVA"><code class="language-JAVA">java -jar 工程包名.jar</code></pre><p>​        执行程序打包指令后，程序正常运行，与在Idea下执行程序没有区别。</p><p>​        <font color="#ff0000"><b>特别关注</b></font>：如果你的计算机中没有安装java的jdk环境，是无法正确执行上述操作的，因为程序执行使用的是java指令。</p><p>​        <font color="#ff0000"><b>特别关注</b></font>：在使用向导创建SpringBoot工程时，pom.xml文件中会有如下配置，这一段配置千万不能删除，否则打包后无法正常执行程序。</p><pre class=" language-XML"><code class="language-XML"><build>    <plugins>        <plugin>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-maven-plugin</artifactId>        </plugin>    </plugins></build></code></pre><p><strong>总结</strong></p><ol><li>SpringBoot工程可以基于java环境下独立运行jar文件启动服务</li><li>SpringBoot工程执行mvn命令package进行打包</li><li>执行jar命令：java –jar 工程名.jar</li></ol><h3 id="SpringBoot程序打包失败处理"><a href="#SpringBoot程序打包失败处理" class="headerlink" title="SpringBoot程序打包失败处理"></a>SpringBoot程序打包失败处理</h3><p>​        有些小伙伴打包以后执行会出现一些问题，导致程序无法正常执行，例如下面的现象</p><img src="img\image-20211201094223991.png" alt="image-20211201094223991" style="zoom:67%;" /><p>​        要想搞清楚这个问题就要说说.jar文件的工作机制了，知道了这个东西就知道如何避免此类问题的发生了。</p><p>​        搞java开发平时会接触很多jar包，比如mysql的驱动jar包，而上面我们打包程序后得到的也是一个jar文件。这个时候如果你使用上面的java -jar指令去执行mysql的驱动jar包就会出现上述不可执行的现象，而我们的SpringBoot项目为什么能执行呢？其实是因为打包方式不一样。</p><p>​        在SpringBoot工程的pom.xml中有下面这组配置，这组配置决定了打包出来的程序包是否可以执行。</p><pre class=" language-XML"><code class="language-XML"><build>    <plugins>        <plugin>            <groupId>org.springframework.boot</groupId>            <artifactId>spring-boot-maven-plugin</artifactId>        </plugin>    </plugins></build></code></pre><p>​        我们分别开启这段配置和注释掉这段配置分别执行两次打包，然后观察两次打包后的程序包的差别，共有3处比较明显的特征</p><ul><li>打包后文件的大小不同</li><li>打包后所包含的内容不同</li><li>打包程序中个别文件内容不同</li></ul><p>​        先看第一个现象，文件大小不同。带有配置时打包生成的程序包大小如下：</p><img src="img\image-20211201095610270.png" alt="image-20211201095610270" style="zoom:150%;" /><p>​        不难看出，带有配置的程序包体积比不带配置的大了30倍，那这里面都有什么呢？能差这么多？下面看看里面的内容有什么区别。</p><p>​        <img src="img\image-20211201101541267.png" alt="image-20211201101541267" style="zoom:50%;" /><img src="img\image-20211201101652868.png" alt="image-20211201101652868" style="zoom:50%;" /></p><p>​        我们发现内容也完全不一样，仅有一个目录是一样的，叫做META-INF。打开容量大的程序包中的BOOT-INF目录下的classes目录，我们发现其中的内容居然和容量小的程序包中的内容完全一样。</p><p>​        <img src="img\image-20211201101805569.png" alt="image-20211201101805569" style="zoom:50%;" /><img src="img\image-20211201101652868.png" alt="image-20211201101652868" style="zoom:50%;" /></p><p>​        原来大的程序包中除了包含小的程序包中的内容，还有别的东西。都有什么呢？回到BOOT-INF目录下，打开lib目录，里面显示了很多个jar文件。</p><p>​        <img src="img\image-20211201102025791.png" alt="image-20211201102025791" style="zoom:50%;" /></p><p>​        仔细翻阅不难发现，这些jar文件都是我们制作这个工程时导入的坐标对应的文件。大概可以想明白了，SpringBoot程序为了让自己打包生成的程序可以独立运行，不仅将项目中自己开发的内容进行了打包，还把当前工程运行需要使用的jar包全部打包进来了。为什么这样做呢？就是为了可以独立运行。不依赖程序包外部的任何资源可以独立运行当前程序。这也是为什么大的程序包容量是小的程序包容量的30倍的主要原因。</p><p>​        再看看大程序包还有什么不同之处，在最外层目录包含一个org目录，进入此目录，目录名是org\springframework\boot\loader，在里面可以找到一个<font color="#ff0000"><b>JarLauncher.class</b></font>的文件，先记得这个文件。再看这套目录名，明显是一个Spring的目录名，为什么要把Spring框架的东西打包到这个程序包中呢？不清楚。</p><p>​        回到两个程序包的最外层目录，查看名称相同的文件夹META-INF下都有一个叫做MANIFEST.MF的文件，但是大小不同，打开文件，比较内容区别</p><ul><li><p>小容量文件的MANIFEST.MF</p><pre class=" language-JAVA"><code class="language-JAVA">Manifest-Version: 1.0Implementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTBuild-Jdk-Spec: 1.8Created-By: Maven Jar Plugin 3.2.0</code></pre></li><li><p>大容量文件的MANIFEST.MF</p><pre class=" language-JAVA"><code class="language-JAVA">Manifest-Version: 1.0Spring-Boot-Classpath-Index: BOOT-INF/classpath.idxImplementation-Title: springboot_08_ssmpImplementation-Version: 0.0.1-SNAPSHOTSpring-Boot-Layers-Index: BOOT-INF/layers.idxStart-Class: com.itheima.SSMPApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.5.4Created-By: Maven Jar Plugin 3.2.0Main-Class: org.springframework.boot.loader.JarLauncher</code></pre></li></ul><p>​        大文件中明显比小文件中多了几行信息，其中最后一行信息是Main-Class: org.springframework.boot.loader.<font color="#ff0000"><b>JarLauncher</b></font>。这句话什么意思呢？如果使用java -jar执行此程序包，将执行Main-Class属性配置的类，这个类恰巧就是前面看到的那个文件。原来SpringBoot打包程序中出现Spring框架的东西是为这里服务的。而这个org.springframework.boot.loader.<font color="#ff0000"><b>JarLauncher</b></font>类内部要查找Start-Class属性中配置的类，并执行对应的类。这个属性在当前配置中也存在，对应的就是我们的引导类类名。</p><p>​        现在这组设定的作用就搞清楚了</p><ol><li>SpringBoot程序添加配置后会打出一个特殊的包，包含Spring框架部分功能，原始工程内容，原始工程依赖的jar包</li><li>首先读取MANIFEST.MF文件中的Main-Class属性，用来标记执行java -jar命令后运行的类</li><li>JarLauncher类执行时会找到Start-Class属性，也就是启动类类名</li><li>运行启动类时会运行当前工程的内容</li><li>运行当前工程时会使用依赖的jar包，从lib目录中查找</li></ol><p>​        看来SpringBoot打出来了包为了能够独立运行，简直是煞费苦心，将所有需要使用的资源全部都添加到了这个包里。这就是为什么这个jar包能独立运行的原因。</p><p>​        再来看之前的报错信息：</p><img src="img\image-20211201094223991.png" alt="image-20211201094223991" style="zoom:67%;" /><p>​        由于打包时没有使用那段配置，结果打包后形成了一个普通的jar包，在MANIFEST.MF文件中也就没有了Main-Class对应的属性了，所以运行时提示找不到主清单属性，这就是报错的原因。</p><p>​        上述内容搞清楚对我们编程意义并不大，但是对各位小伙伴理清楚SpringBoot工程独立运行的机制是有帮助的。其实整体过程主要是带着大家分析，如果以后遇到了类似的问题，多给自己提问，多问一个为什么，兴趣自己就可以独立解决问题了。</p><p><strong>总结</strong></p><ol><li>spring-boot-maven-plugin插件用于将当前程序打包成一个可以独立运行的程序包</li></ol><h3 id="命令行启动常见问题及解决方案"><a href="#命令行启动常见问题及解决方案" class="headerlink" title="命令行启动常见问题及解决方案"></a>命令行启动常见问题及解决方案</h3><p>​        各位小伙伴在DOS环境下启动SpringBoot工程时，可能会遇到端口占用的问题。给大家一组命令，不用深入学习，备用吧。</p><pre class=" language-JAVA"><code class="language-JAVA"># 查询端口netstat -ano# 查询指定端口netstat -ano |findstr "端口号"# 根据进程PID查询进程名称tasklist |findstr "进程PID号"# 根据PID杀死任务taskkill /F /PID "进程PID号"# 根据进程名称杀死任务taskkill -f -t -im "进程名称"</code></pre><p>​        关于打包与运行程序其实还有一系列的配置和参数，下面的内容中遇到再说，这里先开个头，知道如何打包和运行程序。</p><h3 id="SpringBoot项目快速启动（Linux版）"><a href="#SpringBoot项目快速启动（Linux版）" class="headerlink" title="SpringBoot项目快速启动（Linux版）"></a>SpringBoot项目快速启动（Linux版）</h3><p>​        其实对于Linux系统下的程序运行与Windows系统下的程序运行差别不大，命令还是那组命令，只不过各位小伙伴可能对Linux指令不太熟悉，结果就会导致各种各样的问题发生。比如防火墙如何关闭，IP地址如何查询，JDK如何安装等等。这里不作为重点内容给大家普及了，了解一下整体过程就行了。</p><h2 id="YW-2-配置高级"><a href="#YW-2-配置高级" class="headerlink" title="YW-2.配置高级"></a>YW-2.配置高级</h2><p>​        关于配置在基础篇讲过一部分，基础篇的配置总体上来说就是让各位小伙伴掌握配置的格式。比如配置文件如何写啊，写好的数据如何读取啊，都是基础的语法级知识。在实用篇中就要集中在配置的应用这个方面了，下面就开始配置高级相关内容的第一部分学习，为什么说第一部分，因为在开发实用篇中还有对应的配置高级知识要进行学习。</p><h3 id="YW-2-1-临时属性设置"><a href="#YW-2-1-临时属性设置" class="headerlink" title="YW-2-1.临时属性设置"></a>YW-2-1.临时属性设置</h3><p>​        目前我们的程序包打好了，可以发布了。但是程序包打好以后，里面的配置都已经是固定的了，比如配置了服务器的端口是8080。如果我要启动项目，发现当前我的服务器上已经有应用启动起来并且占用了8080端口，这个时候就尴尬了。难道要重新把打包好的程序修改一下吗？比如我要把打包好的程序启动端口改成80。</p><p><img src="img%5Cimage-20211206095113771.png" alt="image-20211206095113771">             <img src="img%5Cimage-20211206095524343.png" alt="image-20211206095524343">             <img src="img%5Cimage-20211206095101581.png" alt="image-20211206095101581"></p><p>​        SpringBoot提供了灵活的配置方式，如果你发现你的项目中有个别属性需要重新配置，可以使用临时属性的方式快速修改某些配置。方法也特别简单，在启动的时候添加上对应参数就可以了。</p><pre class=" language-JAVA"><code class="language-JAVA">java –jar springboot.jar –-server.port=80</code></pre><p>​        上面的命令是启动SpringBoot程序包的命令，在命令输入完毕后，空一格，然后输入两个-号。下面按照属性名=属性值的形式添加对应参数就可以了。记得，这里的格式不是yaml中的书写格式，当属性存在多级名称时，中间使用点分隔，和properties文件中的属性格式完全相同。</p><p>​        如果你发现要修改的属性不止一个，可以按照上述格式继续写，属性与属性之间使用空格分隔。</p><pre class=" language-JAVA"><code class="language-JAVA">java –jar springboot.jar –-server.port=80 --logging.level.root=debug</code></pre><h4 id="属性加载优先级"><a href="#属性加载优先级" class="headerlink" title="属性加载优先级"></a><strong>属性加载优先级</strong></h4><p>​        现在我们的程序配置受两个地方控制了，第一配置文件，第二临时属性。并且我们发现临时属性的加载优先级要高于配置文件的。那是否还有其他的配置方式呢？其实是有的，而且还不少，打开官方文档中对应的内容，就可以查看配置读取的优先顺序。地址奉上：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html">https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-external-config</a></p><img src="img\image-20211206100859236.png" alt="image-20211206100859236" style="zoom:67%;" /><p>​        我们可以看到，居然有14种配置的位置，而我们现在使用的是这里面的2个。第3条Config data说的就是使用配置文件，第11条Command line arguments说的就是使用命令行临时参数。而这14种配置的顺序就是SpringBoot加载配置的顺序，言外之意，命令行临时属性比配置文件的加载优先级高，所以这个列表上面的优先级低，下面的优先级高。其实这个东西不用背的，你就记得一点，你最终要什么效果，你自己是知道的，不管这个顺序是怎么个高低排序，开发时一定要配置成你要的顺序为准。这个顺序只是在你想不明白问题的时候帮助你分析罢了。</p><p>​        比如你现在加载了一个user.name属性。结果你发现出来的结果和你想的不一样，那肯定是别的优先级比你高的属性覆盖你的配置属性了，那你就可以看着这个顺序挨个排查。哪个位置有可能覆盖了你的属性。</p><p>​        我在课程评论区看到小伙伴学习基础篇的时候问这个问题了，就是这个原因造成的。在yaml中配置了user.name属性值，然后读取出来的时候居然不是自己的配置值，因为在系统属性中有一个属性叫做user.name，两个相互冲突了。而系统属性的加载优先顺序在上面这个列表中是5号，高于3号，所以SpringBoot最终会加载系统配置属性user.name。</p><p><strong>总结</strong></p><ol><li>使用jar命令启动SpringBoot工程时可以使用临时属性替换配置文件中的属性</li><li>临时属性添加方式：java –jar 工程名.jar –-属性名=值</li><li>多个临时属性之间使用空格分隔</li><li>临时属性必须是当前boot工程支持的属性，否则设置无效</li></ol><h4 id="开发环境中使用临时属性"><a href="#开发环境中使用临时属性" class="headerlink" title="开发环境中使用临时属性"></a>开发环境中使用临时属性</h4><p>​        临时使用目前是有了，但是上线的时候通过命令行输入的临时属性必须是正确的啊，那这些属性配置值我们必须在开发环境中测试好才行。下面说一下开发环境中如何使用临时属性，其实就是Idea界面下如何操作了。</p><p>​        打开SpringBoot引导类的运行界面，在里面找到配置项。其中Program arguments对应的位置就是添加临时属性的，可以加几个试试效果。</p><img src="img\image-20211206101947622.png" alt="image-20211206101947622" style="zoom:80%;" /><p>​        做到这里其实可以产生一个思考了，如果对java编程熟悉的小伙伴应该知道，我们运行main方法的时候，如果想使用main方法的参数，也就是下面的args参数，就是在上面这个位置添加的参数。</p><pre class=" language-JAVA"><code class="language-JAVA">public static void main(String[] args) &#123;&#125;</code></pre><p>​        原来是这样，通过这个args就可以获取到参数。再来看我们的引导类是如何书写的</p><pre class=" language-JAVA"><code class="language-JAVA">public static void main(String[] args) &#123;    SpringApplication.run(SSMPApplication.class,args);&#125;</code></pre><p>​        这个args参数居然传递给了run方法，看来在Idea中配置的临时参数就是通过这个位置传递到我们的程序中的。言外之意，这里如果不用这个args是不是就断开了外部传递临时属性的入口呢？是这样的，我们可以使用下面的调用方式，这样外部临时属性就无法进入到SpringBoot程序中了。</p><pre class=" language-JAVA"><code class="language-JAVA">public static void main(String[] args) &#123;    SpringApplication.run(SSMPApplication.class);&#125;</code></pre><p>​        或者还可以使用如下格式来玩这个操作，就是将配置不写在配置文件中，直接写成一个字符串数组，传递给程序入口。当然，这种做法并没有什么实际开发意义。</p><pre class=" language-JAVA"><code class="language-JAVA">public static void main(String[] args) &#123;    String[] arg = new String[1];    arg[0] = "--server.port=8082";    SpringApplication.run(SSMPApplication.class, arg);&#125;</code></pre><p><strong>总结</strong></p><ol><li>启动SpringBoot程序时，可以选择是否使用命令行属性为SpringBoot程序传递启动属性</li></ol><p><strong>思考</strong></p><p>​        现在使用临时属性可以在启动项目前临时更改配置了，但是新的问题又出来了。临时属性好用是好用，就是写的多了会很麻烦。比如我现在有个需求，上线的时候使用临时属性配置20个值，这下可麻烦了，能不能搞得简单点，集中管理一下呢？比如说搞个文件，加载指定文件？还真可以。怎么做呢？咱们下一节再说。</p><h3 id="YW-2-2-配置文件分类"><a href="#YW-2-2-配置文件分类" class="headerlink" title="YW-2-2.配置文件分类"></a>YW-2-2.配置文件分类</h3><p>​        SpringBoot提供了配置文件和临时属性的方式来对程序进行配置。前面一直说的是临时属性，这一节要说说配置文件了。其实这个配置文件我们一直在使用，只不过我们用的是SpringBoot提供的4级配置文件中的其中一个级别。4个级别分别是：</p><ul><li>类路径下配置文件（一直使用的是这个，也就是resources目录中的application.yml文件）</li><li>类路径下config目录下配置文件</li><li>程序包所在目录中配置文件</li><li>程序包所在目录中config目录下配置文件</li></ul><p>​        好复杂，一个一个说。其实上述4种文件是提供给你了4种配置文件书写的位置，功能都是一样的，都是做配置的。那大家关心的就是差别了，没错，就是因为位置不同，产生了差异。总体上来说，4种配置文件如果都存在的话，有一个优先级的问题，说白了就是加入4个文件我都有，里面都有一样的配置，谁生效的问题。上面4个文件的加载优先顺序为</p><ol><li>file ：config/application.yml <strong>【最高】</strong></li><li>file ：application.yml</li><li>classpath：config/application.yml</li><li>classpath：application.yml  <strong>【最低】</strong></li></ol><p>​        那为什么设计这种多种呢？说一个最典型的应用吧。</p><ul><li>场景A：你作为一个开发者，你做程序的时候为了方便自己写代码，配置的数据库肯定是连接你自己本机的，咱们使用4这个级别，也就是之前一直用的application.yml。</li><li>场景B：现在项目开发到了一个阶段，要联调测试了，连接的数据库是测试服务器的数据库，肯定要换一组配置吧。你可以选择把你之前的文件中的内容都改了，目前还不麻烦。</li><li>场景C：测试完了，一切OK。你继续写你的代码，你发现你原来写的配置文件被改成测试服务器的内容了，你要再改回来。现在明白了不？场景B中把你的内容都改掉了，你现在要重新改回来，以后呢？改来改去吗？</li></ul><p>​        解决方案很简单，用上面的3这个级别的配置文件就可以快速解决这个问题，再写一个配置就行了。两个配置文件共存，因为config目录中的配置加载优先级比你的高，所以配置项如果和级别4里面的内容相同就覆盖了，这样是不是很简单？</p><p>​        级别1和2什么时候使用呢？程序打包以后就要用这个级别了，管你程序里面配置写的是什么？我的级别高，可以轻松覆盖你，就不用考虑这些配置冲突的问题了。</p><p><strong>总结</strong></p><ol><li><p>配置文件分为4种</p><ul><li>项目类路径配置文件：服务于开发人员本机开发与测试</li><li>项目类路径config目录中配置文件：服务于项目经理整体调控</li><li>工程路径配置文件：服务于运维人员配置涉密线上环境</li><li>工程路径config目录中配置文件：服务于运维经理整体调控</li></ul></li><li><p>多层级配置文件间的属性采用叠加并覆盖的形式作用于程序</p></li></ol><h3 id="YW-2-3-自定义配置文件"><a href="#YW-2-3-自定义配置文件" class="headerlink" title="YW-2-3.自定义配置文件"></a>YW-2-3.自定义配置文件</h3><p>​        之前咱们做配置使用的配置文件都是application.yml，其实这个文件也是可以改名字的，这样方便维护。比如我2020年4月1日搞活动，走了一组配置，2020年5月1日活动取消，恢复原始配置，这个时候只需要重新更换一下配置文件就可以了。但是你总不能在原始配置文件上修改吧，不然搞完活动以后，活动的配置就留不下来了，不利于维护。</p><p>​        自定义配置文件方式有如下两种：</p><p><strong>方式一：使用临时属性设置配置文件名，注意仅仅是名称，不要带扩展名</strong></p><img src="img\image-20211206105548238.png" alt="image-20211206105548238" style="zoom:67%;" /><p><strong>方式二：使用临时属性设置配置文件路径，这个是全路径名</strong></p><img src="img\image-20211206105716450.png" alt="image-20211206105716450" style="zoom:67%;" /><p>​        也可以设置加载多个配置文件</p><img src="img\image-20211206105750285.png" alt="image-20211206105750285" style="zoom:67%;" /><p>​        使用的属性一个是spring.config.name，另一个是spring.config.location，这个一定要区别清楚。</p><p><font color="#f0f"><b>温馨提示</b></font></p><p>​        我们现在研究的都是SpringBoot单体项目，就是单服务器版本。其实企业开发现在更多的是使用基于SpringCloud技术的多服务器项目。这种配置方式和我们现在学习的完全不一样，所有的服务器将不再设置自己的配置文件，而是通过配置中心获取配置，动态加载配置信息。为什么这样做？集中管理。这里不再说这些了，后面再讲这些东西。</p><p><strong>总结</strong></p><ol><li>配置文件可以修改名称，通过启动参数设定</li><li>配置文件可以修改路径，通过启动参数设定</li><li>微服务开发中配置文件通过配置中心进行设置</li></ol><h2 id="YW-3-多环境开发"><a href="#YW-3-多环境开发" class="headerlink" title="YW-3.多环境开发"></a>YW-3.多环境开发</h2><p>​        讲的内容距离线上开发越来越近了，下面说一说多环境开发问题。</p><p>​        什么是多环境？其实就是说你的电脑上写的程序最终要放到别人的服务器上去运行。每个计算机环境不一样，这就是多环境。常见的多环境开发主要兼顾3种环境设置，开发环境——自己用的，测试环境——自己公司用的，生产环境——甲方爸爸用的。因为这是绝对不同的三台电脑，所以环境肯定有所不同，比如连接的数据库不一样，设置的访问端口不一样等等。</p><img src="img\image-20211206110958819.png" alt="image-20211206110958819" style="zoom:67%;" /><h3 id="YW-3-1-多环境开发（yaml单一文件版）"><a href="#YW-3-1-多环境开发（yaml单一文件版）" class="headerlink" title="YW-3-1.多环境开发（yaml单一文件版）"></a>YW-3-1.多环境开发（yaml单一文件版）</h3><p>​        那什么是多环境开发？就是针对不同的环境设置不同的配置属性即可。比如你自己开发时，配置你的端口如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><p>​        如何想设计两组环境呢？中间使用三个减号分隔开</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">---</span><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">81</span></code></pre><p>​        如何区分两种环境呢？起名字呗</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span> pro<span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">---</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span> dev<span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">81</span></code></pre><p>​        那用哪一个呢？设置默认启动哪个就可以了</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span>        <span class="token key atrule">active</span><span class="token punctuation">:</span> pro        <span class="token comment" spellcheck="true"># 启动pro</span><span class="token punctuation">---</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span> pro<span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">---</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span> dev<span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">81</span></code></pre><p>​        就这么简单，再多来一组环境也OK</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span>        <span class="token key atrule">active</span><span class="token punctuation">:</span> pro        <span class="token comment" spellcheck="true"># 启动pro</span><span class="token punctuation">---</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span> pro<span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">---</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span> dev<span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">81</span><span class="token punctuation">---</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span> test<span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">82</span></code></pre><p>​        其中关于环境名称定义上述格式是过时格式，标准格式如下</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">config</span><span class="token punctuation">:</span>        <span class="token key atrule">activate</span><span class="token punctuation">:</span>            <span class="token key atrule">on-profile</span><span class="token punctuation">:</span> pro</code></pre><p><strong>总结</strong></p><ol><li>多环境开发需要设置若干种常用环境，例如开发、生产、测试环境</li><li>yaml格式中设置多环境使用—区分环境设置边界</li><li>每种环境的区别在于加载的配置属性不同</li><li>启用某种环境时需要指定启动时使用该环境</li></ol><h3 id="YW-3-2-多环境开发（yaml多文件版）"><a href="#YW-3-2-多环境开发（yaml多文件版）" class="headerlink" title="YW-3-2.多环境开发（yaml多文件版）"></a>YW-3-2.多环境开发（yaml多文件版）</h3><p>​        将所有的配置都放在一个配置文件中，尤其是每一个配置应用场景都不一样，这显然不合理，于是就有了将一个配置文件拆分成多个配置文件的想法。拆分后，每个配置文件中写自己的配置，主配置文件中写清楚用哪一个配置文件就好了。</p><p><strong>主配置文件</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span>        <span class="token key atrule">active</span><span class="token punctuation">:</span> pro        <span class="token comment" spellcheck="true"># 启动pro</span></code></pre><p><strong>环境配置文件</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><p>​        环境配置文件因为每一个都是配置自己的项，所以连名字都不用写里面了。那问题是如何区分这是哪一组配置呢？使用文件名区分。</p><p><strong>application-pro.yaml</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span></code></pre><p><strong>application-dev.yaml</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">81</span></code></pre><p>​        文件的命名规则为：application-环境名.yml。</p><p>​        在配置文件中，如果某些配置项所有环境都一样，可以将这些项写入到主配置中，只有哪些有区别的项才写入到环境配置文件中。</p><ul><li>主配置文件中设置公共配置（全局）</li><li>环境分类配置文件中常用于设置冲突属性（局部）</li></ul><p><strong>总结</strong></p><ol><li><p>可以使用独立配置文件定义环境属性</p></li><li><p>独立配置文件便于线上系统维护更新并保障系统安全性</p></li></ol><h3 id="YW-3-3-多环境开发（properties多文件版）"><a href="#YW-3-3-多环境开发（properties多文件版）" class="headerlink" title="YW-3-3.多环境开发（properties多文件版）"></a>YW-3-3.多环境开发（properties多文件版）</h3><p>​        SpringBoot最早期提供的配置文件格式是properties格式的，这种格式的多环境配置也了解一下吧。</p><p><strong>主配置文件</strong></p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">spring.profiles.active</span><span class="token punctuation">=</span><span class="token attr-value">pro</span></code></pre><p><strong>环境配置文件</strong></p><p><strong>application-pro.properties</strong></p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">80</span></code></pre><p><strong>application-dev.properties</strong></p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">server.port</span><span class="token punctuation">=</span><span class="token attr-value">81</span></code></pre><p>​        文件的命名规则为：application-环境名.properties。</p><p><strong>总结</strong></p><ol><li>properties文件多环境配置仅支持多文件格式</li></ol><h3 id="YW-3-4-多环境开发独立配置文件书写技巧"><a href="#YW-3-4-多环境开发独立配置文件书写技巧" class="headerlink" title="YW-3-4.多环境开发独立配置文件书写技巧"></a>YW-3-4.多环境开发独立配置文件书写技巧</h3><p>​        作为程序员在搞配置的时候往往处于一种分久必合合久必分的局面。开始先写一起，后来为了方便维护就拆分。对于多环境开发也是如此，下面给大家说一下如何基于多环境开发做配置独立管理，务必掌握。</p><p><strong>准备工作</strong></p><p>​        将所有的配置根据功能对配置文件中的信息进行拆分，并制作成独立的配置文件，命名规则如下</p><ul><li>application-devDB.yml</li><li>application-devRedis.yml</li><li>application-devMVC.yml</li></ul><p><strong>使用</strong></p><p>​        使用include属性在激活指定环境的情况下，同时对多个环境进行加载使其生效，多个环境间使用逗号分隔</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span>        <span class="token key atrule">active</span><span class="token punctuation">:</span> dev        <span class="token key atrule">include</span><span class="token punctuation">:</span> devDB<span class="token punctuation">,</span>devRedis<span class="token punctuation">,</span>devMVC</code></pre><p>​        比较一下，现在相当于加载dev配置时，再加载对应的3组配置，从结构上就很清晰，用了什么，对应的名称是什么</p><p><strong>注意</strong></p><p>​        当主环境dev与其他环境有相同属性时，主环境属性生效；其他环境中有相同属性时，最后加载的环境属性生效</p><p><strong>改良</strong></p><p>​        但是上面的设置也有一个问题，比如我要切换dev环境为pro时，include也要修改。因为include属性只能使用一次，这就比较麻烦了。SpringBoot从2.4版开始使用group属性替代include属性，降低了配置书写量。简单说就是我先写好，你爱用哪个用哪个。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span>        <span class="token key atrule">active</span><span class="token punctuation">:</span> dev        <span class="token key atrule">group</span><span class="token punctuation">:</span>            <span class="token key atrule">"dev"</span><span class="token punctuation">:</span> devDB<span class="token punctuation">,</span>devRedis<span class="token punctuation">,</span>devMVC              <span class="token key atrule">"pro"</span><span class="token punctuation">:</span> proDB<span class="token punctuation">,</span>proRedis<span class="token punctuation">,</span>proMVC              <span class="token key atrule">"test"</span><span class="token punctuation">:</span> testDB<span class="token punctuation">,</span>testRedis<span class="token punctuation">,</span>testMVC</code></pre><p>​        现在再来看，如果切换dev到pro，只需要改一下是不是就结束了？完美！</p><p><strong>总结</strong></p><ol><li>多环境开发使用group属性设置配置文件分组，便于线上维护管理</li></ol><h3 id="YW-3-5-多环境开发控制"><a href="#YW-3-5-多环境开发控制" class="headerlink" title="YW-3-5.多环境开发控制"></a>YW-3-5.多环境开发控制</h3><p>​        多环境开发到这里基本上说完了，最后说一个冲突问题。就是maven和SpringBoot同时设置多环境的话怎么搞。</p><p>​        要想处理这个冲突问题，你要先理清一个关系，究竟谁在多环境开发中其主导地位。也就是说如果现在都设置了多环境，谁的应该是保留下来的，另一个应该遵从相同的设置。</p><p>​        maven是做什么的？项目构建管理的，最终生成代码包的，SpringBoot是干什么的？简化开发的。简化，又不是其主导作用。最终还是要靠maven来管理整个工程，所以SpringBoot应该听maven的。整个确认后下面就好做了。大体思想如下：</p><ul><li>先在maven环境中设置用什么具体的环境</li><li>在SpringBoot中读取maven设置的环境即可</li></ul><p><strong>maven中设置多环境（使用属性方式区分环境）</strong></p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profiles</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>env_dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile.active</span><span class="token punctuation">></span></span>dev<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile.active</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activation</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activeByDefault</span><span class="token punctuation">></span></span>true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activeByDefault</span><span class="token punctuation">></span></span>        <span class="token comment" spellcheck="true">&lt;!--默认启动环境--></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activation</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>id</span><span class="token punctuation">></span></span>env_pro<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>id</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>profile.active</span><span class="token punctuation">></span></span>pro<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile.active</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profile</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>profiles</span><span class="token punctuation">></span></span></code></pre><p><strong>SpringBoot中读取maven设置值</strong></p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token key atrule">profiles</span><span class="token punctuation">:</span>        <span class="token key atrule">active</span><span class="token punctuation">:</span> @profile.active@</code></pre><p>​        上面的@属性名@就是读取maven中配置的属性值的语法格式。</p><p><strong>总结</strong></p><ol><li>当Maven与SpringBoot同时对多环境进行控制时，以Mavn为主，SpringBoot使用@..@占位符读取Maven对应的配置属性值</li><li>基于SpringBoot读取Maven配置属性的前提下，如果在Idea下测试工程时pom.xml每次更新需要手动compile方可生效</li></ol><h2 id="YW-4-日志"><a href="#YW-4-日志" class="headerlink" title="YW-4.日志"></a>YW-4.日志</h2><p>​        运维篇最后一部分我们来聊聊日志，日志大家不陌生，简单介绍一下。日志其实就是记录程序日常运行的信息，主要作用如下：</p><ul><li>编程期调试代码</li><li>运营期记录信息</li><li>记录日常运营重要信息（峰值流量、平均响应时长……）</li><li>记录应用报错信息（错误堆栈）</li><li>记录运维过程数据（扩容、宕机、报警……）</li></ul><p>​        或许各位小伙伴并不习惯于使用日志，没关系，慢慢多用，习惯就好。想进大厂，这是最基本的，别去面试的时候说没用过，完了，没机会了。</p><h4 id="YW-4-1-代码中使用日志工具记录日志"><a href="#YW-4-1-代码中使用日志工具记录日志" class="headerlink" title="YW-4-1.代码中使用日志工具记录日志"></a>YW-4-1.代码中使用日志工具记录日志</h4><p>​        日志的使用格式非常固定，直接上操作步骤：</p><p><strong>步骤①</strong>：添加日志记录操作</p><pre class=" language-JAVA"><code class="language-JAVA">@RestController@RequestMapping("/books")public class BookController extends BaseClass&#123;    private static final Logger log = LoggerFactory.getLogger(BookController.class);    @GetMapping    public String getById()&#123;        log.debug("debug...");        log.info("info...");        log.warn("warn...");        log.error("error...");        return "springboot is running...2";    &#125;&#125;</code></pre><p>​        上述代码中log对象就是用来记录日志的对象，下面的log.debug，log.info这些操作就是写日志的API了。</p><p><strong>步骤②</strong>：设置日志输出级别</p><p>​        日志设置好以后可以根据设置选择哪些参与记录。这里是根据日志的级别来设置的。日志的级别分为6种，分别是：</p><ul><li>TRACE：运行堆栈信息，使用率低</li><li>DEBUG：程序员调试代码使用</li><li>INFO：记录运维过程数据</li><li>WARN：记录运维过程报警数据</li><li>ERROR：记录错误堆栈信息</li><li>FATAL：灾难信息，合并计入ERROR</li></ul><p>​        一般情况下，开发时候使用DEBUG，上线后使用INFO，运维信息记录使用WARN即可。下面就设置一下日志级别：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span><span class="token key atrule">debug</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>​        这么设置太简单粗暴了，日志系统通常都提供了细粒度的控制</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 开启debug模式，输出调试信息，常用于检查系统运行状况</span><span class="token key atrule">debug</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token comment" spellcheck="true"># 设置日志级别，root表示根节点，即整体应用日志级别</span><span class="token key atrule">logging</span><span class="token punctuation">:</span>    <span class="token key atrule">level</span><span class="token punctuation">:</span>        <span class="token key atrule">root</span><span class="token punctuation">:</span> debug</code></pre><p>​        还可以再设置更细粒度的控制</p><p><strong>步骤③</strong>：设置日志组，控制指定包对应的日志输出级别，也可以直接控制指定包对应的日志输出级别</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 设置日志组</span>    <span class="token key atrule">group</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 自定义组名，设置当前组中所包含的包</span>        <span class="token key atrule">ebank</span><span class="token punctuation">:</span> com.itheima.controller    <span class="token key atrule">level</span><span class="token punctuation">:</span>        <span class="token key atrule">root</span><span class="token punctuation">:</span> warn        <span class="token comment" spellcheck="true"># 为对应组设置日志级别</span>        <span class="token key atrule">ebank</span><span class="token punctuation">:</span> debug        <span class="token comment" spellcheck="true"># 为对包设置日志级别</span>        <span class="token key atrule">com.itheima.controller</span><span class="token punctuation">:</span> debug</code></pre><p>​        说白了就是总体设置一下，每个包设置一下，如果感觉设置的麻烦，就先把包分个组，对组设置，没了，就这些。</p><p><strong>总结</strong></p><ol><li>日志用于记录开发调试与运维过程消息</li><li>日志的级别共6种，通常使用4种即可，分别是DEBUG，INFO,WARN,ERROR</li><li>可以通过日志组或代码包的形式进行日志显示级别的控制</li></ol><h4 id="教你一招：优化日志对象创建代码"><a href="#教你一招：优化日志对象创建代码" class="headerlink" title="教你一招：优化日志对象创建代码"></a>教你一招：优化日志对象创建代码</h4><p>​        写代码的时候每个类都要写创建日志记录对象，这个可以优化一下，使用前面用过的lombok技术给我们提供的工具类即可。</p><pre class=" language-JAVA"><code class="language-JAVA">@RestController@RequestMapping("/books")public class BookController extends BaseClass&#123;    private static final Logger log = LoggerFactory.getLogger(BookController.class);    //这一句可以不写了&#125;</code></pre><p>​        导入lombok后使用注解搞定，日志对象名为log</p><pre class=" language-JAVA"><code class="language-JAVA">@Slf4j        //这个注解替代了下面那一行@RestController@RequestMapping("/books")public class BookController extends BaseClass&#123;    private static final Logger log = LoggerFactory.getLogger(BookController.class);    //这一句可以不写了&#125;</code></pre><p><strong>总结</strong></p><ol><li>基于lombok提供的@Slf4j注解为类快速添加日志对象</li></ol><h4 id="YW-4-2-日志输出格式控制"><a href="#YW-4-2-日志输出格式控制" class="headerlink" title="YW-4-2.日志输出格式控制"></a>YW-4-2.日志输出格式控制</h4><p>​        日志已经能够记录了，但是目前记录的格式是SpringBoot给我们提供的，如果想自定义控制就需要自己设置了。先分析一下当前日志的记录格式。</p><p><img src="img%5Cimage-20211206123431222.png" alt="image-20211206123431222"></p><p>​        对于单条日志信息来说，日期，触发位置，记录信息是最核心的信息。级别用于做筛选过滤，PID与线程名用于做精准分析。了解这些信息后就可以DIY日志格式了。本课程不做详细的研究，有兴趣的小伙伴可以学习相关的知识。下面给出课程中模拟的官方日志模板的书写格式，便于大家学习。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">logging</span><span class="token punctuation">:</span>    <span class="token key atrule">pattern</span><span class="token punctuation">:</span>        <span class="token key atrule">console</span><span class="token punctuation">:</span> "%d %clr(%p) <span class="token punctuation">---</span> <span class="token punctuation">[</span>%16t<span class="token punctuation">]</span> %clr(%<span class="token punctuation">-</span>40.40c)&amp;<span class="token comment" spellcheck="true">#123;cyan&amp;#125; : %m %n"</span></code></pre><p><strong>总结</strong></p><ol><li>日志输出格式设置规则</li></ol><h4 id="YW-4-3-日志文件"><a href="#YW-4-3-日志文件" class="headerlink" title="YW-4-3.日志文件"></a>YW-4-3.日志文件</h4><p>​        日志信息显示，记录已经控制住了，下面就要说一下日志的转存了。日志不能仅显示在控制台上，要把日志记录到文件中，方便后期维护查阅。</p><p>​        对于日志文件的使用存在各种各样的策略，例如每日记录，分类记录，报警后记录等。这里主要研究日志文件如何记录。</p><p>​        记录日志到文件中格式非常简单，设置日志文件名即可。</p><pre class=" language-YAML"><code class="language-YAML">logging:    file:        name: server.log</code></pre><p>​        虽然使用上述格式可以将日志记录下来了，但是面对线上的复杂情况，一个文件记录肯定是不能够满足运维要求的，通常会每天记录日志文件，同时为了便于维护，还要限制每个日志文件的大小。下面给出日志文件的常用配置方式：</p><pre class=" language-YAML"><code class="language-YAML">logging:    logback:        rollingpolicy:            max-file-size: 3KB            file-name-pattern: server.%d&#123;yyyy-MM-dd&#125;.%i.log</code></pre><p>​        以上格式是基于logback日志技术设置每日日志文件的设置格式，要求容量到达3KB以后就转存信息到第二个文件中。文件命名规则中的%d标识日期，%i是一个递增变量，用于区分日志文件。</p><p><strong>总结</strong></p><ol><li>日志记录到文件</li><li>日志文件格式设置</li></ol><h2 id="运维实用篇完结"><a href="#运维实用篇完结" class="headerlink" title="运维实用篇完结"></a>运维实用篇完结</h2><p>​        运维实用篇到这里就要先告一段落了，为什么不说结束呢？因为运维篇中还有一些知识，但是现在讲解过于分散了。所以要把这些知识与开发实用篇的知识结合在一起讲，也是本课程的教学设计的体现。</p><p>​        在整体运维实用篇中带着大家学习了4块内容，首先学习了如何运行SpringBoot程序，也就是程序的打包与运行，接下来对配置进行了升级学习，不再局限在配置文件中进行设置，通过临时属性，外部配置文件对项目的配置进行管控。在多环境开发中给大家介绍了多种多环境开发的格式，其实掌握一种即可，此外还给大家讲了多环境开发的一些技巧以及与maven的冲突解决方案。最后给大家介绍了日志系统，老实说日志这里讲的相当的潦草，因为大部分日志相关的知识都不应该在这门课中学习，这里只是告诉大家如何整合实用而已。</p><p>​        看了各位小伙伴的评论，知道你们再催更，我也在加油，一起努力吧，实用开发篇再会。实用开发篇会提高更新频度，不全部做完给大家更新了，我先把做好的一部分开放出来，随后做完一点就更新一点，额，好吧，就说到这里吧。</p><h1 id="SpringBoot开发实用篇"><a href="#SpringBoot开发实用篇" class="headerlink" title="SpringBoot开发实用篇"></a>SpringBoot开发实用篇</h1><p>​        怀着忐忑的心情，开始了开发实用篇文档的编写。为什么忐忑？特喵的债欠的太多，不知道从何写起。哎，不煽情了，开工。</p><p>​        运维实用篇完结以后，开发实用篇采用日更新的形式发布给各位小伙伴，基本上是每天一集，目前已经发布完毕。看评论区，好多小伙伴在求文档，所以赶紧来补文档，加班加点把开发实用篇的文档刨出来。</p><p>​        开发实用篇中因为牵扯到SpringBoot整合各种各样的技术，由于不是每个小伙伴对各种技术都有所掌握，所以在整合每一个技术之前，都会做一个快速的普及，这样的话内容整个开发实用篇所包含的内容就会比较多。各位小伙伴在学习的时候，如果对某一个技术不是很清楚，可以先跳过对应章节，或者先补充一下技术知识，然后再来看对应的课程。开发实用篇具体包含的内容如下：</p><ul><li>热部署</li><li>配置高级</li><li>测试</li><li>数据层解决方案</li><li>整合第三方技术</li><li>监控</li></ul><p>​        看目录感觉内容量并不是很大，但是在数据层解决方案和整合第三方技术中包含了大量的知识，一点一点慢慢学吧。下面开启第一部分热部署相关知识的学习</p><h2 id="KF-1-热部署"><a href="#KF-1-热部署" class="headerlink" title="KF-1.热部署"></a>KF-1.热部署</h2><p>​        什么是热部署？简单说就是你程序改了，现在要重新启动服务器，嫌麻烦？不用重启，服务器会自己悄悄的把更新后的程序给重新加载一遍，这就是热部署。</p><p>​        热部署的功能是如何实现的呢？这就要分两种情况来说了，非springboot工程和springboot工程的热部署实现方式完全不一样。先说一下原始的非springboot项目是如何实现热部署的。</p><p><strong>非springboot项目热部署实现原理</strong></p><p>​        开发非springboot项目时，我们要制作一个web工程并通过tomcat启动，通常需要先安装tomcat服务器到磁盘中，开发的程序配置发布到安装的tomcat服务器上。如果想实现热部署的效果，这种情况其实有两种做法，一种是在tomcat服务器的配置文件中进行配置，这种做法与你使用什么IDE工具无关，不管你使用eclipse还是idea都行。还有一种做法是通过IDE工具进行配置，比如在idea工具中进行设置，这种形式需要依赖IDE工具，每款IDE工具不同，对应的配置也不太一样。但是核心思想是一样的，就是使用服务器去监控其中加载的应用，发现产生了变化就重新加载一次。</p><p>​        上面所说的非springboot项目实现热部署看上去是一个非常简单的过程，几乎每个小伙伴都能自己写出来。如果你不会写，我给你个最简单的思路，但是实际设计要比这复杂一些。例如启动一个定时任务，任务启动时记录每个文件的大小，以后每5秒比对一下每个文件的大小是否有改变，或者是否有新文件。如果没有改变，放行，如果有改变，刷新当前记录的文件信息，然后重新启动服务器，这就可以实现热部署了。当然，这个过程肯定不能这么做，比如我把一个打印输出的字符串”abc”改成”cba”，比对大小是没有变化的，但是内容缺实变了，所以这么做肯定不行，只是给大家打个比方，而且重启服务器这就是冷启动了，不能算热部署，领会精神吧。</p><p>​        看上去这个过程也没多复杂，在springboot项目中难道还有其他的弯弯绕吗？还真有。</p><p><strong>springboot项目热部署实现原理</strong></p><p>​        基于springboot开发的web工程其实有一个显著的特征，就是tomcat服务器内置了，还记得内嵌服务器吗？服务器是以一个对象的形式在spring容器中运行的。本来我们期望于tomcat服务器加载程序后由tomcat服务器盯着程序，你变化后我就重新启动重新加载，但是现在tomcat和我们的程序是平级的了，都是spring容器中的组件，这下就麻烦了，缺乏了一个直接的管理权，那该怎么做呢？简单，再搞一个程序X在spring容器中盯着你原始开发的程序A不就行了吗？确实，搞一个盯着程序A的程序X就行了，如果你自己开发的程序A变化了，那么程序X就命令tomcat容器重新加载程序A就OK了。并且这样做有一个好处，spring容器中东西不用全部重新加载一遍，只需要重新加载你开发的程序那一部分就可以了，这下效率又高了，挺好。</p><p>​    下面就说说，怎么搞出来这么一个程序X，肯定不是我们自己手写了，springboot早就做好了，搞一个坐标导入进去就行了。</p><h3 id="KF-1-1-手动启动热部署"><a href="#KF-1-1-手动启动热部署" class="headerlink" title="KF-1-1.手动启动热部署"></a>KF-1-1.手动启动热部署</h3><p><strong>步骤①</strong>：导入开发者工具对应的坐标</p><pre class=" language-XML"><code class="language-XML"><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-devtools</artifactId>    <optional>true</optional></dependency></code></pre><p><strong>步骤②</strong>：构建项目，可以使用快捷键激活此功能</p><p><img src="img%5Cimage-20220222121257218.png" alt="image-20220222121257218"></p><p>​        对应的快捷键一定要记得</p><pre class=" language-CMD"><code class="language-CMD"><CTR>L+<F9></code></pre><p>​        以上过程就实现了springboot工程的热部署，是不是挺简单的。不过这里需要把底层的工作工程给普及一下。</p><p><strong>重启与重载</strong></p><p>​        一个springboot项目在运行时实际上是分两个过程进行的，根据加载的东西不同，划分成base类加载器与restart类加载器。</p><ul><li>base类加载器：用来加载jar包中的类，jar包中的类和配置文件由于不会发生变化，因此不管加载多少次，加载的内容不会发生变化</li><li>restart类加载器：用来加载开发者自己开发的类、配置文件、页面等信息，这一类文件受开发者影响</li></ul><p>​        当springboot项目启动时，base类加载器执行，加载jar包中的信息后，restart类加载器执行，加载开发者制作的内容。当执行构建项目后，由于jar中的信息不会变化，因此base类加载器无需再次执行，所以仅仅运行restart类加载即可，也就是将开发者自己制作的内容重新加载就行了，这就完成了一次热部署的过程，也可以说热部署的过程实际上是重新加载restart类加载器中的信息。</p><p><strong>总结</strong></p><ol><li>使用开发者工具可以为当前项目开启热部署功能</li><li>使用构建项目操作对工程进行热部署</li></ol><p><strong>思考</strong></p><p>​        上述过程每次进行热部署都需要开发者手工操作，不管是点击按钮还是快捷键都需要开发者手工执行。这种操作的应用场景主要是在开发调试期，并且调试的代码处于不同的文件中，比如服务器启动了，我需要改4个文件中的内容，然后重启，等4个文件都改完了再执行热部署，使用一个快捷键就OK了。但是如果现在开发者要修改的内容就只有一个文件中的少量代码，这个时候代码修改完毕如果能够让程序自己执行热部署功能，就可以减少开发者的操作，也就是自动进行热部署，能这么做吗？是可以的。咱们下一节再说。</p><p>​        </p><h3 id="KF-1-2-自动启动热部署"><a href="#KF-1-2-自动启动热部署" class="headerlink" title="KF-1-2.自动启动热部署"></a>KF-1-2.自动启动热部署</h3><p>​        自动热部署其实就是设计一个开关，打开这个开关后，IDE工具就可以自动热部署。因此这个操作和IDE工具有关，以下以idea为例设置idea中启动热部署</p><p><strong>步骤①</strong>：设置自动构建项目</p><p>​        打开【File】，选择【settings…】,在面板左侧的菜单中找到【Compile】选项，然后勾选【Build project automatically】，意思是自动构建项目</p><p><img src="img%5Cimage-20220222123543551.png" alt="image-20220222123543551"></p><p>​        自动构建项目选项勾选后</p><p><strong>步骤②</strong>：允许在程序运行时进行自动构建</p><p>​        使用快捷键【Ctrl】+【Alt】+【Shit】+【/】打开维护面板，选择第1项【Registry…】</p><p><img src="img%5Cimage-20220222124006910.png" alt="image-20220222124006910"></p><p>​        在选项中搜索comple，然后勾选对应项即可</p><img src="img\image-20220222124240069.png" alt="image-20220222124240069" style="zoom:80%;" /><p>​        这样程序在运行的时候就可以进行自动构建了，实现了热部署的效果。</p><p><font color="#ff0000"><b>关注</b></font>：如果你每敲一个字母，服务器就重新构建一次，这未免有点太频繁了，所以idea设置当idea工具失去焦点5秒后进行热部署。其实就是你从idea工具中切换到其他工具时进行热部署，比如改完程序需要到浏览器上去调试，这个时候idea就自动进行热部署操作。</p><p><strong>总结</strong></p><ol><li>自动热部署要开启自动构建项目</li><li>自动热部署要开启在程序运行时自动构建项目</li></ol><p><strong>思考</strong></p><p>​        现在已经实现了热部署了，但是到企业开发的时候你会发现，为了便于管理，在你的程序目录中除了有代码，还有可能有文档，如果你修改了一下文档，这个时候会进行热部署吗？不管是否进行热部署，这个过程我们需要自己控制才比较合理，那这个东西能控制吗？咱们下一节再说。</p><h3 id="KF-1-3-参与热部署监控的文件范围配置"><a href="#KF-1-3-参与热部署监控的文件范围配置" class="headerlink" title="KF-1-3.参与热部署监控的文件范围配置"></a>KF-1-3.参与热部署监控的文件范围配置</h3><p>​        通过修改项目中的文件，你可以发现其实并不是所有的文件修改都会激活热部署的，原因在于在开发者工具中有一组配置，当满足了配置中的条件后，才会启动热部署，配置中默认不参与热部署的目录信息如下</p><ul><li>/META-INF/maven</li><li>/META-INF/resources</li><li>/resources</li><li>/static</li><li>/public</li><li>/templates</li></ul><p>​        以上目录中的文件如果发生变化，是不参与热部署的。如果想修改配置，可以通过application.yml文件进行设定哪些文件不参与热部署操作</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">devtools</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span>      <span class="token comment" spellcheck="true"># 设置不参与热部署的文件或文件夹</span>      <span class="token key atrule">exclude</span><span class="token punctuation">:</span> static/**<span class="token punctuation">,</span>public/**<span class="token punctuation">,</span>config/application.yml</code></pre><p><strong>总结</strong></p><ol><li>通过配置可以修改不参与热部署的文件或目录</li></ol><p><strong>思考</strong></p><p>​        热部署功能是一个典型的开发阶段使用的功能，到了线上环境运行程序时，这个功能就没有意义了。能否关闭热部署功能呢？咱们下一节再说。</p><h3 id="KF-1-4-关闭热部署"><a href="#KF-1-4-关闭热部署" class="headerlink" title="KF-1-4.关闭热部署"></a>KF-1-4.关闭热部署</h3><p>​        线上环境运行时是不可能使用热部署功能的，所以需要强制关闭此功能，通过配置可以关闭此功能。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">devtools</span><span class="token punctuation">:</span>    <span class="token key atrule">restart</span><span class="token punctuation">:</span>      <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">false</span></code></pre><p>​        如果当心配置文件层级过多导致相符覆盖最终引起配置失效，可以提高配置的层级，在更高层级中配置关闭热部署。例如在启动容器前通过系统属性设置关闭热部署功能。</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootApplicationpublic class SSMPApplication &#123;    public static void main(String[] args) &#123;        System.setProperty("spring.devtools.restart.enabled","false");        SpringApplication.run(SSMPApplication.class);    &#125;&#125;</code></pre><p>​        其实上述担心略微有点多余，因为线上环境的维护是不可能出现修改代码的操作的，这么做唯一的作用是降低资源消耗，毕竟那双盯着你项目是不是产生变化的眼睛只要闭上了，就不具有热部署功能了，这个开关的作用就是禁用对应功能。</p><p><strong>总结</strong></p><ol><li>通过配置可以关闭热部署功能降低线上程序的资源消耗</li></ol><h2 id="KF-2-配置高级"><a href="#KF-2-配置高级" class="headerlink" title="KF-2.配置高级"></a>KF-2.配置高级</h2><p>​        进入开发实用篇第二章内容，配置高级，其实配置在基础篇讲了一部分，在运维实用篇讲了一部分，这里还要讲，讲的东西有什么区别呢？距离开发过程越来越接近，解决的问题也越来越靠近线上环境，下面就开启本章的学习。</p><h3 id="KF-2-1-ConfigurationProperties"><a href="#KF-2-1-ConfigurationProperties" class="headerlink" title="KF-2-1.@ConfigurationProperties"></a>KF-2-1.@ConfigurationProperties</h3><p>​        在基础篇学习了@ConfigurationProperties注解，此注解的作用是用来为bean绑定属性的。开发者可以在yml配置文件中以对象的格式添加若干属性</p><pre class=" language-YML"><code class="language-YML">servers:  ip-address: 192.168.0.1   port: 2345  timeout: -1</code></pre><p>​        然后再开发一个用来封装数据的实体类，注意要提供属性对应的setter方法</p><pre class=" language-JAVA"><code class="language-JAVA">@Component@Datapublic class ServerConfig &#123;    private String ipAddress;    private int port;    private long timeout;&#125;</code></pre><p>​        使用@ConfigurationProperties注解就可以将配置中的属性值关联到开发的模型类上</p><pre class=" language-JAVA"><code class="language-JAVA">@Component@Data@ConfigurationProperties(prefix = "servers")public class ServerConfig &#123;    private String ipAddress;    private int port;    private long timeout;&#125;</code></pre><p>​        这样加载对应bean的时候就可以直接加载配置属性值了。但是目前我们学的都是给自定义的bean使用这种形式加载属性值，如果是第三方的bean呢？能不能用这种形式加载属性值呢？为什么会提出这个疑问？原因就在于当前@ConfigurationProperties注解是写在类定义的上方，而第三方开发的bean源代码不是你自己书写的，你也不可能到源代码中去添加@ConfigurationProperties注解，这种问题该怎么解决呢？下面就来说说这个问题。</p><p>​        使用@ConfigurationProperties注解其实可以为第三方bean加载属性，格式特殊一点而已。</p><p><strong>步骤①</strong>：使用@Bean注解定义第三方bean</p><pre class=" language-JAVA"><code class="language-JAVA">@Beanpublic DruidDataSource datasource()&#123;    DruidDataSource ds = new DruidDataSource();    return ds;&#125;</code></pre><p><strong>步骤②</strong>：在yml中定义要绑定的属性，注意datasource此时全小写</p><pre class=" language-YAML"><code class="language-YAML">datasource:  driverClassName: com.mysql.jdbc.Driver</code></pre><p><strong>步骤③</strong>：使用@ConfigurationProperties注解为第三方bean进行属性绑定，注意前缀是全小写的datasource</p><pre class=" language-JAVA"><code class="language-JAVA">@Bean@ConfigurationProperties(prefix = "datasource")public DruidDataSource datasource()&#123;    DruidDataSource ds = new DruidDataSource();    return ds;&#125;</code></pre><p>​        操作方式完全一样，只不过@ConfigurationProperties注解不仅能添加到类上，还可以添加到方法上，添加到类上是为spring容器管理的当前类的对象绑定属性，添加到方法上是为spring容器管理的当前方法的返回值对象绑定属性，其实本质上都一样。</p><p>​        做到这其实就出现了一个新的问题，目前我们定义bean不是通过类注解定义就是通过@Bean定义，使用@ConfigurationProperties注解可以为bean进行属性绑定，那在一个业务系统中，哪些bean通过注解@ConfigurationProperties去绑定属性了呢？因为这个注解不仅可以写在类上，还可以写在方法上，所以找起来就比较麻烦了。为了解决这个问题，spring给我们提供了一个全新的注解，专门标注使用@ConfigurationProperties注解绑定属性的bean是哪些。这个注解叫做@EnableConfigurationProperties。具体如何使用呢？</p><p><strong>步骤①</strong>：在配置类上开启@EnableConfigurationProperties注解，并标注要使用@ConfigurationProperties注解绑定属性的类</p><pre class=" language-YAML"><code class="language-YAML">@SpringBootApplication@EnableConfigurationProperties(ServerConfig.class)public class Springboot13ConfigurationApplication &#123;&#125;</code></pre><p><strong>步骤②</strong>：在对应的类上直接使用@ConfigurationProperties进行属性绑定</p><pre class=" language-JAVA"><code class="language-JAVA">@Data@ConfigurationProperties(prefix = "servers")public class ServerConfig &#123;    private String ipAddress;    private int port;    private long timeout;&#125;</code></pre><p>​        有人感觉这没区别啊？注意观察，现在绑定属性的ServerConfig类并没有声明@Component注解。当使用@EnableConfigurationProperties注解时，spring会默认将其标注的类定义为bean，因此无需再次声明@Component注解了。</p><p>​        最后再说一个小技巧，使用@ConfigurationProperties注解时，会出现一个提示信息</p><p><img src="img%5Cimage-20220222145535749.png" alt="image-20220222145535749"></p><p>​        出现这个提示后只需要添加一个坐标此提醒就消失了</p><pre class=" language-XML"><code class="language-XML"><dependency>    <groupId>org.springframework.boot</groupId>    <artifactId>spring-boot-configuration-processor</artifactId></dependency></code></pre><p><strong>总结</strong></p><ol><li>使用@ConfigurationProperties可以为使用@Bean声明的第三方bean绑定属性</li><li>当使用@EnableConfigurationProperties声明进行属性绑定的bean后，无需使用@Component注解再次进行bean声明</li></ol><h3 id="KF-2-2-宽松绑定-松散绑定"><a href="#KF-2-2-宽松绑定-松散绑定" class="headerlink" title="KF-2-2.宽松绑定/松散绑定"></a>KF-2-2.宽松绑定/松散绑定</h3><p>​        在进行属性绑定时，可能会遇到如下情况，为了进行标准命名，开发者会将属性名严格按照驼峰命名法书写，在yml配置文件中将datasource修改为dataSource，如下：</p><pre class=" language-YAML"><code class="language-YAML">dataSource:  driverClassName: com.mysql.jdbc.Driver</code></pre><p>​        此时程序可以正常运行，然后又将代码中的前缀datasource修改为dataSource，如下：</p><pre class=" language-JAVA"><code class="language-JAVA">@Bean@ConfigurationProperties(prefix = "dataSource")public DruidDataSource datasource()&#123;    DruidDataSource ds = new DruidDataSource();    return ds;&#125;</code></pre><p>​        此时就发生了编译错误，而且并不是idea工具导致的，运行后依然会出现问题，配置属性名dataSource是无效的</p><pre class=" language-CMD"><code class="language-CMD">Configuration property name 'dataSource' is not valid:    Invalid characters: 'S'    Bean: datasource    Reason: Canonical names should be kebab-case ('-' separated), lowercase alpha-numeric characters and must start with a letterAction:Modify 'dataSource' so that it conforms to the canonical names requirements.</code></pre><p>​        为什么会出现这种问题，这就要来说一说springboot进行属性绑定时的一个重要知识点了，有关属性名称的宽松绑定，也可以称为宽松绑定。</p><p>​        什么是宽松绑定？实际上是springboot进行编程时人性化设计的一种体现，即配置文件中的命名格式与变量名的命名格式可以进行格式上的最大化兼容。兼容到什么程度呢？几乎主流的命名格式都支持，例如：</p><p>​        在ServerConfig中的ipAddress属性名</p><pre class=" language-JAVA"><code class="language-JAVA">@Component@Data@ConfigurationProperties(prefix = "servers")public class ServerConfig &#123;    private String ipAddress;&#125;</code></pre><p>​        可以与下面的配置属性名规则全兼容</p><pre class=" language-YML"><code class="language-YML">servers:  ipAddress: 192.168.0.2       # 驼峰模式  ip_address: 192.168.0.2      # 下划线模式  ip-address: 192.168.0.2      # 烤肉串模式  IP_ADDRESS: 192.168.0.2      # 常量模式</code></pre><p>​        也可以说，以上4种模式最终都可以匹配到ipAddress这个属性名。为什么这样呢？原因就是在进行匹配时，配置中的名称要去掉中划线和下划线后，忽略大小写的情况下去与java代码中的属性名进行忽略大小写的等值匹配，以上4种命名去掉下划线中划线忽略大小写后都是一个词ipaddress，java代码中的属性名忽略大小写后也是ipaddress，这样就可以进行等值匹配了，这就是为什么这4种格式都能匹配成功的原因。不过springboot官方推荐使用烤肉串模式，也就是中划线模式。</p><p>​        到这里我们掌握了一个知识点，就是命名的规范问题。再来看开始出现的编程错误信息</p><pre class=" language-CMD"><code class="language-CMD">Configuration property name 'dataSource' is not valid:    Invalid characters: 'S'    Bean: datasource    Reason: Canonical names should be kebab-case ('-' separated), lowercase alpha-numeric characters and must start with a letterAction:Modify 'dataSource' so that it conforms to the canonical names requirements.</code></pre><p>​        其中Reason描述了报错的原因，规范的名称应该是烤肉串(kebab)模式(case)，即使用-分隔，使用小写字母数字作为标准字符，且必须以字母开头。然后再看我们写的名称dataSource，就不满足上述要求。闹了半天，在书写前缀时，这个词不是随意支持的，必须使用上述标准。编程写了这么久，基本上编程习惯都养成了，到这里又被springboot教育了，没辙，谁让人家东西好用呢，按照人家的要求写吧。</p><p>​        最后说一句，以上规则仅针对springboot中@ConfigurationProperties注解进行属性绑定时有效，对@Value注解进行属性映射无效。有人就说，那我不用你不就行了？不用，你小看springboot的推广能力了，到原理篇我们看源码时，你会发现内部全是这玩意儿，算了，拿人手短吃人嘴短，认怂吧。</p><p><strong>总结</strong></p><ol><li>@ConfigurationProperties绑定属性时支持属性名宽松绑定，这个宽松体现在属性名的命名规则上</li><li>@Value注解不支持松散绑定规则</li><li>绑定前缀名推荐采用烤肉串命名规则，即使用中划线做分隔符</li></ol><h3 id="KF-2-3-常用计量单位绑定"><a href="#KF-2-3-常用计量单位绑定" class="headerlink" title="KF-2-3.常用计量单位绑定"></a>KF-2-3.常用计量单位绑定</h3><p>​        在前面的配置中，我们书写了如下配置值，其中第三项超时时间timeout描述了服务器操作超时时间，当前值是-1表示永不超时。</p><pre class=" language-YML"><code class="language-YML">servers:  ip-address: 192.168.0.1   port: 2345  timeout: -1</code></pre><p>​        但是每个人都这个值的理解会产生不同，比如线上服务器完成一次主从备份，配置超时时间240，这个240如果单位是秒就是超时时间4分钟，如果单位是分钟就是超时时间4小时。面对一次线上服务器的主从备份，设置4分钟，简直是开玩笑，别说拷贝过程，备份之前的压缩过程4分钟也搞不定，这个时候问题就来了，怎么解决这个误会？</p><p>​        除了加强约定之外，springboot充分利用了JDK8中提供的全新的用来表示计量单位的新数据类型，从根本上解决这个问题。以下模型类中添加了两个JDK8中新增的类，分别是Duration和DataSize</p><pre class=" language-JAVA"><code class="language-JAVA">@Component@Data@ConfigurationProperties(prefix = "servers")public class ServerConfig &#123;    @DurationUnit(ChronoUnit.HOURS)    private Duration serverTimeOut;    @DataSizeUnit(DataUnit.MEGABYTES)    private DataSize dataSize;&#125;</code></pre><p><strong>Duration</strong>：表示时间间隔，可以通过@DurationUnit注解描述时间单位，例如上例中描述的单位为小时（ChronoUnit.HOURS）</p><p><strong>DataSize</strong>：表示存储空间，可以通过@DataSizeUnit注解描述存储空间单位，例如上例中描述的单位为MB（DataUnit.MEGABYTES）</p><p>​        使用上述两个单位就可以有效避免因沟通不同步或文档不健全导致的信息不对称问题，从根本上解决了问题，避免产生误读。</p><p>Druation常用单位如下：</p><img src="img\image-20220222173911102.png" alt="image-20220222173911102" style="zoom:50%;" /><p>DataSize常用单位如下：</p><img src="img\image-20220222174130102.png" alt="image-20220222174130102" style="zoom:67%;" /><h3 id="KF-2-4-校验"><a href="#KF-2-4-校验" class="headerlink" title="KF-2-4.校验"></a>KF-2-4.校验</h3><p>​        目前我们在进行属性绑定时可以通过松散绑定规则在书写时放飞自我了，但是在书写时由于无法感知模型类中的数据类型，就会出现类型不匹配的问题，比如代码中需要int类型，配置中给了非法的数值，例如写一个“a”，这种数据肯定无法有效的绑定，还会引发错误。        SpringBoot给出了强大的数据校验功能，可以有效的避免此类问题的发生。在JAVAEE的JSR303规范中给出了具体的数据校验标准，开发者可以根据自己的需要选择对应的校验框架，此处使用Hibernate提供的校验框架来作为实现进行数据校验。书写应用格式非常固定，话不多说，直接上步骤</p><p><strong>步骤①</strong>：开启校验框架</p><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--1.导入JSR303规范--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>javax.validation<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>validation-api<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--使用hibernate框架提供的校验器做实现--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.hibernate.validator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>hibernate-validator<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：在需要开启校验功能的类上使用注解@Validated开启校验功能</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"servers"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//开启对当前bean的属性注入校验</span><span class="token annotation punctuation">@Validated</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ServerConfig</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤③</strong>：对具体的字段设置校验规则</p><pre class=" language-JAVA"><code class="language-JAVA">@Component@Data@ConfigurationProperties(prefix = "servers")//开启对当前bean的属性注入校验@Validatedpublic class ServerConfig &#123;    //设置具体的规则    @Max(value = 8888,message = "最大值不能超过8888")    @Min(value = 202,message = "最小值不能低于202")    private int port;&#125;</code></pre><p>​        通过设置数据格式校验，就可以有效避免非法数据加载，其实使用起来还是挺轻松的，基本上就是一个格式。</p><p><strong>总结</strong></p><ol><li>开启Bean属性校验功能一共3步：导入JSR303与Hibernate校验框架坐标、使用@Validated注解启用校验功能、使用具体校验规则规范数据校验格式</li></ol><h3 id="KF-2-5-数据类型转换"><a href="#KF-2-5-数据类型转换" class="headerlink" title="KF-2-5.数据类型转换"></a>KF-2-5.数据类型转换</h3><p>​        有关spring属性注入的问题到这里基本上就讲完了，但是最近一名开发者向我咨询了一个问题，我觉得需要给各位学习者分享一下。在学习阶段其实我们遇到的问题往往复杂度比较低，单一性比较强，但是到了线上开发时，都是综合性的问题，而这个开发者遇到的问题就是由于bean的属性注入引发的灾难。</p><p>​        先把问题描述一下，这位开发者连接数据库正常操作，但是运行程序后显示的信息是密码错误。</p><pre class=" language-CMD"><code class="language-CMD">java.sql.SQLException: Access denied for user 'root'@'localhost' (using password: YES)</code></pre><p>​        其实看到这个报错，几乎所有的学习者都能分辨出来，这是用户名和密码不匹配，就就是密码输入错了，但是问题就在于密码并没有输入错误，这就比较讨厌了。给的报错信息无法帮助你有效的分析问题，甚至会给你带到沟里。如果是初学者，估计这会心态就崩了，我密码没错啊，你怎么能说我有错误呢？来看看用户名密码的配置是如何写的：</p><pre class=" language-YAML"><code class="language-YAML">spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    username: root    password: 0127</code></pre><p>​        这名开发者的生日是1月27日，所以密码就使用了0127，其实问题就出在这里了。</p><p>​        之前在基础篇讲属性注入时，提到过类型相关的知识，在整数相关知识中有这么一句话，<strong>支持二进制，八进制，十六进制</strong></p><img src="img\image-20220222225748370.png" alt="image-20220222225748370" style="zoom:80%;" /><p>​        这个问题就处在这里了，因为0127在开发者眼中是一个字符串“0127”，但是在springboot看来，这就是一个数字，而且是一个八进制的数字。当后台使用String类型接收数据时，如果配置文件中配置了一个整数值，他是先安装整数进行处理，读取后再转换成字符串。巧了，0127撞上了八进制的格式，所以最终以十进制数字87的结果存在了。</p><p>​        这里提两个注意点，第一，字符串标准书写加上引号包裹，养成习惯，第二，遇到0开头的数据多注意吧。</p><p><strong>总结</strong></p><ol><li>yaml文件中对于数字的定义支持进制书写格式，如需使用字符串请使用引号明确标注</li></ol><h2 id="KF-3-测试"><a href="#KF-3-测试" class="headerlink" title="KF-3.测试"></a>KF-3.测试</h2><p>​        说完bean配置相关的内容，下面要对前面讲过的一个知识做加强了，测试。测试是保障程序正确性的唯一屏障，在企业级开发中更是不可缺少，但是由于测试代码往往不产生实际效益，所以一些小型公司并不是很关注，导致一些开发者从小型公司进入中大型公司后，往往这一块比较短板，所以还是要拿出来把这一块知识好好说说，做一名专业的开发人员。</p><h3 id="KF-3-1-加载测试专用属性"><a href="#KF-3-1-加载测试专用属性" class="headerlink" title="KF-3-1.加载测试专用属性"></a>KF-3-1.加载测试专用属性</h3><p>​        测试过程本身并不是一个复杂的过程，但是很多情况下测试时需要模拟一些线上情况，或者模拟一些特殊情况。如果当前环境按照线上环境已经设定好了，例如是下面的配置</p><pre class=" language-YAML"><code class="language-YAML">env:  maxMemory: 32GB  minMemory: 16GB</code></pre><p>​        但是你现在想测试对应的兼容性，需要测试如下配置</p><pre class=" language-YAML"><code class="language-YAML">env:  maxMemory: 16GB  minMemory: 8GB</code></pre><p>​        这个时候我们能不能每次测试的时候都去修改源码application.yml中的配置进行测试呢？显然是不行的。每次测试前改过来，每次测试后改回去，这太麻烦了。于是我们就想，需要在测试环境中创建一组临时属性，去覆盖我们源码中设定的属性，这样测试用例就相当于是一个独立的环境，能够独立测试，这样就方便多了。</p><p><strong>临时属性</strong></p><p>​        springboot已经为我们开发者早就想好了这种问题该如何解决，并且提供了对应的功能入口。在测试用例程序中，可以通过对注解@SpringBootTest添加属性来模拟临时属性，具体如下：</p><pre class=" language-JAVA"><code class="language-JAVA">//properties属性可以为当前测试用例添加临时的属性配置@SpringBootTest(properties = &#123;"test.prop=testValue1"&#125;)public class PropertiesAndArgsTest &#123;    @Value("$&#123;test.prop&#125;")    private String msg;        @Test    void testProperties()&#123;        System.out.println(msg);    &#125;&#125;</code></pre><p>​        使用注解@SpringBootTest的properties属性就可以为当前测试用例添加临时的属性，覆盖源码配置文件中对应的属性值进行测试。</p><p><strong>临时参数</strong></p><p>​        除了上述这种情况，在前面讲解使用命令行启动springboot程序时讲过，通过命令行参数也可以设置属性值。而且线上启动程序时，通常都会添加一些专用的配置信息。作为运维人员他们才不懂java，更不懂这些配置的信息具体格式该怎么写，那如果我们作为开发者提供了对应的书写内容后，能否提前测试一下这些配置信息是否有效呢？当时是可以的，还是通过注解@SpringBootTest的另一个属性来进行设定。</p><pre class=" language-JAVA"><code class="language-JAVA">//args属性可以为当前测试用例添加临时的命令行参数@SpringBootTest(args=&#123;"--test.prop=testValue2"&#125;)public class PropertiesAndArgsTest &#123;        @Value("$&#123;test.prop&#125;")    private String msg;        @Test    void testProperties()&#123;        System.out.println(msg);    &#125;&#125;</code></pre><p>​        使用注解@SpringBootTest的args属性就可以为当前测试用例模拟命令行参数并进行测试。</p><p>​        说到这里，好奇宝宝们肯定就有新问题了，如果两者共存呢？其实如果思考一下配置属性与命令行参数的加载优先级，这个结果就不言而喻了。在属性加载的优先级设定中，有明确的优先级设定顺序，还记得下面这个顺序吗？</p><img src="img\image-20211206100859236.png" alt="image-20211206100859236" style="zoom:67%;" /><p>​        在这个属性加载优先级的顺序中，明确规定了命令行参数的优先级排序是11，而配置属性的优先级是3，结果不言而喻了，args属性配置优先于properties属性配置加载。</p><p>​        到这里我们就掌握了如果在测试用例中去模拟临时属性的设定。</p><p><strong>总结</strong></p><ol><li>加载测试临时属性可以通过注解@SpringBootTest的properties和args属性进行设定，此设定应用范围仅适用于当前测试用例</li></ol><p><strong>思考</strong></p><p>​        应用于测试环境的临时属性解决了，如果想在测试的时候临时加载一些bean能不做呢？也就是说我测试时，想搞一些独立的bean出来，专门应用于测试环境，能否实现呢？咱们下一节再讲。</p><h3 id="KF-3-2-加载测试专用配置"><a href="#KF-3-2-加载测试专用配置" class="headerlink" title="KF-3-2.加载测试专用配置"></a>KF-3-2.加载测试专用配置</h3><p>​        上一节提出了临时配置一些专用于测试环境的bean的需求，这一节我们就来解决这个问题。</p><p>​        学习过Spring的知识，我们都知道，其实一个spring环境中可以设置若干个配置文件或配置类，若干个配置信息可以同时生效。现在我们的需求就是在测试环境中再添加一个配置类，然后启动测试环境时，生效此配置就行了。其实做法和spring环境中加载多个配置信息的方式完全一样。具体操作步骤如下：</p><p><strong>步骤①</strong>：在测试包test中创建专用的测试环境配置类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MsgConfig</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> String <span class="token function">msg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token string">"bean msg"</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        上述配置仅用于演示当前实验效果，实际开发可不能这么注入String类型的数据</p><p><strong>步骤②</strong>：在启动测试环境时，导入测试环境专用的配置类，使用@Import注解即可实现</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>MsgConfig<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigurationTest</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> String msg<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        到这里就通过@Import属性实现了基于开发环境的配置基础上，对配置进行测试环境的追加操作，实现了1+1的配置环境效果。这样我们就可以实现每一个不同的测试用例加载不同的bean的效果，丰富测试用例的编写，同时不影响开发环境的配置。</p><p><strong>总结</strong></p><ol><li>定义测试环境专用的配置类，然后通过@Import注解在具体的测试中导入临时的配置，例如测试用例，方便测试过程，且上述配置不影响其他的测试类环境</li></ol><p><strong>思考</strong></p><p>​        当前我们已经可以实现业务层和数据层的测试，并且通过临时配置，控制每个测试用例加载不同的测试数据。但是实际企业开发不仅要保障业务层与数据层的功能安全有效，也要保障表现层的功能正常。但是我们目的对表现层的测试都是通过postman手工测试的，并没有在打包过程中体现表现层功能被测试通过。能否在测试用例中对表现层进行功能测试呢？还真可以，咱们下一节再讲。</p><h3 id="KF-3-3-Web环境模拟测试"><a href="#KF-3-3-Web环境模拟测试" class="headerlink" title="KF-3-3.Web环境模拟测试"></a>KF-3-3.Web环境模拟测试</h3><p>​        在测试中对表现层功能进行测试需要一个基础和一个功能。所谓的一个基础是运行测试程序时，必须启动web环境，不然没法测试web功能。一个功能是必须在测试程序中具备发送web请求的能力，不然无法实现web功能的测试。所以在测试用例中测试表现层接口这项工作就转换成了两件事，一，如何在测试类中启动web测试，二，如何在测试类中发送web请求。下面一件事一件事进行，先说第一个</p><p><strong>测试类中启动web环境</strong></p><p>​        每一个springboot的测试类上方都会标准@SpringBootTest注解，而注解带有一个属性，叫做webEnvironment。通过该属性就可以设置在测试用例中启动web环境，具体如下：</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class WebTest &#123;    &#125;</code></pre><p>​        测试类中启动web环境时，可以指定启动的Web环境对应的端口，springboot提供了4种设置值，分别如下：</p><img src="img\image-20220223125453317.png" alt="image-20220223125453317" style="zoom:80%;" /><ul><li>MOCK：根据当前设置确认是否启动web环境，例如使用了Servlet的API就启动web环境，属于适配性的配置</li><li>DEFINED_PORT：使用自定义的端口作为web服务器端口</li><li>RANDOM_PORT：使用随机端口作为web服务器端口</li><li>NONE：不启动web环境</li></ul><p>​        通过上述配置，现在启动测试程序时就可以正常启用web环境了，建议大家测试时使用RANDOM_PORT，避免代码中因为写死设定引发线上功能打包测试时由于端口冲突导致意外现象的出现。就是说你程序中写了用8080端口，结果线上环境8080端口被占用了，结果你代码中所有写的东西都要改，这就是写死代码的代价。现在你用随机端口就可以测试出来你有没有这种问题的隐患了。</p><p>​        测试环境中的web环境已经搭建好了，下面就可以来解决第二个问题了，如何在程序代码中发送web请求。</p><p><strong>测试类中发送请求</strong></p><p>​        对于测试类中发送请求，其实java的API就提供对应的功能，只不过平时各位小伙伴接触的比较少，所以较为陌生。springboot为了便于开发者进行对应的功能开发，对其又进行了包装，简化了开发步骤，具体操作如下：</p><p><strong>步骤①</strong>：在测试类中开启web虚拟调用功能，通过注解@AutoConfigureMockMvc实现此功能的开启</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>webEnvironment <span class="token operator">=</span> SpringBootTest<span class="token punctuation">.</span>WebEnvironment<span class="token punctuation">.</span>RANDOM_PORT<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//开启虚拟MVC调用</span><span class="token annotation punctuation">@AutoConfigureMockMvc</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebTest</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤②</strong>：定义发起虚拟调用的对象MockMVC，通过自动装配的形式初始化对象</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>webEnvironment <span class="token operator">=</span> SpringBootTest<span class="token punctuation">.</span>WebEnvironment<span class="token punctuation">.</span>RANDOM_PORT<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//开启虚拟MVC调用</span><span class="token annotation punctuation">@AutoConfigureMockMvc</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebTest</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testWeb</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Autowired</span> MockMvc mvc<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤③</strong>：创建一个虚拟请求对象，封装请求的路径，并使用MockMVC对象发送对应请求</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token punctuation">(</span>webEnvironment <span class="token operator">=</span> SpringBootTest<span class="token punctuation">.</span>WebEnvironment<span class="token punctuation">.</span>RANDOM_PORT<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//开启虚拟MVC调用</span><span class="token annotation punctuation">@AutoConfigureMockMvc</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebTest</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testWeb</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Autowired</span> MockMvc mvc<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//http://localhost:8080/books</span>        <span class="token comment" spellcheck="true">//创建虚拟请求，当前访问/books</span>        MockHttpServletRequestBuilder builder <span class="token operator">=</span> MockMvcRequestBuilders<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/books"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//执行对应的请求</span>        mvc<span class="token punctuation">.</span><span class="token function">perform</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        执行测试程序，现在就可以正常的发送/books对应的请求了，注意访问路径不要写<a href="http://localhost:8080/books%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%89%8D%E9%9D%A2%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8IP%E5%9C%B0%E5%9D%80%E5%92%8C%E7%AB%AF%E5%8F%A3%E4%BD%BF%E7%94%A8%E7%9A%84%E6%98%AF%E5%BD%93%E5%89%8D%E8%99%9A%E6%8B%9F%E7%9A%84web%E7%8E%AF%E5%A2%83%EF%BC%8C%E6%97%A0%E9%9C%80%E6%8C%87%E5%AE%9A%EF%BC%8C%E4%BB%85%E6%8C%87%E5%AE%9A%E8%AF%B7%E6%B1%82%E7%9A%84%E5%85%B7%E4%BD%93%E8%B7%AF%E5%BE%84%E5%8D%B3%E5%8F%AF%E3%80%82">http://localhost:8080/books，因为前面的服务器IP地址和端口使用的是当前虚拟的web环境，无需指定，仅指定请求的具体路径即可。</a></p><p><strong>总结</strong></p><ol><li>在测试类中测试web层接口要保障测试类启动时启动web容器，使用@SpringBootTest注解的webEnvironment属性可以虚拟web环境用于测试</li><li>为测试方法注入MockMvc对象，通过MockMvc对象可以发送虚拟请求，模拟web请求调用过程</li></ol><p><strong>思考</strong></p><p>​        目前已经成功的发送了请求，但是还没有起到测试的效果，测试过程必须出现预计值与真实值的比对结果才能确认测试结果是否通过，虚拟请求中能对哪些请求结果进行比对呢？咱们下一节再讲。</p><p><strong>web环境请求结果比对</strong></p><p>​        上一节已经在测试用例中成功的模拟出了web环境，并成功的发送了web请求，本节就来解决发送请求后如何比对发送结果的问题。其实发完请求得到的信息只有一种，就是响应对象。至于响应对象中包含什么，就可以比对什么。常见的比对内容如下：</p><ul><li><p>响应状态匹配</p><pre class=" language-JAVA"><code class="language-JAVA">@Testvoid testStatus(@Autowired MockMvc mvc) throws Exception &#123;    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    StatusResultMatchers status = MockMvcResultMatchers.status();    //预计本次调用时成功的：状态200    ResultMatcher ok = status.isOk();    //添加预计值到本次调用过程中进行匹配    action.andExpect(ok);&#125;</code></pre></li><li><p>响应体匹配（非json数据格式）</p><pre class=" language-JAVA"><code class="language-JAVA">@Testvoid testBody(@Autowired MockMvc mvc) throws Exception &#123;    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    ContentResultMatchers content = MockMvcResultMatchers.content();    ResultMatcher result = content.string("springboot2");    //添加预计值到本次调用过程中进行匹配    action.andExpect(result);&#125;</code></pre></li><li><p>响应体匹配（json数据格式，开发中的主流使用方式）</p><pre class=" language-JAVA"><code class="language-JAVA">@Testvoid testJson(@Autowired MockMvc mvc) throws Exception &#123;    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    ContentResultMatchers content = MockMvcResultMatchers.content();    ResultMatcher result = content.json("&#123;\"id\":1,\"name\":\"springboot2\",\"type\":\"springboot\"&#125;");    //添加预计值到本次调用过程中进行匹配    action.andExpect(result);&#125;</code></pre></li><li><p>响应头信息匹配</p><pre class=" language-JAVA"><code class="language-JAVA">@Testvoid testContentType(@Autowired MockMvc mvc) throws Exception &#123;    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");    ResultActions action = mvc.perform(builder);    //设定预期值 与真实值进行比较，成功测试通过，失败测试失败    //定义本次调用的预期值    HeaderResultMatchers header = MockMvcResultMatchers.header();    ResultMatcher contentType = header.string("Content-Type", "application/json");    //添加预计值到本次调用过程中进行匹配    action.andExpect(contentType);&#125;</code></pre></li></ul><p>​        基本上齐了，头信息，正文信息，状态信息都有了，就可以组合出一个完美的响应结果比对结果了。以下范例就是三种信息同时进行匹配校验，也是一个完整的信息匹配过程。</p><pre class=" language-JAVA"><code class="language-JAVA">@Testvoid testGetById(@Autowired MockMvc mvc) throws Exception &#123;    MockHttpServletRequestBuilder builder = MockMvcRequestBuilders.get("/books");    ResultActions action = mvc.perform(builder);    StatusResultMatchers status = MockMvcResultMatchers.status();    ResultMatcher ok = status.isOk();    action.andExpect(ok);    HeaderResultMatchers header = MockMvcResultMatchers.header();    ResultMatcher contentType = header.string("Content-Type", "application/json");    action.andExpect(contentType);    ContentResultMatchers content = MockMvcResultMatchers.content();    ResultMatcher result = content.json("&#123;\"id\":1,\"name\":\"springboot\",\"type\":\"springboot\"&#125;");    action.andExpect(result);&#125;</code></pre><p><strong>总结</strong></p><ol><li>web虚拟调用可以对本地虚拟请求的返回响应信息进行比对，分为响应头信息比对、响应体信息比对、响应状态信息比对</li></ol><h3 id="KF-3-4-数据层测试回滚"><a href="#KF-3-4-数据层测试回滚" class="headerlink" title="KF-3-4.数据层测试回滚"></a>KF-3-4.数据层测试回滚</h3><p>​        当前我们的测试程序可以完美的进行表现层、业务层、数据层接口对应的功能测试了，但是测试用例开发完成后，在打包的阶段由于test生命周期属于必须被运行的生命周期，如果跳过会给系统带来极高的安全隐患，所以测试用例必须执行。但是新的问题就呈现了，测试用例如果测试时产生了事务提交就会在测试过程中对数据库数据产生影响，进而产生垃圾数据。这个过程不是我们希望发生的，作为开发者测试用例该运行运行，但是过程中产生的数据不要在我的系统中留痕，这样该如何处理呢？</p><p>​        springboot早就为开发者想到了这个问题，并且针对此问题给出了最简解决方案，在原始测试用例中添加注解@Transactional即可实现当前测试用例的事务不提交。当程序运行后，只要注解@Transactional出现的位置存在注解@SpringBootTest，springboot就会认为这是一个测试程序，无需提交事务，所以也就可以避免事务的提交。</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootTest@Transactional@Rollback(true)public class DaoTest &#123;    @Autowired    private BookService bookService;    @Test    void testSave()&#123;        Book book = new Book();        book.setName("springboot3");        book.setType("springboot3");        book.setDescription("springboot3");        bookService.save(book);    &#125;&#125;</code></pre><p>​        如果开发者想提交事务，也可以，再添加一个@RollBack的注解，设置回滚状态为false即可正常提交事务，是不是很方便？springboot在辅助开发者日常工作这一块展现出了惊人的能力，实在太贴心了。</p><p><strong>总结</strong></p><ol><li>在springboot的测试类中通过添加注解@Transactional来阻止测试用例提交事务</li><li>通过注解@Rollback控制springboot测试类执行结果是否提交事务，需要配合注解@Transactional使用</li></ol><p><strong>思考</strong></p><p>​        当前测试程序已经近乎完美了，但是由于测试用例中书写的测试数据属于固定数据，往往失去了测试的意义，开发者可以针对测试用例进行针对性开发，这样就有可能出现测试用例不能完美呈现业务逻辑代码是否真实有效的达成业务目标的现象，解决方案其实很容易想，测试用例的数据只要随机产生就可以了，能实现吗？咱们下一节再讲。</p><h3 id="KF-3-5-测试用例数据设定"><a href="#KF-3-5-测试用例数据设定" class="headerlink" title="KF-3-5.测试用例数据设定"></a>KF-3-5.测试用例数据设定</h3><p>​        对于测试用例的数据固定书写肯定是不合理的，springboot提供了在配置中使用随机值的机制，确保每次运行程序加载的数据都是随机的。具体如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">testcase</span><span class="token punctuation">:</span>  <span class="token key atrule">book</span><span class="token punctuation">:</span>    <span class="token key atrule">id</span><span class="token punctuation">:</span> $&amp;<span class="token comment" spellcheck="true">#123;random.int&amp;#125;</span>    <span class="token key atrule">id2</span><span class="token punctuation">:</span> $&amp;<span class="token comment" spellcheck="true">#123;random.int(10)&amp;#125;</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> $&amp;<span class="token comment" spellcheck="true">#123;random.int!5,10!&amp;#125;</span>    <span class="token key atrule">name</span><span class="token punctuation">:</span> $&amp;<span class="token comment" spellcheck="true">#123;random.value&amp;#125;</span>    <span class="token key atrule">uuid</span><span class="token punctuation">:</span> $&amp;<span class="token comment" spellcheck="true">#123;random.uuid&amp;#125;</span>    <span class="token key atrule">publishTime</span><span class="token punctuation">:</span> $&amp;<span class="token comment" spellcheck="true">#123;random.long&amp;#125;</span></code></pre><p>​        当前配置就可以在每次运行程序时创建一组随机数据，避免每次运行时数据都是固定值的尴尬现象发生，有助于测试功能的进行。数据的加载按照之前加载数据的形式，使用@ConfigurationProperties注解即可</p><pre class=" language-JAVA"><code class="language-JAVA">@Component@Data@ConfigurationProperties(prefix = "testcase.book")public class BookCase &#123;    private int id;    private int id2;    private int type;    private String name;    private String uuid;    private long publishTime;&#125;</code></pre><p>​        对于随机值的产生，还有一些小的限定规则，比如产生的数值性数据可以设置范围等，具体如下：</p><img src="img\image-20220223135454862.png" alt="image-20220223135454862" style="zoom:80%;" /><ul><li>${random.int}表示随机整数</li><li>${random.int(10)}表示10以内的随机数</li><li>${random.int(10,20)}表示10到20的随机数</li><li>其中()可以是任意字符，例如[]，!!均可</li></ul><p><strong>总结</strong></p><ol><li>使用随机数据可以替换测试用例中书写的固定数据，提高测试用例中的测试数据有效性</li></ol><h2 id="KF-4-数据层解决方案"><a href="#KF-4-数据层解决方案" class="headerlink" title="KF-4.数据层解决方案"></a>KF-4.数据层解决方案</h2><p>​        开发实用篇前三章基本上是开胃菜，从第四章开始，开发实用篇进入到了噩梦难度了，从这里开始，不再是单纯的在springboot内部搞事情了，要涉及到很多相关知识。本章节主要内容都是和数据存储与读取相关，前期学习的知识与数据层有关的技术基本上都围绕在数据库这个层面上，所以本章要讲的第一个大的分支就是SQL解决方案相关的内容，除此之外，数据的来源还可以是非SQL技术相关的数据操作，因此第二部分围绕着NOSQL解决方案讲解。至于什么是NOSQL解决方案，讲到了再说吧。下面就从SQL解决方案说起。</p><h3 id="KF-4-1-SQL"><a href="#KF-4-1-SQL" class="headerlink" title="KF-4-1.SQL"></a>KF-4-1.SQL</h3><p>​        回忆一下之前做SSMP整合的时候数据层解决方案涉及到了哪些技术？MySQL数据库与MyBatisPlus框架，后面又学了Druid数据源的配置，所以现在数据层解决方案可以说是Mysql+Druid+MyBatisPlus。而三个技术分别对应了数据层操作的三个层面：</p><ul><li>数据源技术：Druid</li><li>持久化技术：MyBatisPlus</li><li>数据库技术：MySQL</li></ul><p>​        下面的研究就分为三个层面进行研究，对应上面列出的三个方面，咱们就从第一个数据源技术开始说起。</p><h4 id="数据源技术"><a href="#数据源技术" class="headerlink" title="数据源技术"></a>数据源技术</h4><p>​        目前我们使用的数据源技术是Druid，运行时可以在日志中看到对应的数据源初始化信息，具体如下：</p><pre class=" language-CMD"><code class="language-CMD">INFO 28600 --- [           main] c.a.d.s.b.a.DruidDataSourceAutoConfigure : Init DruidDataSourceINFO 28600 --- [           main] com.alibaba.druid.pool.DruidDataSource   : &#123;dataSource-1&#125; inited</code></pre><p>​        如果不使用Druid数据源，程序运行后是什么样子呢？是独立的数据库连接对象还是有其他的连接池技术支持呢？将Druid技术对应的starter去掉再次运行程序可以在日志中找到如下初始化信息：</p><pre class=" language-CMD"><code class="language-CMD">INFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...INFO 31820 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</code></pre><p>​        虽然没有DruidDataSource相关的信息了，但是我们发现日志中有HikariDataSource这个信息，就算不懂这是个什么技术，看名字也能看出来，以DataSource结尾的名称，这一定是一个数据源技术。我们又没有手工添加这个技术，这个技术哪里来的呢？这就是这一节要讲的知识，springboot内嵌数据源。</p><p>​        数据层技术是每一个企业级应用程序都会用到的，而其中必定会进行数据库连接的管理。springboot根据开发者的习惯出发，开发者提供了数据源技术，就用你提供的，开发者没有提供，那总不能手工管理一个一个的数据库连接对象啊，怎么办？我给你一个默认的就好了，这样省心又省事，大家都方便。</p><p>​        springboot提供了3款内嵌数据源技术，分别如下：</p><ul><li>HikariCP</li><li>Tomcat提供DataSource</li><li>Commons DBCP</li></ul><p>​        第一种，HikartCP，这是springboot官方推荐的数据源技术，作为默认内置数据源使用。啥意思？你不配置数据源，那就用这个。</p><p>​        第二种，Tomcat提供的DataSource，如果不想用HikartCP，并且使用tomcat作为web服务器进行web程序的开发，使用这个。为什么是Tomcat，不是其他web服务器呢？因为web技术导入starter后，默认使用内嵌tomcat，既然都是默认使用的技术了，那就一用到底，数据源也用它的。有人就提出怎么才能不使用HikartCP用tomcat提供的默认数据源对象呢？把HikartCP技术的坐标排除掉就OK了。</p><p>​        第三种，DBCP，这个使用的条件就更苛刻了，既不使用HikartCP也不使用tomcat的DataSource时，默认给你用这个。</p><p>​        springboot这心操的，也是稀碎啊，就怕你自己管不好连接对象，给你一顿推荐，真是开发界的最强辅助。既然都给你奶上了，那就受用吧，怎么配置使用这些东西呢？之前我们配置druid时使用druid的starter对应的配置如下：</p><pre class=" language-YAML"><code class="language-YAML">spring:  datasource:    druid:             url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC      driver-class-name: com.mysql.cj.jdbc.Driver      username: root      password: root</code></pre><p>​        换成是默认的数据源HikariCP后，直接吧druid删掉就行了，如下：</p><pre class=" language-YAML"><code class="language-YAML">spring:  datasource:    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    driver-class-name: com.mysql.cj.jdbc.Driver    username: root    password: root</code></pre><p>​         当然，也可以写上是对hikari做的配置，但是url地址要单独配置，如下：</p><pre class=" language-YAML"><code class="language-YAML">spring:  datasource:    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    hikari:      driver-class-name: com.mysql.cj.jdbc.Driver      username: root      password: root</code></pre><p>​        这就是配置hikari数据源的方式。如果想对hikari做进一步的配置，可以继续配置其独立的属性。例如：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>    <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span>3306/ssm_db<span class="token punctuation">?</span>serverTimezone=UTC    <span class="token key atrule">hikari</span><span class="token punctuation">:</span>      <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver      <span class="token key atrule">username</span><span class="token punctuation">:</span> root      <span class="token key atrule">password</span><span class="token punctuation">:</span> root      <span class="token key atrule">maximum-pool-size</span><span class="token punctuation">:</span> <span class="token number">50</span></code></pre><p>​        如果不想使用hikari数据源，使用tomcat的数据源或者DBCP配置格式也是一样的。学习到这里，以后我们做数据层时，数据源对象的选择就不再是单一的使用druid数据源技术了，可以根据需要自行选择。</p><p><strong>总结</strong></p><ol><li>springboot技术提供了3种内置的数据源技术，分别是Hikari、tomcat内置数据源、DBCP</li></ol><h4 id="持久化技术"><a href="#持久化技术" class="headerlink" title="持久化技术"></a>持久化技术</h4><p>​        说完数据源解决方案，再来说一下持久化解决方案。springboot充分发挥其最强辅助的特征，给开发者提供了一套现成的数据层技术，叫做JdbcTemplate。其实这个技术不能说是springboot提供的，因为不使用springboot技术，一样能使用它，谁提供的呢？spring技术提供的，所以在springboot技术范畴中，这个技术也是存在的，毕竟springboot技术是加速spring程序开发而创建的。</p><p>​        这个技术其实就是回归到jdbc最原始的编程形式来进行数据层的开发，下面直接上操作步骤：</p><p><strong>步骤①</strong>：导入jdbc对应的坐标，记得是starter</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>&lt;/dependency</code></pre><p><strong>步骤②</strong>：自动装配JdbcTemplate对象</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">Springboot15SqlApplicationTests</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">testJdbcTemplate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Autowired</span> JdbcTemplate jdbcTemplate<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤③</strong>：使用JdbcTemplate实现查询操作（非实体类封装数据的查询操作）</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testJdbcTemplate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Autowired</span> JdbcTemplate jdbcTemplate<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    String sql <span class="token operator">=</span> <span class="token string">"select * from tbl_book"</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">>></span> maps <span class="token operator">=</span> jdbcTemplate<span class="token punctuation">.</span><span class="token function">queryForList</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>maps<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤④</strong>：使用JdbcTemplate实现查询操作（实体类封装数据的查询操作）</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testJdbcTemplate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Autowired</span> JdbcTemplate jdbcTemplate<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    String sql <span class="token operator">=</span> <span class="token string">"select * from tbl_book"</span><span class="token punctuation">;</span>    RowMapper<span class="token operator">&lt;</span>Book<span class="token operator">></span> rm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RowMapper</span><span class="token operator">&lt;</span>Book<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> Book <span class="token function">mapRow</span><span class="token punctuation">(</span>ResultSet rs<span class="token punctuation">,</span> <span class="token keyword">int</span> rowNum<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            Book temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"type"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            temp<span class="token punctuation">.</span><span class="token function">setDescription</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"description"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> temp<span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Book<span class="token operator">></span> list <span class="token operator">=</span> jdbcTemplate<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>sql<span class="token punctuation">,</span> rm<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤⑤</strong>：使用JdbcTemplate实现增删改操作</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testJdbcTemplateSave</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Autowired</span> JdbcTemplate jdbcTemplate<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    String sql <span class="token operator">=</span> <span class="token string">"insert into tbl_book values(3,'springboot1','springboot2','springboot3')"</span><span class="token punctuation">;</span>    jdbcTemplate<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        如果想对JdbcTemplate对象进行相关配置，可以在yml文件中进行设定，具体如下：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">jdbc</span><span class="token punctuation">:</span>    <span class="token key atrule">template</span><span class="token punctuation">:</span>      <span class="token key atrule">query-timeout</span><span class="token punctuation">:</span> <span class="token number">-1   </span><span class="token comment" spellcheck="true"># 查询超时时间</span>      <span class="token key atrule">max-rows</span><span class="token punctuation">:</span> <span class="token number">500       </span><span class="token comment" spellcheck="true"># 最大行数</span>      <span class="token key atrule">fetch-size</span><span class="token punctuation">:</span> <span class="token number">-1      </span><span class="token comment" spellcheck="true"># 缓存行数</span></code></pre><p><strong>总结</strong></p><ol><li>SpringBoot内置JdbcTemplate持久化解决方案</li><li>使用JdbcTemplate需要导入spring-boot-starter-jdbc的坐标</li></ol><h4 id="数据库技术"><a href="#数据库技术" class="headerlink" title="数据库技术"></a>数据库技术</h4><p>​        截止到目前，springboot给开发者提供了内置的数据源解决方案和持久化解决方案，在数据层解决方案三件套中还剩下一个数据库，莫非springboot也提供有内置的解决方案？还真有，还不是一个，三个，这一节就来说说内置的数据库解决方案。</p><p>​        springboot提供了3款内置的数据库，分别是</p><ul><li>H2</li><li>HSQL</li><li>Derby</li></ul><p>​        以上三款数据库除了可以独立安装之外，还可以像是tomcat服务器一样，采用内嵌的形式运行在spirngboot容器中。内嵌在容器中运行，那必须是java对象啊，对，这三款数据库底层都是使用java语言开发的。</p><p>​        我们一直使用MySQL数据库就挺好的，为什么有需求用这个呢？原因就在于这三个数据库都可以采用内嵌容器的形式运行，在应用程序运行后，如果我们进行测试工作，此时测试的数据无需存储在磁盘上，但是又要测试使用，内嵌数据库就方便了，运行在内存中，该测试测试，该运行运行，等服务器关闭后，一切烟消云散，多好，省得你维护外部数据库了。这也是内嵌数据库的最大优点，方便进行功能测试。</p><p>​        下面以H2数据库为例讲解如何使用这些内嵌数据库，操作步骤也非常简单，简单才好用嘛</p><p><strong>步骤①</strong>：导入H2数据库对应的坐标，一共2个</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.h2database<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>h2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-jpa<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：将工程设置为web工程，启动工程时启动H2数据库</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤③</strong>：通过配置开启H2数据库控制台访问程序，也可以使用其他的数据库连接软件操作</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">h2</span><span class="token punctuation">:</span>    <span class="token key atrule">console</span><span class="token punctuation">:</span>      <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token key atrule">path</span><span class="token punctuation">:</span> /h2</code></pre><p>​        web端访问路径/h2，访问密码123456，如果访问失败，先配置下列数据源，启动程序运行后再次访问/h2路径就可以正常访问了</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">datasource</span><span class="token punctuation">:</span>  <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>h2<span class="token punctuation">:</span>~/test  <span class="token key atrule">hikari</span><span class="token punctuation">:</span>    <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> org.h2.Driver    <span class="token key atrule">username</span><span class="token punctuation">:</span> sa    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span></code></pre><p><strong>步骤④</strong>：使用JdbcTemplate或MyBatisPlus技术操作数据库</p><p>（略）</p><p>​        其实我们只是换了一个数据库而已，其他的东西都不受影响。一个重要提醒，别忘了，上线时，把内存级数据库关闭，采用MySQL数据库作为数据持久化方案，关闭方式就是设置enabled属性为false即可。</p><p><strong>总结</strong></p><ol><li>H2内嵌式数据库启动方式，添加坐标，添加配置</li><li>H2数据库线上运行时请务必关闭</li></ol><p>​        到这里SQL相关的数据层解决方案就讲完了，现在的可选技术就丰富的多了。</p><ul><li>数据源技术：Druid、Hikari、tomcat DataSource、DBCP</li><li>持久化技术：MyBatisPlus、MyBatis、JdbcTemplate</li><li>数据库技术：MySQL、H2、HSQL、Derby</li></ul><p>​        现在开发程序时就可以在以上技术中任选一种组织成一套数据库解决方案了。</p><h3 id="KF-4-2-NoSQL"><a href="#KF-4-2-NoSQL" class="headerlink" title="KF-4-2.NoSQL"></a>KF-4-2.NoSQL</h3><p>​        SQL数据层解决方案说完了，下面来说收NoSQL数据层解决方案。这个NoSQL是什么意思呢？从字面来看，No表示否定，NoSQL就是非关系型数据库解决方案，意思就是数据该存存该取取，只是这些数据不放在关系型数据库中了，那放在哪里？自然是一些能够存储数据的其他相关技术中了，比如Redis等。本节讲解的内容就是springboot如何整合这些技术，在springboot官方文档中提供了10种相关技术的整合方案，我们将讲解国内市场上最流行的几款NoSQL数据库整合方案，分别是Redis、MongoDB、ES。</p><p>​        因为每个小伙伴学习这门课程的时候起点不同，为了便于各位学习者更好的学习，每种技术在讲解整合前都会先讲一下安装和基本使用，然后再讲整合。如果对某个技术比较熟悉的小伙伴可以直接跳过安装的学习过程，直接看整合方案即可。此外上述这些技术最佳使用方案都是在Linux服务器上部署，但是考虑到各位小伙伴的学习起点差异过大，所以下面的课程都是以Windows平台作为安装基础讲解，如果想看Linux版软件安装，可以再找到对应技术的学习文档查阅学习。</p><h4 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h4><p>​        Redis是一款采用key-value数据存储格式的内存级NoSQL数据库，重点关注数据存储格式，是key-value格式，也就是键值对的存储形式。与MySQL数据库不同，MySQL数据库有表、有字段、有记录，Redis没有这些东西，就是一个名称对应一个值，并且数据以存储在内存中使用为主。什么叫以存储在内存中为主？其实Redis有它的数据持久化方案，分别是RDB和AOF，但是Redis自身并不是为了数据持久化而生的，主要是在内存中保存数据，加速数据访问的，所以说是一款内存级数据库。</p><p>​        Redis支持多种数据存储格式，比如可以直接存字符串，也可以存一个map集合，list集合，后面会涉及到一些不同格式的数据操作，这个需要先学习一下才能进行整合，所以在基本操作中会介绍一些相关操作。下面就先安装，再操作，最后说整合</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><p>​        windows版安装包下载地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p><p>​        下载的安装包有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，这里就不介绍安装过程了，本课程采用的是msi一键安装的msi文件进行安装的。</p><p>​        啥是msi，其实就是一个文件安装包，不仅安装软件，还帮你把安装软件时需要的功能关联在一起，打包操作。比如如安装序列、创建和设置安装路径、设置系统依赖项、默认设定安装选项和控制安装过程的属性。说简单点就是一站式服务，安装过程一条龙操作一气呵成，就是为小白用户提供的软件安装程序。</p><p>​        安装完毕后会得到如下文件，其中有两个文件对应两个命令，是启动Redis的核心命令，需要再CMD命令行模式执行。</p><img src="img\image-20220224091709173.png" alt="image-20220224091709173" style="zoom: 80%;" /><p><strong>启动服务器</strong></p><pre class=" language-CMD"><code class="language-CMD">redis-server.exe redis.windows.conf</code></pre><p>​        初学者无需调整服务器对外服务端口，默认6379。</p><p><strong>启动客户端</strong></p><pre class=" language-CMD"><code class="language-CMD">redis-cli.exe</code></pre><p>​        如果启动redis服务器失败，可以先启动客户端，然后执行shutdown操作后退出，此时redis服务器就可以正常执行了。</p><h5 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h5><p>​        服务器启动后，使用客户端就可以连接服务器，类似于启动完MySQL数据库，然后启动SQL命令行操作数据库。        </p><p>​        放置一个字符串数据到redis中，先为数据定义一个名称，比如name,age等，然后使用命令set设置数据到redis服务器中即可</p><pre class=" language-CMD"><code class="language-CMD">set name itheimaset age 12</code></pre><p>​        从redis中取出已经放入的数据，根据名称取，就可以得到对应数据。如果没有对应数据就会得到(nil)</p><pre class=" language-CMD"><code class="language-CMD">get nameget age</code></pre><p>​        以上使用的数据存储是一个名称对应一个值，如果要维护的数据过多，可以使用别的数据存储结构。例如hash，它是一种一个名称下可以存储多个数据的存储模型，并且每个数据也可以有自己的二级存储名称。向hash结构中存储数据格式如下：</p><pre><code>hset a a1 aa1        #对外key名称是a，在名称为a的存储模型中，a1这个key中保存了数据aa1hset a a2 aa2</code></pre><p>​        获取hash结构中的数据命令如下</p><pre class=" language-CMD"><code class="language-CMD">hget a a1            #得到aa1hget a a2            #得到aa2</code></pre><p>​        有关redis的基础操作就普及到这里，需要全面掌握redis技术，请参看相关教程学习。</p><h5 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h5><p>​        在进行整合之前先梳理一下整合的思想，springboot整合任何技术其实就是在springboot中使用对应技术的API。如果两个技术没有交集，就不存在整合的概念了。所谓整合其实就是使用springboot技术去管理其他技术，几个问题是躲不掉的。</p><p>​        第一，需要先导入对应技术的坐标，而整合之后，这些坐标都有了一些变化</p><p>​        第二，任何技术通常都会有一些相关的设置信息，整合之后，这些信息如何写，写在哪是一个问题</p><p>​        第三，没有整合之前操作如果是模式A的话，整合之后如果没有给开发者带来一些便捷操作，那整合将毫无意义，所以整合后操作肯定要简化一些，那对应的操作方式自然也有所不同</p><p>​        按照上面的三个问题去思考springboot整合所有技术是一种通用思想，在整合的过程中会逐步摸索出整合的套路，而且适用性非常强，经过若干种技术的整合后基本上可以总结出一套固定思维。</p><p>​        下面就开始springboot整合redis，操作步骤如下：</p><p><strong>步骤①</strong>：导入springboot整合redis的starter坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>​        上述坐标可以在创建模块的时候通过勾选的形式进行选择，归属NoSQL分类中</p><img src="img\image-20220224101142220.png" alt="image-20220224101142220" style="zoom:50%;" /><p><strong>步骤②</strong>：进行基础配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span></code></pre><p>​        操作redis，最基本的信息就是操作哪一台redis服务器，所以服务器地址属于基础配置信息，不可缺少。但是即便你不配置，目前也是可以用的。因为以上两组信息都有默认配置，刚好就是上述配置值。</p><p><strong>步骤③</strong>：使用springboot整合redis的专用客户端接口操作，此处使用的是RedisTemplate</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">Springboot16RedisApplicationTests</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RedisTemplate redisTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        ValueOperations ops <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ops<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token number">41</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        ValueOperations ops <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object age <span class="token operator">=</span> ops<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">hset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        HashOperations ops <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ops<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"info"</span><span class="token punctuation">,</span><span class="token string">"b"</span><span class="token punctuation">,</span><span class="token string">"bb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">hget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        HashOperations ops <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForHash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object val <span class="token operator">=</span> ops<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"info"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        在操作redis时，需要先确认操作何种数据，根据数据种类得到操作接口。例如使用opsForValue()获取string类型的数据操作接口，使用opsForHash()获取hash类型的数据操作接口，剩下的就是调用对应api操作了。各种类型的数据操作接口如下：</p><img src="img\image-20220224103104908.png" alt="image-20220224103104908" style="zoom:80%;" /><p><strong>总结</strong></p><ol><li>springboot整合redis步骤<ol><li>导入springboot整合redis的starter坐标</li><li>进行基础配置</li><li>使用springboot整合redis的专用客户端接口RedisTemplate操作</li></ol></li></ol><p><strong>StringRedisTemplate</strong></p><p>​        由于redis内部不提供java对象的存储格式，因此当操作的数据以对象的形式存在时，会进行转码，转换成字符串格式后进行操作。为了方便开发者使用基于字符串为数据的操作，springboot整合redis时提供了专用的API接口StringRedisTemplate，你可以理解为这是RedisTemplate的一种指定数据泛型的操作API。</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootTestpublic class StringRedisTemplateTest &#123;    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Test    void get()&#123;        ValueOperations<String, String> ops = stringRedisTemplate.opsForValue();        String name = ops.get("name");        System.out.println(name);    &#125;&#125;</code></pre><p><strong>redis客户端选择</strong></p><pre><code>     springboot整合redis技术提供了多种客户端兼容模式，默认提供的是lettucs客户端技术，也可以根据需要切换成指定客户端技术，例如jedis客户端技术，切换成jedis客户端技术操作步骤如下：</code></pre><p><strong>步骤①</strong>：导入jedis坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>​        jedis坐标受springboot管理，无需提供版本号</p><p><strong>步骤②</strong>：配置客户端技术类型，设置为jedis</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">client-type</span><span class="token punctuation">:</span> jedis</code></pre><p><strong>步骤③</strong>：根据需要设置对应的配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>    <span class="token key atrule">client-type</span><span class="token punctuation">:</span> jedis    <span class="token key atrule">lettuce</span><span class="token punctuation">:</span>      <span class="token key atrule">pool</span><span class="token punctuation">:</span>        <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">16</span>    <span class="token key atrule">jedis</span><span class="token punctuation">:</span>      <span class="token key atrule">pool</span><span class="token punctuation">:</span>        <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">16</span></code></pre><p><strong>lettcus与jedis区别</strong></p><ul><li>jedis连接Redis服务器是直连模式，当多线程模式下使用jedis会存在线程安全问题，解决方案可以通过配置连接池使每个连接专用，这样整体性能就大受影响</li><li>lettcus基于Netty框架进行与Redis服务器连接，底层设计中采用StatefulRedisConnection。 StatefulRedisConnection自身是线程安全的，可以保障并发访问安全问题，所以一个连接可以被多线程复用。当然lettcus也支持多连接实例一起工作</li></ul><p><strong>总结</strong></p><ol><li>springboot整合redis提供了StringRedisTemplate对象，以字符串的数据格式操作redis</li><li>如果需要切换redis客户端实现技术，可以通过配置的形式进行</li></ol><h4 id="SpringBoot整合MongoDB"><a href="#SpringBoot整合MongoDB" class="headerlink" title="SpringBoot整合MongoDB"></a>SpringBoot整合MongoDB</h4><p>​        使用Redis技术可以有效的提高数据访问速度，但是由于Redis的数据格式单一性，无法操作结构化数据，当操作对象型的数据时，Redis就显得捉襟见肘。在保障访问速度的情况下，如果想操作结构化数据，看来Redis无法满足要求了，此时需要使用全新的数据存储结束来解决此问题，本节讲解springboot如何整合MongoDB技术。</p><p>​        MongoDB是一个开源、高性能、无模式的文档型数据库，它是NoSQL数据库产品中的一种，是最像关系型数据库的非关系型数据库。</p><p>​        上述描述中几个词，其中对于我们最陌生的词是无模式的。什么叫无模式呢？简单说就是作为一款数据库，没有固定的数据存储结构，第一条数据可能有A、B、C一共3个字段，第二条数据可能有D、E、F也是3个字段，第三条数据可能是A、C、E3个字段，也就是说数据的结构不固定，这就是无模式。有人会说这有什么用啊？灵活，随时变更，不受约束。基于上述特点，MongoDB的应用面也会产生一些变化。以下列出了一些可以使用MongoDB作为数据存储的场景，但是并不是必须使用MongoDB的场景：</p><ul><li>淘宝用户数据<ul><li>存储位置：数据库</li><li>特征：永久性存储，修改频度极低</li></ul></li><li>游戏装备数据、游戏道具数据<ul><li>存储位置：数据库、Mongodb</li><li>特征：永久性存储与临时存储相结合、修改频度较高</li></ul></li><li>直播数据、打赏数据、粉丝数据<ul><li>存储位置：数据库、Mongodb</li><li>特征：永久性存储与临时存储相结合，修改频度极高</li></ul></li><li>物联网数据<ul><li>存储位置：Mongodb</li><li>特征：临时存储，修改频度飞速</li></ul></li></ul><p>​        快速了解一下MongoDB，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合</p><h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><p>​        windows版安装包下载地址：<a href="https://www.mongodb.com/try/download">https://www.mongodb.com/try/download</a></p><p>​        下载的安装包也有两种形式，一种是一键安装的msi文件，还有一种是解压缩就能使用的zip文件，哪种形式都行，本课程采用解压缩zip文件进行安装。</p><p>​        解压缩完毕后会得到如下文件，其中bin目录包含了所有mongodb的可执行命令</p><p><img src="img%5Cimage-20220224111306933.png" alt="image-20220224111306933"></p><p>​        mongodb在运行时需要指定一个数据存储的目录，所以创建一个数据存储目录，通常放置在安装目录中，此处创建data的目录用来存储数据，具体如下</p><p><img src="img%5Cimage-20220224111053408.png" alt="image-20220224111053408"></p><p>​        如果在安装的过程中出现了如下警告信息，就是告诉你，你当前的操作系统缺少了一些系统文件，这个不用担心。</p><img src="img\image-20220224113956882.png" alt="image-20220224113956882" style="zoom:50%;" /><p>​        根据下列方案即可解决，在浏览器中搜索提示缺少的名称对应的文件，并下载，将下载的文件拷贝到windows安装目录的system32目录下，然后在命令行中执行regsvr32命令注册此文件。根据下载的文件名不同，执行命令前更改对应名称。</p><pre class=" language-CMD"><code class="language-CMD">regsvr32 vcruntime140_1.dll</code></pre><p><strong>启动服务器</strong></p><pre class=" language-CMD"><code class="language-CMD">mongod --dbpath=..\data\db</code></pre><p>​        启动服务器时需要指定数据存储位置，通过参数–dbpath进行设置，可以根据需要自行设置数据存储路径。默认服务端口27017。</p><p><strong>启动客户端</strong></p><pre class=" language-CMD"><code class="language-CMD">mongo --host=127.0.0.1 --port=27017</code></pre><h5 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h5><p>​        MongoDB虽然是一款数据库，但是它的操作并不是使用SQL语句进行的，因此操作方式各位小伙伴可能比较陌生，好在有一些类似于Navicat的数据库客户端软件，能够便捷的操作MongoDB，先安装一个客户端，再来操作MongoDB。</p><p>​        同类型的软件较多，本次安装的软件时Robo3t，Robot3t是一款绿色软件，无需安装，解压缩即可。解压缩完毕后进入安装目录双击robot3t.exe即可使用。</p><img src="img\image-20220224114911573.png" alt="image-20220224114911573" style="zoom: 33%;" /><p>​        打开软件首先要连接MongoDB服务器，选择【File】菜单，选择【Connect…】</p><p><img src="img%5Cimage-20220224115202422.png" alt="image-20220224115202422"></p><p>​        进入连接管理界面后，选择左上角的【Create】链接，创建新的连接设置</p><img src="img\image-20220224115254200.png" alt="image-20220224115254200" style="zoom:80%;" /><p>​        如果输入设置值即可连接（默认不修改即可连接本机27017端口）</p><p><img src="img%5Cimage-20220224115300266.png" alt="image-20220224115300266"></p><p>​        连接成功后在命令输入区域输入命令即可操作MongoDB。</p><p>​        创建数据库：在左侧菜单中使用右键创建，输入数据库名称即可</p><p>​        创建集合：在Collections上使用右键创建，输入集合名称即可，集合等同于数据库中的表的作用</p><p>​        新增文档：（文档是一种类似json格式的数据，初学者可以先把数据理解为就是json数据）    </p><pre class=" language-CMD"><code class="language-CMD">db.集合名称.insert/save/insertOne(文档)</code></pre><p>​        删除文档：</p><pre class=" language-CMD"><code class="language-CMD">db.集合名称.remove(条件)</code></pre><p>​        修改文档：</p><pre class=" language-cmd"><code class="language-cmd">db.集合名称.update(条件，&#123;操作种类:&#123;文档&#125;&#125;)</code></pre><p>​        查询文档：</p><pre class=" language-CMD"><code class="language-CMD">基础查询查询全部：           db.集合.find();查第一条：           db.集合.findOne()查询指定数量文档：    db.集合.find().limit(10)                    //查10条文档跳过指定数量文档：    db.集合.find().skip(20)                    //跳过20条文档统计：                  db.集合.count()排序：                db.集合.sort(&#123;age:1&#125;)                        //按age升序排序投影：                db.集合名称.find(条件,&#123;name:1,age:1&#125;)         //仅保留name与age域条件查询基本格式：            db.集合.find(&#123;条件&#125;)模糊查询：            db.集合.find(&#123;域名:/正则表达式/&#125;)          //等同SQL中的like，比like强大，可以执行正则所有规则条件比较运算：           db.集合.find(&#123;域名:&#123;$gt:值&#125;&#125;)                //等同SQL中的数值比较操作，例如：name>18包含查询：            db.集合.find(&#123;域名:&#123;$in:[值1，值2]&#125;&#125;)        //等同于SQL中的in条件连接查询：           db.集合.find(&#123;$and:[&#123;条件1&#125;,&#123;条件2&#125;]&#125;)       //等同于SQL中的and、or</code></pre><p>​        有关MongoDB的基础操作就普及到这里，需要全面掌握MongoDB技术，请参看相关教程学习。</p><h5 id="整合-1"><a href="#整合-1" class="headerlink" title="整合"></a>整合</h5><p>​        使用springboot整合MongDB该如何进行呢？其实springboot为什么使用的开发者这么多，就是因为他的套路几乎完全一样。导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB同样如此。</p><p>​        第一，先导入对应技术的整合starter坐标</p><p>​        第二，配置必要信息</p><p>​        第三，使用提供的API操作即可</p><p>​        下面就开始springboot整合MongoDB，操作步骤如下：</p><p><strong>步骤①</strong>：导入springboot整合MongoDB的starter坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-mongodb<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>​        上述坐标也可以在创建模块的时候通过勾选的形式进行选择，同样归属NoSQL分类中</p><img src="img\image-20220224120721626.png" alt="image-20220224120721626" style="zoom: 67%;" /><p><strong>步骤②</strong>：进行基础配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">data</span><span class="token punctuation">:</span>    <span class="token key atrule">mongodb</span><span class="token punctuation">:</span>      <span class="token key atrule">uri</span><span class="token punctuation">:</span> mongodb<span class="token punctuation">:</span>//localhost/itheima</code></pre><p>​        操作MongoDB需要的配置与操作redis一样，最基本的信息都是操作哪一台服务器，区别就是连接的服务器IP地址和端口不同，书写格式不同而已。</p><p><strong>步骤③</strong>：使用springboot整合MongoDB的专用客户端接口MongoTemplate来进行操作</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">Springboot17MongodbApplicationTests</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> MongoTemplate mongoTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        Book book <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Book</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        book<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        book<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"springboot2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        book<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token string">"springboot2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        book<span class="token punctuation">.</span><span class="token function">setDescription</span><span class="token punctuation">(</span><span class="token string">"springboot2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mongoTemplate<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Book<span class="token operator">></span> all <span class="token operator">=</span> mongoTemplate<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span>Book<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>all<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        整合工作到这里就做完了，感觉既熟悉也陌生。熟悉的是这个套路，三板斧，就这三招，导坐标做配置用API操作，陌生的是这个技术，里面具体的操作API可能会不熟悉，有关springboot整合MongoDB我们就讲到这里。有兴趣可以继续学习MongoDB的操作，然后再来这里通过编程的形式操作MongoDB。</p><p><strong>总结</strong></p><ol><li>springboot整合MongoDB步骤<ol><li>导入springboot整合MongoDB的starter坐标</li><li>进行基础配置</li><li>使用springboot整合MongoDB的专用客户端接口MongoTemplate操作</li></ol></li></ol><h4 id="SpringBoot整合ES"><a href="#SpringBoot整合ES" class="headerlink" title="SpringBoot整合ES"></a>SpringBoot整合ES</h4><p>​        NoSQL解决方案已经讲完了两种技术的整合了，Redis可以使用内存加载数据并实现数据快速访问，MongoDB可以在内存中存储类似对象的数据并实现数据的快速访问，在企业级开发中对于速度的追求是永无止境的。下面要讲的内容也是一款NoSQL解决方案，只不过他的作用不是为了直接加速数据的读写，而是加速数据的查询的，叫做ES技术。</p><p>​        ES（Elasticsearch）是一个分布式全文搜索引擎，重点是全文搜索。</p><p>​        那什么是全文搜索呢？比如用户要买一本书，以Java为关键字进行搜索，不管是书名中还是书的介绍中，甚至是书的作者名字，只要包含java就作为查询结果返回给用户查看，上述过程就使用了全文搜索技术。搜索的条件不再是仅用于对某一个字段进行比对，而是在一条数据中使用搜索条件去比对更多的字段，只要能匹配上就列入查询结果，这就是全文搜索的目的。而ES技术就是一种可以实现上述效果的技术。</p><p>​        要实现全文搜索的效果，不可能使用数据库中like操作去进行比对，这种效率太低了。ES设计了一种全新的思想，来实现全文搜索。具体操作过程如下：</p><ol><li><p>将被查询的字段的数据全部文本信息进行查分，分成若干个词</p><ul><li>例如“中华人民共和国”就会被拆分成三个词，分别是“中华”、“人民”、“共和国”，此过程有专业术语叫做分词。分词的策略不同，分出的效果不一样，不同的分词策略称为分词器。</li></ul></li><li><p>将分词得到的结果存储起来，对应每条数据的id</p><ul><li><p>例如id为1的数据中名称这一项的值是“中华人民共和国”，那么分词结束后，就会出现“中华”对应id为1，“人民”对应id为1，“共和国”对应id为1</p></li><li><p>例如id为2的数据中名称这一项的值是“人民代表大会“，那么分词结束后，就会出现“人民”对应id为2，“代表”对应id为2，“大会”对应id为2</p></li><li><p>此时就会出现如下对应结果，按照上述形式可以对所有文档进行分词。需要注意分词的过程不是仅对一个字段进行，而是对每一个参与查询的字段都执行，最终结果汇总到一个表格中</p><table><thead><tr><th>分词结果关键字</th><th>对应id</th></tr></thead><tbody><tr><td>中华</td><td>1</td></tr><tr><td>人民</td><td>1,2</td></tr><tr><td>共和国</td><td>1</td></tr><tr><td>代表</td><td>2</td></tr><tr><td>大会</td><td>2</td></tr></tbody></table></li></ul></li><li><p>当进行查询时，如果输入“人民”作为查询条件，可以通过上述表格数据进行比对，得到id值1,2，然后根据id值就可以得到查询的结果数据了。</p></li></ol><p>​        上述过程中分词结果关键字内容每一个都不相同，作用有点类似于数据库中的索引，是用来加速数据查询的。但是数据库中的索引是对某一个字段进行添加索引，而这里的分词结果关键字不是一个完整的字段值，只是一个字段中的其中的一部分内容。并且索引使用时是根据索引内容查找整条数据，全文搜索中的分词结果关键字查询后得到的并不是整条的数据，而是数据的id，要想获得具体数据还要再次查询，因此这里为这种分词结果关键字起了一个全新的名称，叫做<strong>倒排索引</strong>。</p><p>​        通过上述内容的学习，发现使用ES其实准备工作还是挺多的，必须先建立文档的倒排索引，然后才能继续使用。快速了解一下ES的工作原理，下面直接开始我们的学习，老规矩，先安装，再操作，最后说整合。</p><h5 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h5><p>​        windows版安装包下载地址：<a href="https://www.elastic.co/cn/downloads/elasticsearch">https://</a><a href="https://www.elastic.co/cn/downloads/elasticsearch">www.elastic.co/cn/downloads/elasticsearch</a></p><p>​        下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件</p><p><img src="img%5Cimage-20220225132756400.png" alt="image-20220225132756400"></p><ul><li>bin目录：包含所有的可执行命令</li><li>config目录：包含ES服务器使用的配置文件</li><li>jdk目录：此目录中包含了一个完整的jdk工具包，版本17，当ES升级时，使用最新版本的jdk确保不会出现版本支持性不足的问题</li><li>lib目录：包含ES运行的依赖jar文件</li><li>logs目录：包含ES运行后产生的所有日志文件</li><li>modules目录：包含ES软件中所有的功能模块，也是一个一个的jar包。和jar目录不同，jar目录是ES运行期间依赖的jar包，modules是ES软件自己的功能jar包</li><li>plugins目录：包含ES软件安装的插件，默认为空</li></ul><p><strong>启动服务器</strong></p><pre class=" language-CMD"><code class="language-CMD">elasticsearch.bat</code></pre><p>​        双击elasticsearch.bat文件即可启动ES服务器，默认服务端口9200。通过浏览器访问<a href="http://localhost:9200看到如下信息视为ES服务器正常启动">http://localhost:9200看到如下信息视为ES服务器正常启动</a></p><pre class=" language-CMD"><code class="language-CMD">&#123;  "name" : "CZBK-**********",  "cluster_name" : "elasticsearch",  "cluster_uuid" : "j137DSswTPG8U4Yb-0T1Mg",  "version" : &#123;    "number" : "7.16.2",    "build_flavor" : "default",    "build_type" : "zip",    "build_hash" : "2b937c44140b6559905130a8650c64dbd0879cfb",    "build_date" : "2021-12-18T19:42:46.604893745Z",    "build_snapshot" : false,    "lucene_version" : "8.10.1",    "minimum_wire_compatibility_version" : "6.8.0",    "minimum_index_compatibility_version" : "6.0.0-beta1"  &#125;,  "tagline" : "You Know, for Search"&#125;</code></pre><h5 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h5><p>​        ES中保存有我们要查询的数据，只不过格式和数据库存储数据格式不同而已。在ES中我们要先创建倒排索引，这个索引的功能又点类似于数据库的表，然后将数据添加到倒排索引中，添加的数据称为文档。所以要进行ES的操作要先创建索引，再添加文档，这样才能进行后续的查询操作。</p><p>​        要操作ES可以通过Rest风格的请求来进行，也就是说发送一个请求就可以执行一个操作。比如新建索引，删除索引这些操作都可以使用发送请求的形式来进行。</p><ul><li><p>创建索引，books是索引名称，下同</p><pre class=" language-CMD"><code class="language-CMD">PUT请求        http://localhost:9200/books</code></pre><p>发送请求后，看到如下信息即索引创建成功</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"acknowledged"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"shards_acknowledged"</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token property">"index"</span><span class="token operator">:</span> <span class="token string">"books"</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>重复创建已经存在的索引会出现错误信息，reason属性中描述错误原因</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"error"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"root_cause"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"resource_already_exists_exception"</span><span class="token punctuation">,</span>                <span class="token property">"reason"</span><span class="token operator">:</span> <span class="token string">"index [books/VgC_XMVAQmedaiBNSgO2-w] already exists"</span><span class="token punctuation">,</span>                <span class="token property">"index_uuid"</span><span class="token operator">:</span> <span class="token string">"VgC_XMVAQmedaiBNSgO2-w"</span><span class="token punctuation">,</span>                <span class="token property">"index"</span><span class="token operator">:</span> <span class="token string">"books"</span>            &amp;#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"resource_already_exists_exception"</span><span class="token punctuation">,</span>        <span class="token property">"reason"</span><span class="token operator">:</span> <span class="token string">"index [books/VgC_XMVAQmedaiBNSgO2-w] already exists"</span><span class="token punctuation">,</span>    # books索引已经存在        <span class="token property">"index_uuid"</span><span class="token operator">:</span> <span class="token string">"VgC_XMVAQmedaiBNSgO2-w"</span><span class="token punctuation">,</span>        <span class="token property">"index"</span><span class="token operator">:</span> <span class="token string">"book"</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    <span class="token property">"status"</span><span class="token operator">:</span> <span class="token number">400</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>查询索引</p><pre class=" language-CMD"><code class="language-CMD">GET请求        http://localhost:9200/books</code></pre><p>查询索引得到索引相关信息，如下</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"book"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"aliases"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"mappings"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"index"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token property">"routing"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token property">"allocation"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token property">"include"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token property">"_tier_preference"</span><span class="token operator">:</span> <span class="token string">"data_content"</span>                        &amp;#<span class="token number">125</span><span class="token punctuation">;</span>                    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>                &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>                <span class="token property">"number_of_shards"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>                <span class="token property">"provided_name"</span><span class="token operator">:</span> <span class="token string">"books"</span><span class="token punctuation">,</span>                <span class="token property">"creation_date"</span><span class="token operator">:</span> <span class="token string">"1645768584849"</span><span class="token punctuation">,</span>                <span class="token property">"number_of_replicas"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>                <span class="token property">"uuid"</span><span class="token operator">:</span> <span class="token string">"VgC_XMVAQmedaiBNSgO2-w"</span><span class="token punctuation">,</span>                <span class="token property">"version"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token property">"created"</span><span class="token operator">:</span> <span class="token string">"7160299"</span>                &amp;#<span class="token number">125</span><span class="token punctuation">;</span>            &amp;#<span class="token number">125</span><span class="token punctuation">;</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>如果查询了不存在的索引，会返回错误信息，例如查询名称为book的索引后信息如下</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"error"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"root_cause"</span><span class="token operator">:</span> <span class="token punctuation">[</span>            &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"index_not_found_exception"</span><span class="token punctuation">,</span>                <span class="token property">"reason"</span><span class="token operator">:</span> <span class="token string">"no such index [book]"</span><span class="token punctuation">,</span>                <span class="token property">"resource.type"</span><span class="token operator">:</span> <span class="token string">"index_or_alias"</span><span class="token punctuation">,</span>                <span class="token property">"resource.id"</span><span class="token operator">:</span> <span class="token string">"book"</span><span class="token punctuation">,</span>                <span class="token property">"index_uuid"</span><span class="token operator">:</span> <span class="token string">"_na_"</span><span class="token punctuation">,</span>                <span class="token property">"index"</span><span class="token operator">:</span> <span class="token string">"book"</span>            &amp;#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>        <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"index_not_found_exception"</span><span class="token punctuation">,</span>        <span class="token property">"reason"</span><span class="token operator">:</span> <span class="token string">"no such index [book]"</span><span class="token punctuation">,</span>        # 没有book索引        <span class="token property">"resource.type"</span><span class="token operator">:</span> <span class="token string">"index_or_alias"</span><span class="token punctuation">,</span>        <span class="token property">"resource.id"</span><span class="token operator">:</span> <span class="token string">"book"</span><span class="token punctuation">,</span>        <span class="token property">"index_uuid"</span><span class="token operator">:</span> <span class="token string">"_na_"</span><span class="token punctuation">,</span>        <span class="token property">"index"</span><span class="token operator">:</span> <span class="token string">"book"</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>    <span class="token property">"status"</span><span class="token operator">:</span> <span class="token number">404</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>删除索引</p><pre class=" language-CMD"><code class="language-CMD">DELETE请求    http://localhost:9200/books</code></pre><p>删除所有后，给出删除结果</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"acknowledged"</span><span class="token operator">:</span> <span class="token boolean">true</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>如果重复删除，会给出错误信息，同样在reason属性中描述具体的错误原因</p><pre class=" language-JSON"><code class="language-JSON">&#123;    "error": &#123;        "root_cause": [            &#123;                "type": "index_not_found_exception",                "reason": "no such index [books]",                "resource.type": "index_or_alias",                "resource.id": "book",                "index_uuid": "_na_",                "index": "book"            &#125;        ],        "type": "index_not_found_exception",        "reason": "no such index [books]",        # 没有books索引        "resource.type": "index_or_alias",        "resource.id": "book",        "index_uuid": "_na_",        "index": "book"    &#125;,    "status": 404&#125;</code></pre></li><li><p>创建索引并指定分词器</p><p>​        前面创建的索引是未指定分词器的，可以在创建索引时添加请求参数，设置分词器。目前国内较为流行的分词器是IK分词器，使用前先在下对应的分词器，然后使用。IK分词器下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a></p><p>​        分词器下载后解压到ES安装目录的plugins目录中即可，安装分词器后需要重新启动ES服务器。使用IK分词器创建索引格式：</p><pre class=" language-json"><code class="language-json">PUT请求        http<span class="token operator">:</span>//localhost<span class="token operator">:</span><span class="token number">9200</span>/books请求参数如下（注意是json格式的参数）&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"mappings"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                            #定义mappings属性，替换创建索引时对应的mappings属性                <span class="token property">"properties"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                        #定义索引中包含的属性设置            <span class="token property">"id"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                            #设置索引中包含id属性                <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"keyword"</span>            #当前属性可以被直接搜索            &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>            <span class="token property">"name"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                        #设置索引中包含name属性                <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"text"</span><span class="token punctuation">,</span>              #当前属性是文本信息，参与分词                  <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"ik_max_word"</span><span class="token punctuation">,</span>   #使用IK分词器进行分词                             <span class="token property">"copy_to"</span><span class="token operator">:</span><span class="token string">"all"</span>                #分词结果拷贝到all属性中            &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>            <span class="token property">"type"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"keyword"</span>            &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>            <span class="token property">"description"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"text"</span><span class="token punctuation">,</span>                                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"ik_max_word"</span><span class="token punctuation">,</span>                                <span class="token property">"copy_to"</span><span class="token operator">:</span><span class="token string">"all"</span>            &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>            <span class="token property">"all"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                            #定义属性，用来描述多个字段的分词结果集合，当前属性可以参与查询                <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"text"</span><span class="token punctuation">,</span>                                    <span class="token property">"analyzer"</span><span class="token operator">:</span><span class="token string">"ik_max_word"</span>            &amp;#<span class="token number">125</span><span class="token punctuation">;</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        创建完毕后返回结果和不使用分词器创建索引的结果是一样的，此时可以通过查看索引信息观察到添加的请求参数mappings已经进入到了索引属性中</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"books"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"aliases"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"mappings"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                        #mappings属性已经被替换            <span class="token property">"properties"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token property">"all"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span>                &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>                <span class="token property">"description"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"copy_to"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                        <span class="token string">"all"</span>                    <span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span>                &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>                <span class="token property">"id"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>                &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>                <span class="token property">"name"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"text"</span><span class="token punctuation">,</span>                    <span class="token property">"copy_to"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                        <span class="token string">"all"</span>                    <span class="token punctuation">]</span><span class="token punctuation">,</span>                    <span class="token property">"analyzer"</span><span class="token operator">:</span> <span class="token string">"ik_max_word"</span>                &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>                <span class="token property">"type"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token property">"type"</span><span class="token operator">:</span> <span class="token string">"keyword"</span>                &amp;#<span class="token number">125</span><span class="token punctuation">;</span>            &amp;#<span class="token number">125</span><span class="token punctuation">;</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"settings"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"index"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token property">"routing"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token property">"allocation"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                        <span class="token property">"include"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                            <span class="token property">"_tier_preference"</span><span class="token operator">:</span> <span class="token string">"data_content"</span>                        &amp;#<span class="token number">125</span><span class="token punctuation">;</span>                    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>                &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>                <span class="token property">"number_of_shards"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>                <span class="token property">"provided_name"</span><span class="token operator">:</span> <span class="token string">"books"</span><span class="token punctuation">,</span>                <span class="token property">"creation_date"</span><span class="token operator">:</span> <span class="token string">"1645769809521"</span><span class="token punctuation">,</span>                <span class="token property">"number_of_replicas"</span><span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">,</span>                <span class="token property">"uuid"</span><span class="token operator">:</span> <span class="token string">"DohYKvr_SZO4KRGmbZYmTQ"</span><span class="token punctuation">,</span>                <span class="token property">"version"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>                    <span class="token property">"created"</span><span class="token operator">:</span> <span class="token string">"7160299"</span>                &amp;#<span class="token number">125</span><span class="token punctuation">;</span>            &amp;#<span class="token number">125</span><span class="token punctuation">;</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul><p>目前我们已经有了索引了，但是索引中还没有数据，所以要先添加数据，ES中称数据为文档，下面进行文档操作。</p><ul><li><p>添加文档，有三种方式</p><pre class=" language-json"><code class="language-json">POST请求    http<span class="token operator">:</span>//localhost<span class="token operator">:</span><span class="token number">9200</span>/books/_doc        #使用系统生成idPOST请求    http<span class="token operator">:</span>//localhost<span class="token operator">:</span><span class="token number">9200</span>/books/_create/<span class="token number">1</span>    #使用指定idPOST请求    http<span class="token operator">:</span>//localhost<span class="token operator">:</span><span class="token number">9200</span>/books/_doc/<span class="token number">1</span>        #使用指定id，不存在创建，存在更新（版本递增）文档通过请求参数传递，数据格式json&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"springboot"</span><span class="token punctuation">,</span>    <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"springboot"</span><span class="token punctuation">,</span>    <span class="token property">"description"</span><span class="token operator">:</span><span class="token string">"springboot"</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span>  </code></pre></li><li><p>查询文档</p><pre class=" language-json"><code class="language-json">GET请求    http<span class="token operator">:</span>//localhost<span class="token operator">:</span><span class="token number">9200</span>/books/_doc/<span class="token number">1</span>         #查询单个文档         GET请求    http<span class="token operator">:</span>//localhost<span class="token operator">:</span><span class="token number">9200</span>/books/_search         #查询全部文档</code></pre></li><li><p>条件查询</p><pre class=" language-json"><code class="language-json">GET请求    http<span class="token operator">:</span>//localhost<span class="token operator">:</span><span class="token number">9200</span>/books/_search?q=name<span class="token operator">:</span>springboot    # q=查询属性名<span class="token operator">:</span>查询属性值</code></pre></li><li><p>删除文档</p><pre class=" language-json"><code class="language-json">DELETE请求    http<span class="token operator">:</span>//localhost<span class="token operator">:</span><span class="token number">9200</span>/books/_doc/<span class="token number">1</span></code></pre></li><li><p>修改文档（全量更新）</p><pre class=" language-json"><code class="language-json">PUT请求    http<span class="token operator">:</span>//localhost<span class="token operator">:</span><span class="token number">9200</span>/books/_doc/<span class="token number">1</span>文档通过请求参数传递，数据格式json&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"springboot"</span><span class="token punctuation">,</span>    <span class="token property">"type"</span><span class="token operator">:</span><span class="token string">"springboot"</span><span class="token punctuation">,</span>    <span class="token property">"description"</span><span class="token operator">:</span><span class="token string">"springboot"</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>修改文档（部分更新）</p><pre class=" language-json"><code class="language-json">POST请求    http<span class="token operator">:</span>//localhost<span class="token operator">:</span><span class="token number">9200</span>/books/_update/<span class="token number">1</span>文档通过请求参数传递，数据格式json&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                <span class="token property">"doc"</span><span class="token operator">:</span>&amp;#<span class="token number">123</span><span class="token punctuation">;</span>                        #部分更新并不是对原始文档进行更新，而是对原始文档对象中的doc属性中的指定属性更新        <span class="token property">"name"</span><span class="token operator">:</span><span class="token string">"springboot"</span>        #仅更新提供的属性值，未提供的属性值不参与更新操作    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li></ul><h5 id="整合-2"><a href="#整合-2" class="headerlink" title="整合"></a>整合</h5><p>​        使用springboot整合ES该如何进行呢？老规矩，导入坐标，做配置，使用API接口操作。整合Redis如此，整合MongoDB如此，整合ES依然如此。太没有新意了，其实不是没有新意，这就是springboot的强大之处，所有东西都做成相同规则，对开发者来说非常友好。</p><p>​        下面就开始springboot整合ES，操作步骤如下：</p><p><strong>步骤①</strong>：导入springboot整合ES的starter坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-elasticsearch<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：进行基础配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">elasticsearch</span><span class="token punctuation">:</span>    <span class="token key atrule">rest</span><span class="token punctuation">:</span>      <span class="token key atrule">uris</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">9200</span></code></pre><p>​        配置ES服务器地址，端口9200</p><p><strong>步骤③</strong>：使用springboot整合ES的专用客户端接口ElasticsearchRestTemplate来进行操作</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">Springboot18EsApplicationTests</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> ElasticsearchRestTemplate template<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        上述操作形式是ES早期的操作方式，使用的客户端被称为Low Level Client，这种客户端操作方式性能方面略显不足，于是ES开发了全新的客户端操作方式，称为High Level Client。高级别客户端与ES版本同步更新，但是springboot最初整合ES的时候使用的是低级别客户端，所以企业开发需要更换成高级别的客户端模式。</p><p>​        下面使用高级别客户端方式进行springboot整合ES，操作步骤如下：</p><p><strong>步骤①</strong>：导入springboot整合ES高级别客户端的坐标，此种形式目前没有对应的starter</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.elasticsearch.client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>elasticsearch-rest-high-level-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：使用编程的形式设置连接的ES服务器，并获取客户端对象</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">Springboot18EsApplicationTests</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> RestHighLevelClient client<span class="token punctuation">;</span>      <span class="token annotation punctuation">@Test</span>      <span class="token keyword">void</span> <span class="token function">testCreateClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          HttpHost host <span class="token operator">=</span> HttpHost<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"http://localhost:9200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          RestClientBuilder builder <span class="token operator">=</span> RestClient<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>          client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RestHighLevelClient</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>            client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        配置ES服务器地址与端口9200，记得客户端使用完毕需要手工关闭。由于当前客户端是手工维护的，因此不能通过自动装配的形式加载对象。</p><p><strong>步骤③</strong>：使用客户端对象操作ES，例如创建索引</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span><span class="token keyword">class</span> <span class="token class-name">Springboot18EsApplicationTests</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> RestHighLevelClient client<span class="token punctuation">;</span>      <span class="token annotation punctuation">@Test</span>      <span class="token keyword">void</span> <span class="token function">testCreateIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>          HttpHost host <span class="token operator">=</span> HttpHost<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"http://localhost:9200"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          RestClientBuilder builder <span class="token operator">=</span> RestClient<span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span>          client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RestHighLevelClient</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>                    CreateIndexRequest request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateIndexRequest</span><span class="token punctuation">(</span><span class="token string">"books"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          client<span class="token punctuation">.</span><span class="token function">indices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> RequestOptions<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>                     client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        高级别客户端操作是通过发送请求的方式完成所有操作的，ES针对各种不同的操作，设定了各式各样的请求对象，上例中创建索引的对象是CreateIndexRequest，其他操作也会有自己专用的Request对象。</p><p>​        当前操作我们发现，无论进行ES何种操作，第一步永远是获取RestHighLevelClient对象，最后一步永远是关闭该对象的连接。在测试中可以使用测试类的特性去帮助开发者一次性的完成上述操作，但是在业务书写时，还需要自行管理。将上述代码格式转换成使用测试类的初始化方法和销毁方法进行客户端对象的维护。</p><pre class=" language-JAVA"><code class="language-JAVA">@SpringBootTestclass Springboot18EsApplicationTests &#123;    @BeforeEach        //在测试类中每个操作运行前运行的方法    void setUp() &#123;        HttpHost host = HttpHost.create("http://localhost:9200");        RestClientBuilder builder = RestClient.builder(host);        client = new RestHighLevelClient(builder);    &#125;    @AfterEach        //在测试类中每个操作运行后运行的方法    void tearDown() throws IOException &#123;        client.close();    &#125;    private RestHighLevelClient client;    @Test    void testCreateIndex() throws IOException &#123;        CreateIndexRequest request = new CreateIndexRequest("books");        client.indices().create(request, RequestOptions.DEFAULT);    &#125;&#125;</code></pre><p>​        现在的书写简化了很多，也更合理。下面使用上述模式将所有的ES操作执行一遍，测试结果</p><p><strong>创建索引（IK分词器）</strong>：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">void</span> <span class="token function">testCreateIndexByIK</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    CreateIndexRequest request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateIndexRequest</span><span class="token punctuation">(</span><span class="token string">"books"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String json <span class="token operator">=</span> <span class="token string">"&amp;#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"    \"mappings\":&amp;#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"        \"properties\":&amp;#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"            \"id\":&amp;#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"                \"type\":\"keyword\"\n"</span> <span class="token operator">+</span>            <span class="token string">"            &amp;#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"            \"name\":&amp;#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"                \"type\":\"text\",\n"</span> <span class="token operator">+</span>            <span class="token string">"                \"analyzer\":\"ik_max_word\",\n"</span> <span class="token operator">+</span>            <span class="token string">"                \"copy_to\":\"all\"\n"</span> <span class="token operator">+</span>            <span class="token string">"            &amp;#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"            \"type\":&amp;#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"                \"type\":\"keyword\"\n"</span> <span class="token operator">+</span>            <span class="token string">"            &amp;#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"            \"description\":&amp;#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"                \"type\":\"text\",\n"</span> <span class="token operator">+</span>            <span class="token string">"                \"analyzer\":\"ik_max_word\",\n"</span> <span class="token operator">+</span>            <span class="token string">"                \"copy_to\":\"all\"\n"</span> <span class="token operator">+</span>            <span class="token string">"            &amp;#125;,\n"</span> <span class="token operator">+</span>            <span class="token string">"            \"all\":&amp;#123;\n"</span> <span class="token operator">+</span>            <span class="token string">"                \"type\":\"text\",\n"</span> <span class="token operator">+</span>            <span class="token string">"                \"analyzer\":\"ik_max_word\"\n"</span> <span class="token operator">+</span>            <span class="token string">"            &amp;#125;\n"</span> <span class="token operator">+</span>            <span class="token string">"        &amp;#125;\n"</span> <span class="token operator">+</span>            <span class="token string">"    &amp;#125;\n"</span> <span class="token operator">+</span>            <span class="token string">"&amp;#125;"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//设置请求中的参数</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span> XContentType<span class="token punctuation">.</span>JSON<span class="token punctuation">)</span><span class="token punctuation">;</span>    client<span class="token punctuation">.</span><span class="token function">indices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> RequestOptions<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        IK分词器是通过请求参数的形式进行设置的，设置请求参数使用request对象中的source方法进行设置，至于参数是什么，取决于你的操作种类。当请求中需要参数时，均可使用当前形式进行参数设置。    </p><p><strong>添加文档</strong>：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">//添加文档</span><span class="token keyword">void</span> <span class="token function">testCreateDoc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    Book book <span class="token operator">=</span> bookDao<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    IndexRequest request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexRequest</span><span class="token punctuation">(</span><span class="token string">"books"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span>XContentType<span class="token punctuation">.</span>JSON<span class="token punctuation">)</span><span class="token punctuation">;</span>    client<span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>RequestOptions<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        添加文档使用的请求对象是IndexRequest，与创建索引使用的请求对象不同。    </p><p><strong>批量添加文档</strong>：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">//批量添加文档</span><span class="token keyword">void</span> <span class="token function">testCreateDocAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    List<span class="token operator">&lt;</span>Book<span class="token operator">></span> bookList <span class="token operator">=</span> bookDao<span class="token punctuation">.</span><span class="token function">selectList</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    BulkRequest bulk <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BulkRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Book book <span class="token operator">:</span> bookList<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        IndexRequest request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IndexRequest</span><span class="token punctuation">(</span><span class="token string">"books"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">id</span><span class="token punctuation">(</span>book<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String json <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span>        request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span>json<span class="token punctuation">,</span>XContentType<span class="token punctuation">.</span>JSON<span class="token punctuation">)</span><span class="token punctuation">;</span>        bulk<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    client<span class="token punctuation">.</span><span class="token function">bulk</span><span class="token punctuation">(</span>bulk<span class="token punctuation">,</span>RequestOptions<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        批量做时，先创建一个BulkRequest的对象，可以将该对象理解为是一个保存request对象的容器，将所有的请求都初始化好后，添加到BulkRequest对象中，再使用BulkRequest对象的bulk方法，一次性执行完毕。</p><p><strong>按id查询文档</strong>：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">//按id查询</span><span class="token keyword">void</span> <span class="token function">testGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    GetRequest request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GetRequest</span><span class="token punctuation">(</span><span class="token string">"books"</span><span class="token punctuation">,</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    GetResponse response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> RequestOptions<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    String json <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getSourceAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        根据id查询文档使用的请求对象是GetRequest。</p><p><strong>按条件查询文档</strong>：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token comment" spellcheck="true">//按条件查询</span><span class="token keyword">void</span> <span class="token function">testSearch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    SearchRequest request <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchRequest</span><span class="token punctuation">(</span><span class="token string">"books"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    SearchSourceBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SearchSourceBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    builder<span class="token punctuation">.</span><span class="token function">query</span><span class="token punctuation">(</span>QueryBuilders<span class="token punctuation">.</span><span class="token function">termQuery</span><span class="token punctuation">(</span><span class="token string">"all"</span><span class="token punctuation">,</span><span class="token string">"spring"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    request<span class="token punctuation">.</span><span class="token function">source</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>    SearchResponse response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">search</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> RequestOptions<span class="token punctuation">.</span>DEFAULT<span class="token punctuation">)</span><span class="token punctuation">;</span>    SearchHits hits <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getHits</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>SearchHit hit <span class="token operator">:</span> hits<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String source <span class="token operator">=</span> hit<span class="token punctuation">.</span><span class="token function">getSourceAsString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//System.out.println(source);</span>        Book book <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parseObject</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> Book<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>book<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        按条件查询文档使用的请求对象是SearchRequest，查询时调用SearchRequest对象的termQuery方法，需要给出查询属性名，此处支持使用合并字段，也就是前面定义索引属性时添加的all属性。</p><p>​        springboot整合ES的操作到这里就说完了，与前期进行springboot整合redis和mongodb的差别还是蛮大的，主要原始就是我们没有使用springboot整合ES的客户端对象。至于操作，由于ES操作种类过多，所以显得操作略微有点复杂。有关springboot整合ES就先学习到这里吧。</p><p><strong>总结</strong></p><ol><li>springboot整合ES步骤<ol><li>导入springboot整合ES的High Level Client坐标</li><li>手工管理客户端对象，包括初始化和关闭操作</li><li>使用High Level Client根据操作的种类不同，选择不同的Request对象完成对应操作</li></ol></li></ol><h2 id="KF-5-整合第三方技术"><a href="#KF-5-整合第三方技术" class="headerlink" title="KF-5.整合第三方技术"></a>KF-5.整合第三方技术</h2><p>​        通过第四章的学习，我们领略到了springboot在整合第三方技术时强大的一致性，在第五章中我们要使用springboot继续整合各种各样的第三方技术，通过本章的学习，可以将之前学习的springboot整合第三方技术的思想贯彻到底，还是那三板斧。导坐标、做配置、调API。</p><p>​        springboot能够整合的技术实在是太多了，可以说是万物皆可整。本章将从企业级开发中常用的一些技术作为出发点，对各种各样的技术进行整合。</p><h3 id="KF-5-1-缓存"><a href="#KF-5-1-缓存" class="headerlink" title="KF-5-1.缓存"></a>KF-5-1.缓存</h3><p>​        企业级应用主要作用是信息处理，当需要读取数据时，由于受限于数据库的访问效率，导致整体系统性能偏低。</p><img src="img\image-20220226154148303.png" alt="image-20220226154148303" style="zoom:67%;" /><p>​                                                                      应用程序直接与数据库打交道，访问效率低</p><p>​        为了改善上述现象，开发者通常会在应用程序与数据库之间建立一种临时的数据存储机制，该区域中的数据在内存中保存，读写速度较快，可以有效解决数据库访问效率低下的问题。这一块临时存储数据的区域就是缓存。</p><img src="img\image-20220226154233010.png" alt="image-20220226154233010" style="zoom:67%;" /><pre><code>                                         使用缓存后，应用程序与缓存打交道，缓存与数据库打交道，数据访问效率提高</code></pre><p>​        缓存是什么？缓存是一种介于数据永久存储介质与应用程序之间的数据临时存储介质，使用缓存可以有效的减少低速数据读取过程的次数（例如磁盘IO），提高系统性能。此外缓存不仅可以用于提高永久性存储介质的数据读取效率，还可以提供临时的数据存储空间。而springboot提供了对市面上几乎所有的缓存技术进行整合的方案，下面就一起开启springboot整合缓存之旅。</p><h4 id="SpringBoot内置缓存解决方案"><a href="#SpringBoot内置缓存解决方案" class="headerlink" title="SpringBoot内置缓存解决方案"></a>SpringBoot内置缓存解决方案</h4><p>​        springboot技术提供有内置的缓存解决方案，可以帮助开发者快速开启缓存技术，并使用缓存技术进行数据的快速操作，例如读取缓存数据和写入数据到缓存。</p><p><strong>步骤①</strong>：导入springboot提供的缓存技术对应的starter</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-cache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token comment" spellcheck="true">//开启缓存功能</span><span class="token annotation punctuation">@EnableCaching</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot19CacheApplication</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Springboot19CacheApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤③</strong>：设置操作的数据是否使用缓存</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> BookDao bookDao<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">"cacheSpace"</span><span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token string">"#id"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> Book <span class="token function">getById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bookDao<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        在业务方法上面使用注解@Cacheable声明当前方法的返回值放入缓存中，其中要指定缓存的存储位置，以及缓存中保存当前方法返回值对应的名称。上例中value属性描述缓存的存储位置，可以理解为是一个存储空间名，key属性描述了缓存中保存数据的名称，使用#id读取形参中的id值作为缓存名称。</p><p>​        使用@Cacheable注解后，执行当前操作，如果发现对应名称在缓存中没有数据，就正常读取数据，然后放入缓存；如果对应名称在缓存中有数据，就终止当前业务方法执行，直接返回缓存中的数据。</p><h4 id="手机验证码案例"><a href="#手机验证码案例" class="headerlink" title="手机验证码案例"></a>手机验证码案例</h4><p>​        为了便于下面演示各种各样的缓存技术，我们创建一个手机验证码的案例环境，模拟使用缓存保存手机验证码的过程。</p><p>​        手机验证码案例需求如下：</p><ul><li>输入手机号获取验证码，组织文档以短信形式发送给用户（页面模拟）</li><li>输入手机号和验证码验证结果</li></ul><p>​        为了描述上述操作，我们制作两个表现层接口，一个用来模拟发送短信的过程，其实就是根据用户提供的手机号生成一个验证码，然后放入缓存，另一个用来模拟验证码校验的过程，其实就是使用传入的手机号和验证码进行匹配，并返回最终匹配结果。下面直接制作本案例的模拟代码，先以上例中springboot提供的内置缓存技术来完成当前案例的制作。</p><p><strong>步骤①</strong>：导入springboot提供的缓存技术对应的starter</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-cache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：启用缓存，在引导类上方标注注解@EnableCaching配置springboot程序中可以使用缓存</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token comment" spellcheck="true">//开启缓存功能</span><span class="token annotation punctuation">@EnableCaching</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot19CacheApplication</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Springboot19CacheApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤③</strong>：定义验证码对应的实体类，封装手机号与验证码两个属性</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SMSCode</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String tele<span class="token punctuation">;</span>    <span class="token keyword">private</span> String code<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤④</strong>：定义验证码功能的业务层接口与实现类</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SMSCodeService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">sendCodeToSMS</span><span class="token punctuation">(</span>String tele<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkCode</span><span class="token punctuation">(</span>SMSCode smsCode<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SMSCodeServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SMSCodeService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> CodeUtils codeUtils<span class="token punctuation">;</span>    <span class="token annotation punctuation">@CachePut</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsCode"</span><span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"#tele"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">sendCodeToSMS</span><span class="token punctuation">(</span>String tele<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String code <span class="token operator">=</span> codeUtils<span class="token punctuation">.</span><span class="token function">generator</span><span class="token punctuation">(</span>tele<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkCode</span><span class="token punctuation">(</span>SMSCode smsCode<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//取出内存中的验证码与传递过来的验证码比对，如果相同，返回true</span>        String code <span class="token operator">=</span> smsCode<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String cacheCode <span class="token operator">=</span> codeUtils<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>smsCode<span class="token punctuation">.</span><span class="token function">getTele</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> code<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>cacheCode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        获取验证码后，当验证码失效时必须重新获取验证码，因此在获取验证码的功能上不能使用@Cacheable注解，@Cacheable注解是缓存中没有值则放入值，缓存中有值则取值。此处的功能仅仅是生成验证码并放入缓存，并不具有从缓存中取值的功能，因此不能使用@Cacheable注解，应该使用仅具有向缓存中保存数据的功能，使用@CachePut注解即可。</p><p>​        对于校验验证码的功能建议放入工具类中进行。</p><p><strong>步骤⑤</strong>：定义验证码的生成策略与根据手机号读取验证码的功能</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CodeUtils</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String <span class="token punctuation">[</span><span class="token punctuation">]</span> patch <span class="token operator">=</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span><span class="token string">"000000"</span><span class="token punctuation">,</span><span class="token string">"00000"</span><span class="token punctuation">,</span><span class="token string">"0000"</span><span class="token punctuation">,</span><span class="token string">"000"</span><span class="token punctuation">,</span><span class="token string">"00"</span><span class="token punctuation">,</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">generator</span><span class="token punctuation">(</span>String tele<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> hash <span class="token operator">=</span> tele<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> encryption <span class="token operator">=</span> <span class="token number">20206666</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> result <span class="token operator">=</span> hash <span class="token operator">^</span> encryption<span class="token punctuation">;</span>        <span class="token keyword">long</span> nowTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result <span class="token operator">=</span> result <span class="token operator">^</span> nowTime<span class="token punctuation">;</span>        <span class="token keyword">long</span> code <span class="token operator">=</span> result <span class="token operator">%</span> <span class="token number">1000000</span><span class="token punctuation">;</span>        code <span class="token operator">=</span> code <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token operator">-</span>code <span class="token operator">:</span> code<span class="token punctuation">;</span>        String codeStr <span class="token operator">=</span> code <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> codeStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> patch<span class="token punctuation">[</span>len<span class="token punctuation">]</span> <span class="token operator">+</span> codeStr<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsCode"</span><span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token string">"#tele"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> String <span class="token function">get</span><span class="token punctuation">(</span>String tele<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤⑥</strong>：定义验证码功能的web层接口，一个方法用于提供手机号获取验证码，一个方法用于提供手机号和验证码进行校验</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@RestController</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/sms"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SMSCodeController</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> SMSCodeService smsCodeService<span class="token punctuation">;</span>        <span class="token annotation punctuation">@GetMapping</span>    <span class="token keyword">public</span> String <span class="token function">getCode</span><span class="token punctuation">(</span>String tele<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String code <span class="token operator">=</span> smsCodeService<span class="token punctuation">.</span><span class="token function">sendCodeToSMS</span><span class="token punctuation">(</span>tele<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@PostMapping</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkCode</span><span class="token punctuation">(</span>SMSCode smsCode<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> smsCodeService<span class="token punctuation">.</span><span class="token function">checkCode</span><span class="token punctuation">(</span>smsCode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h4 id="SpringBoot整合Ehcache缓存"><a href="#SpringBoot整合Ehcache缓存" class="headerlink" title="SpringBoot整合Ehcache缓存"></a>SpringBoot整合Ehcache缓存</h4><p>​        手机验证码的案例已经完成了，下面就开始springboot整合各种各样的缓存技术，第一个整合Ehcache技术。Ehcache是一种缓存技术，使用springboot整合Ehcache其实就是变更一下缓存技术的实现方式，话不多说，直接开整</p><p><strong>步骤①</strong>：导入Ehcache的坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>net.sf.ehcache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>ehcache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>​        此处为什么不是导入Ehcache的starter，而是导入技术坐标呢？其实springboot整合缓存技术做的是通用格式，不管你整合哪种缓存技术，只是实现变化了，操作方式一样。这也体现出springboot技术的优点，统一同类技术的整合方式。</p><p><strong>步骤②</strong>：配置缓存技术实现使用Ehcache</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">cache</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> ehcache    <span class="token key atrule">ehcache</span><span class="token punctuation">:</span>      <span class="token key atrule">config</span><span class="token punctuation">:</span> ehcache.xml</code></pre><p>​        配置缓存的类型type为ehcache，此处需要说明一下，当前springboot可以整合的缓存技术中包含有ehcach，所以可以这样书写。其实这个type不可以随便写的，不是随便写一个名称就可以整合的。</p><p>​        由于ehcache的配置有独立的配置文件格式，因此还需要指定ehcache的配置文件，以便于读取相应配置</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="UTF-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ehcache</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>xsi</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://www.w3.org/2001/XMLSchema-instance<span class="token punctuation">"</span></span>         <span class="token attr-name"><span class="token namespace">xsi:</span>noNamespaceSchemaLocation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://ehcache.org/ehcache.xsd<span class="token punctuation">"</span></span>         <span class="token attr-name">updateCheck</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>diskStore</span> <span class="token attr-name">path</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>D:\ehcache<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token comment" spellcheck="true">&lt;!--默认缓存策略 --></span>    <span class="token comment" spellcheck="true">&lt;!-- external：是否永久存在，设置为true则不会被清除，此时与timeout冲突，通常设置为false--></span>    <span class="token comment" spellcheck="true">&lt;!-- diskPersistent：是否启用磁盘持久化--></span>    <span class="token comment" spellcheck="true">&lt;!-- maxElementsInMemory：最大缓存数量--></span>    <span class="token comment" spellcheck="true">&lt;!-- overflowToDisk：超过最大缓存数量是否持久化到磁盘--></span>    <span class="token comment" spellcheck="true">&lt;!-- timeToIdleSeconds：最大不活动间隔，设置过长缓存容易溢出，设置过短无效果，可用于记录时效性数据，例如验证码--></span>    <span class="token comment" spellcheck="true">&lt;!-- timeToLiveSeconds：最大存活时间--></span>    <span class="token comment" spellcheck="true">&lt;!-- memoryStoreEvictionPolicy：缓存清除策略--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>defaultCache</span>        <span class="token attr-name">eternal</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>        <span class="token attr-name">diskPersistent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>        <span class="token attr-name">maxElementsInMemory</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span>        <span class="token attr-name">overflowToDisk</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>        <span class="token attr-name">timeToIdleSeconds</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>60<span class="token punctuation">"</span></span>        <span class="token attr-name">timeToLiveSeconds</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>60<span class="token punctuation">"</span></span>        <span class="token attr-name">memoryStoreEvictionPolicy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>LRU<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span>        <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>smsCode<span class="token punctuation">"</span></span>        <span class="token attr-name">eternal</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>        <span class="token attr-name">diskPersistent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>        <span class="token attr-name">maxElementsInMemory</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>1000<span class="token punctuation">"</span></span>        <span class="token attr-name">overflowToDisk</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span>        <span class="token attr-name">timeToIdleSeconds</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span>        <span class="token attr-name">timeToLiveSeconds</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span>        <span class="token attr-name">memoryStoreEvictionPolicy</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>LRU<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ehcache</span><span class="token punctuation">></span></span></code></pre><p>​        注意前面的案例中，设置了数据保存的位置是smsCode</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@CachePut</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsCode"</span><span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"#tele"</span><span class="token punctuation">)</span><span class="token keyword">public</span> String <span class="token function">sendCodeToSMS</span><span class="token punctuation">(</span>String tele<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    String code <span class="token operator">=</span> codeUtils<span class="token punctuation">.</span><span class="token function">generator</span><span class="token punctuation">(</span>tele<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> code<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    </code></pre><p>​        这个设定需要保障ehcache中有一个缓存空间名称叫做smsCode的配置，前后要统一。在企业开发过程中，通过设置不同名称的cache来设定不同的缓存策略，应用于不同的缓存数据。</p><p>​        到这里springboot整合Ehcache就做完了，可以发现一点，原始代码没有任何修改，仅仅是加了一组配置就可以变更缓存供应商了，这也是springboot提供了统一的缓存操作接口的优势，变更实现并不影响原始代码的书写。</p><p><strong>总结</strong></p><ol><li>springboot使用Ehcache作为缓存实现需要导入Ehcache的坐标</li><li>修改设置，配置缓存供应商为ehcache，并提供对应的缓存配置文件</li></ol><p>​        </p><h4 id="SpringBoot整合Redis缓存"><a href="#SpringBoot整合Redis缓存" class="headerlink" title="SpringBoot整合Redis缓存"></a>SpringBoot整合Redis缓存</h4><p>​        上节使用Ehcache替换了springboot内置的缓存技术，其实springboot支持的缓存技术还很多，下面使用redis技术作为缓存解决方案来实现手机验证码案例。</p><p>​        比对使用Ehcache的过程，加坐标，改缓存实现类型为ehcache，做Ehcache的配置。如果还成redis做缓存呢？一模一样，加坐标，改缓存实现类型为redis，做redis的配置。差别之处只有一点，redis的配置可以在yml文件中直接进行配置，无需制作独立的配置文件。</p><p><strong>步骤①</strong>：导入redis的坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：配置缓存技术实现使用redis</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>  <span class="token key atrule">cache</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> redis</code></pre><p>​        如果需要对redis作为缓存进行配置，注意不是对原始的redis进行配置，而是配置redis作为缓存使用相关的配置，隶属于spring.cache.redis节点下，注意不要写错位置了。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">redis</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>  <span class="token key atrule">cache</span><span class="token punctuation">:</span>    <span class="token key atrule">type</span><span class="token punctuation">:</span> redis    <span class="token key atrule">redis</span><span class="token punctuation">:</span>      <span class="token key atrule">use-key-prefix</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>      <span class="token key atrule">key-prefix</span><span class="token punctuation">:</span> sms_      <span class="token key atrule">cache-null-values</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>      <span class="token key atrule">time-to-live</span><span class="token punctuation">:</span> 10s</code></pre><p><strong>总结</strong></p><ol><li>springboot使用redis作为缓存实现需要导入redis的坐标</li><li>修改设置，配置缓存供应商为redis，并提供对应的缓存配置</li></ol><h4 id="SpringBoot整合Memcached缓存"><a href="#SpringBoot整合Memcached缓存" class="headerlink" title="SpringBoot整合Memcached缓存"></a>SpringBoot整合Memcached缓存</h4><p>​        目前我们已经掌握了3种缓存解决方案的配置形式，分别是springboot内置缓存，ehcache和redis，本节研究一下国内比较流行的一款缓存memcached。</p><p>​        按照之前的套路，其实变更缓存并不繁琐，但是springboot并没有支持使用memcached作为其缓存解决方案，也就是说在type属性中没有memcached的配置选项，这里就需要更变一下处理方式了。在整合之前先安装memcached。</p><p><strong>安装</strong></p><p>​        windows版安装包下载地址：<a href="https://www.runoob.com/memcached/window-install-memcached.html">https://www.runoob.com/memcached/window-install-memcached.html</a></p><p>​        下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件</p><p><img src="img%5Cimage-20220226174957040.png" alt="image-20220226174957040"></p><p>​        可执行文件只有一个memcached.exe，使用该文件可以将memcached作为系统服务启动，执行此文件时会出现报错信息，如下：</p><img src="img\image-20220226175141986.png" alt="image-20220226175141986" style="zoom:80%;" /><p>​        此处出现问题的原因是注册系统服务时需要使用管理员权限，当前账号权限不足导致安装服务失败，切换管理员账号权限启动命令行</p><img src="img\image-20220226175302903.png" alt="image-20220226175302903" style="zoom:80%;" /><p>​        然后再次执行安装服务的命令即可，如下：</p><pre class=" language-CMD"><code class="language-CMD">memcached.exe -d install</code></pre><p>​        服务安装完毕后可以使用命令启动和停止服务，如下：</p><pre class=" language-cmd"><code class="language-cmd">memcached.exe -d start        # 启动服务memcached.exe -d stop        # 停止服务</code></pre><p>​        也可以在任务管理器中进行服务状态的切换</p><img src="img\image-20220226175441675.png" alt="image-20220226175441675" style="zoom:67%;" /><p><strong>变更缓存为Memcached</strong></p><p>​        由于memcached未被springboot收录为缓存解决方案，因此使用memcached需要通过手工硬编码的方式来使用，于是前面的套路都不适用了，需要自己写了。</p><p>​        memcached目前提供有三种客户端技术，分别是Memcached Client for Java、SpyMemcached和Xmemcached，其中性能指标各方面最好的客户端是Xmemcached，本次整合就使用这个作为客户端实现技术了。下面开始使用Xmemcached</p><p><strong>步骤①</strong>：导入xmemcached的坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.googlecode.xmemcached<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>xmemcached<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.4.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：配置memcached，制作memcached的配置类</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XMemcachedConfig</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> MemcachedClient <span class="token function">getMemcachedClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        MemcachedClientBuilder memcachedClientBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMemcachedClientBuilder</span><span class="token punctuation">(</span><span class="token string">"localhost:11211"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MemcachedClient memcachedClient <span class="token operator">=</span> memcachedClientBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> memcachedClient<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        memcached默认对外服务端口11211。</p><p><strong>步骤③</strong>：使用xmemcached客户端操作缓存，注入MemcachedClient对象</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SMSCodeServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SMSCodeService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> CodeUtils codeUtils<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> MemcachedClient memcachedClient<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">sendCodeToSMS</span><span class="token punctuation">(</span>String tele<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String code <span class="token operator">=</span> codeUtils<span class="token punctuation">.</span><span class="token function">generator</span><span class="token punctuation">(</span>tele<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            memcachedClient<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>tele<span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkCode</span><span class="token punctuation">(</span>SMSCode smsCode<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String code <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            code <span class="token operator">=</span> memcachedClient<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>smsCode<span class="token punctuation">.</span><span class="token function">getTele</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> smsCode<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        设置值到缓存中使用set操作，取值使用get操作，其实更符合我们开发者的习惯。</p><p>​        上述代码中对于服务器的配置使用硬编码写死到了代码中，将此数据提取出来，做成独立的配置属性。</p><p><strong>定义配置属性</strong></p><p>​        以下过程采用前期学习的属性配置方式进行，当前操作有助于理解原理篇中的很多知识。</p><ul><li><p>定义配置类，加载必要的配置属性，读取配置文件中memcached节点信息</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"memcached"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Data</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XMemcachedProperties</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> String servers<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> poolSize<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">long</span> opTimeout<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre></li><li><p>定义memcached节点信息</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">memcached</span><span class="token punctuation">:</span>  <span class="token key atrule">servers</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">11211</span>  <span class="token key atrule">poolSize</span><span class="token punctuation">:</span> <span class="token number">10</span>  <span class="token key atrule">opTimeout</span><span class="token punctuation">:</span> <span class="token number">3000</span></code></pre></li><li><p>在memcached配置类中加载信息</p></li></ul><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XMemcachedConfig</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> XMemcachedProperties props<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> MemcachedClient <span class="token function">getMemcachedClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        MemcachedClientBuilder memcachedClientBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMemcachedClientBuilder</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token function">getServers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        memcachedClientBuilder<span class="token punctuation">.</span><span class="token function">setConnectionPoolSize</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token function">getPoolSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        memcachedClientBuilder<span class="token punctuation">.</span><span class="token function">setOpTimeout</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span><span class="token function">getOpTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        MemcachedClient memcachedClient <span class="token operator">=</span> memcachedClientBuilder<span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> memcachedClient<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>总结</strong></p><ol><li>memcached安装后需要启动对应服务才可以对外提供缓存功能，安装memcached服务需要基于windows系统管理员权限</li><li>由于springboot没有提供对memcached的缓存整合方案，需要采用手工编码的形式创建xmemcached客户端操作缓存</li><li>导入xmemcached坐标后，创建memcached配置类，注册MemcachedClient对应的bean，用于操作缓存</li><li>初始化MemcachedClient对象所需要使用的属性可以通过自定义配置属性类的形式加载</li></ol><p><strong>思考</strong></p><p>​        到这里已经完成了三种缓存的整合，其中redis和mongodb需要安装独立的服务器，连接时需要输入对应的服务器地址，这种是远程缓存，Ehcache是一个典型的内存级缓存，因为它什么也不用安装，启动后导入jar包就有缓存功能了。这个时候就要问了，能不能这两种缓存一起用呢？咱们下节再说。</p><h4 id="SpringBoot整合jetcache缓存"><a href="#SpringBoot整合jetcache缓存" class="headerlink" title="SpringBoot整合jetcache缓存"></a>SpringBoot整合jetcache缓存</h4><p>​        目前我们使用的缓存都是要么A要么B，能不能AB一起用呢？这一节就解决这个问题。springboot针对缓存的整合仅仅停留在用缓存上面，如果缓存自身不支持同时支持AB一起用，springboot也没办法，所以要想解决AB缓存一起用的问题，就必须找一款缓存能够支持AB两种缓存一起用，有这种缓存吗？还真有，阿里出品，jetcache。</p><p>​        jetcache严格意义上来说，并不是一个缓存解决方案，只能说他算是一个缓存框架，然后把别的缓存放到jetcache中管理，这样就可以支持AB缓存一起用了。并且jetcache参考了springboot整合缓存的思想，整体技术使用方式和springboot的缓存解决方案思想非常类似。下面咱们就先把jetcache用起来，然后再说它里面的一些小的功能。</p><p>​        做之前要先明确一下，jetcache并不是随便拿两个缓存都能拼到一起去的。目前jetcache支持的缓存方案本地缓存支持两种，远程缓存支持两种，分别如下：</p><ul><li>本地缓存（Local）<ul><li>LinkedHashMap</li><li>Caffeine</li></ul></li><li>远程缓存（Remote）<ul><li>Redis</li><li>Tair</li></ul></li></ul><p>​        其实也有人问我，为什么jetcache只支持2+2这么4款缓存呢？阿里研发这个技术其实主要是为了满足自身的使用需要。最初肯定只有1+1种，逐步变化成2+2种。下面就以LinkedHashMap+Redis的方案实现本地与远程缓存方案同时使用。</p><h5 id="纯远程方案"><a href="#纯远程方案" class="headerlink" title="纯远程方案"></a>纯远程方案</h5><p><strong>步骤①</strong>：导入springboot整合jetcache对应的坐标starter，当前坐标默认使用的远程方案是redis</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alicp.jetcache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jetcache-starter-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：远程方案基本配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">jetcache</span><span class="token punctuation">:</span>  <span class="token key atrule">remote</span><span class="token punctuation">:</span>    <span class="token key atrule">default</span><span class="token punctuation">:</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> redis      <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>      <span class="token key atrule">poolConfig</span><span class="token punctuation">:</span>        <span class="token key atrule">maxTotal</span><span class="token punctuation">:</span> <span class="token number">50</span></code></pre><p>​        其中poolConfig是必配项，否则会报错</p><p><strong>步骤③</strong>：启用缓存，在引导类上方标注注解@EnableCreateCacheAnnotation配置springboot程序中可以使用注解的形式创建缓存</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token comment" spellcheck="true">//jetcache启用缓存的主开关</span><span class="token annotation punctuation">@EnableCreateCacheAnnotation</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot20JetCacheApplication</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Springboot20JetCacheApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤④</strong>：创建缓存对象Cache，并使用注解@CreateCache标记当前缓存的信息，然后使用Cache对象的API操作缓存，put写缓存，get读缓存。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SMSCodeServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SMSCodeService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> CodeUtils codeUtils<span class="token punctuation">;</span>        <span class="token annotation punctuation">@CreateCache</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"jetCache_"</span><span class="token punctuation">,</span>expire <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span>timeUnit <span class="token operator">=</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">)</span>    <span class="token keyword">private</span> Cache<span class="token operator">&lt;</span>String <span class="token punctuation">,</span>String<span class="token operator">></span> jetCache<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">sendCodeToSMS</span><span class="token punctuation">(</span>String tele<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String code <span class="token operator">=</span> codeUtils<span class="token punctuation">.</span><span class="token function">generator</span><span class="token punctuation">(</span>tele<span class="token punctuation">)</span><span class="token punctuation">;</span>        jetCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>tele<span class="token punctuation">,</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkCode</span><span class="token punctuation">(</span>SMSCode smsCode<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String code <span class="token operator">=</span> jetCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>smsCode<span class="token punctuation">.</span><span class="token function">getTele</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> smsCode<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        通过上述jetcache使用远程方案连接redis可以看出，jetcache操作缓存时的接口操作更符合开发者习惯，使用缓存就先获取缓存对象Cache，放数据进去就是put，取数据出来就是get，更加简单易懂。并且jetcache操作缓存时，可以为某个缓存对象设置过期时间，将同类型的数据放入缓存中，方便有效周期的管理。</p><p>​        上述方案中使用的是配置中定义的default缓存，其实这个default是个名字，可以随便写，也可以随便加。例如再添加一种缓存解决方案，参照如下配置进行：</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">jetcache</span><span class="token punctuation">:</span>  <span class="token key atrule">remote</span><span class="token punctuation">:</span>    <span class="token key atrule">default</span><span class="token punctuation">:</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> redis      <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>      <span class="token key atrule">poolConfig</span><span class="token punctuation">:</span>        <span class="token key atrule">maxTotal</span><span class="token punctuation">:</span> <span class="token number">50</span>    <span class="token key atrule">sms</span><span class="token punctuation">:</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> redis      <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>      <span class="token key atrule">poolConfig</span><span class="token punctuation">:</span>        <span class="token key atrule">maxTotal</span><span class="token punctuation">:</span> <span class="token number">50</span></code></pre><p>​        如果想使用名称是sms的缓存，需要再创建缓存时指定参数area，声明使用对应缓存即可</p><pre class=" language-JAVA"><code class="language-JAVA">@Servicepublic class SMSCodeServiceImpl implements SMSCodeService &#123;    @Autowired    private CodeUtils codeUtils;        @CreateCache(area="sms",name="jetCache_",expire = 10,timeUnit = TimeUnit.SECONDS)    private Cache<String ,String> jetCache;    public String sendCodeToSMS(String tele) &#123;        String code = codeUtils.generator(tele);        jetCache.put(tele,code);        return code;    &#125;    public boolean checkCode(SMSCode smsCode) &#123;        String code = jetCache.get(smsCode.getTele());        return smsCode.getCode().equals(code);    &#125;&#125;</code></pre><h5 id="纯本地方案"><a href="#纯本地方案" class="headerlink" title="纯本地方案"></a>纯本地方案</h5><p>​        远程方案中，配置中使用remote表示远程，换成local就是本地，只不过类型不一样而已。</p><p><strong>步骤①</strong>：导入springboot整合jetcache对应的坐标starter</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alicp.jetcache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jetcache-starter-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：本地缓存基本配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">jetcache</span><span class="token punctuation">:</span>  <span class="token key atrule">local</span><span class="token punctuation">:</span>    <span class="token key atrule">default</span><span class="token punctuation">:</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> linkedhashmap      <span class="token key atrule">keyConvertor</span><span class="token punctuation">:</span> fastjson</code></pre><p>​        为了加速数据获取时key的匹配速度，jetcache要求指定key的类型转换器。简单说就是，如果你给了一个Object作为key的话，我先用key的类型转换器给转换成字符串，然后再保存。等到获取数据时，仍然是先使用给定的Object转换成字符串，然后根据字符串匹配。由于jetcache是阿里的技术，这里推荐key的类型转换器使用阿里的fastjson。</p><p><strong>步骤③</strong>：启用缓存</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token comment" spellcheck="true">//jetcache启用缓存的主开关</span><span class="token annotation punctuation">@EnableCreateCacheAnnotation</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot20JetCacheApplication</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Springboot20JetCacheApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤④</strong>：创建缓存对象Cache时，标注当前使用本地缓存</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SMSCodeServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SMSCodeService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@CreateCache</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"jetCache_"</span><span class="token punctuation">,</span>expire <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">,</span>timeUnit <span class="token operator">=</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>cacheType <span class="token operator">=</span> CacheType<span class="token punctuation">.</span>LOCAL<span class="token punctuation">)</span>    <span class="token keyword">private</span> Cache<span class="token operator">&lt;</span>String <span class="token punctuation">,</span>String<span class="token operator">></span> jetCache<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">sendCodeToSMS</span><span class="token punctuation">(</span>String tele<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String code <span class="token operator">=</span> codeUtils<span class="token punctuation">.</span><span class="token function">generator</span><span class="token punctuation">(</span>tele<span class="token punctuation">)</span><span class="token punctuation">;</span>        jetCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>tele<span class="token punctuation">,</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkCode</span><span class="token punctuation">(</span>SMSCode smsCode<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String code <span class="token operator">=</span> jetCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>smsCode<span class="token punctuation">.</span><span class="token function">getTele</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> smsCode<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        cacheType控制当前缓存使用本地缓存还是远程缓存，配置cacheType=CacheType.LOCAL即使用本地缓存。</p><h5 id="本地-远程方案"><a href="#本地-远程方案" class="headerlink" title="本地+远程方案"></a>本地+远程方案</h5><p>​        本地和远程方法都有了，两种方案一起使用如何配置呢？其实就是将两种配置合并到一起就可以了。</p><pre class=" language-YAML"><code class="language-YAML">jetcache:  local:    default:      type: linkedhashmap      keyConvertor: fastjson  remote:    default:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50    sms:      type: redis      host: localhost      port: 6379      poolConfig:        maxTotal: 50</code></pre><p>​        在创建缓存的时候，配置cacheType为BOTH即则本地缓存与远程缓存同时使用。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SMSCodeServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SMSCodeService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@CreateCache</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"jetCache_"</span><span class="token punctuation">,</span>expire <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">,</span>timeUnit <span class="token operator">=</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">,</span>cacheType <span class="token operator">=</span> CacheType<span class="token punctuation">.</span>BOTH<span class="token punctuation">)</span>    <span class="token keyword">private</span> Cache<span class="token operator">&lt;</span>String <span class="token punctuation">,</span>String<span class="token operator">></span> jetCache<span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        cacheType如果不进行配置，默认值是REMOTE，即仅使用远程缓存方案。关于jetcache的配置，参考以下信息</p><table><thead><tr><th>属性</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>jetcache.statIntervalMinutes</td><td>0</td><td>统计间隔，0表示不统计</td></tr><tr><td>jetcache.hiddenPackages</td><td>无</td><td>自动生成name时，隐藏指定的包名前缀</td></tr><tr><td>jetcache.[local|remote].${area}.type</td><td>无</td><td>缓存类型，本地支持linkedhashmap、caffeine，远程支持redis、tair</td></tr><tr><td>jetcache.[local|remote].${area}.keyConvertor</td><td>无</td><td>key转换器，当前仅支持fastjson</td></tr><tr><td>jetcache.[local|remote].${area}.valueEncoder</td><td>java</td><td>仅remote类型的缓存需要指定，可选java和kryo</td></tr><tr><td>jetcache.[local|remote].${area}.valueDecoder</td><td>java</td><td>仅remote类型的缓存需要指定，可选java和kryo</td></tr><tr><td>jetcache.[local|remote].${area}.limit</td><td>100</td><td>仅local类型的缓存需要指定，缓存实例最大元素数</td></tr><tr><td>jetcache.[local|remote].${area}.expireAfterWriteInMillis</td><td>无穷大</td><td>默认过期时间，毫秒单位</td></tr><tr><td>jetcache.local.${area}.expireAfterAccessInMillis</td><td>0</td><td>仅local类型的缓存有效，毫秒单位，最大不活动间隔</td></tr></tbody></table><p>​        以上方案仅支持手工控制缓存，但是springcache方案中的方法缓存特别好用，给一个方法添加一个注解，方法就会自动使用缓存。jetcache也提供了对应的功能，即方法缓存。</p><p><strong>方法缓存</strong></p><p>​        jetcache提供了方法缓存方案，只不过名称变更了而已。在对应的操作接口上方使用注解@Cached即可</p><p><strong>步骤①</strong>：导入springboot整合jetcache对应的坐标starter</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>com.alicp.jetcache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>jetcache-starter-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.6.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：配置缓存</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">jetcache</span><span class="token punctuation">:</span>  <span class="token key atrule">local</span><span class="token punctuation">:</span>    <span class="token key atrule">default</span><span class="token punctuation">:</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> linkedhashmap      <span class="token key atrule">keyConvertor</span><span class="token punctuation">:</span> fastjson  <span class="token key atrule">remote</span><span class="token punctuation">:</span>    <span class="token key atrule">default</span><span class="token punctuation">:</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> redis      <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>      <span class="token key atrule">keyConvertor</span><span class="token punctuation">:</span> fastjson      <span class="token key atrule">valueEncode</span><span class="token punctuation">:</span> java      <span class="token key atrule">valueDecode</span><span class="token punctuation">:</span> java      <span class="token key atrule">poolConfig</span><span class="token punctuation">:</span>        <span class="token key atrule">maxTotal</span><span class="token punctuation">:</span> <span class="token number">50</span>    <span class="token key atrule">sms</span><span class="token punctuation">:</span>      <span class="token key atrule">type</span><span class="token punctuation">:</span> redis      <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost      <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>      <span class="token key atrule">poolConfig</span><span class="token punctuation">:</span>        <span class="token key atrule">maxTotal</span><span class="token punctuation">:</span> <span class="token number">50</span></code></pre><p>​        由于redis缓存中不支持保存对象，因此需要对redis设置当Object类型数据进入到redis中时如何进行类型转换。需要配置keyConvertor表示key的类型转换方式，同时标注value的转换类型方式，值进入redis时是java类型，标注valueEncode为java，值从redis中读取时转换成java，标注valueDecode为java。</p><p>​        注意，为了实现Object类型的值进出redis，需要保障进出redis的Object类型的数据必须实现序列化接口。</p><pre class=" language-JAVA"><code class="language-JAVA">@Datapublic class Book implements Serializable &#123;    private Integer id;    private String type;    private String name;    private String description;&#125;</code></pre><p><strong>步骤③</strong>：启用缓存时开启方法缓存功能，并配置basePackages，说明在哪些包中开启方法缓存</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token comment" spellcheck="true">//jetcache启用缓存的主开关</span><span class="token annotation punctuation">@EnableCreateCacheAnnotation</span><span class="token comment" spellcheck="true">//开启方法注解缓存</span><span class="token annotation punctuation">@EnableMethodCache</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"com.itheima"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot20JetCacheApplication</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Springboot20JetCacheApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤④</strong>：使用注解@Cached标注当前方法使用缓存</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> BookDao bookDao<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Cached</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"book_"</span><span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token string">"#id"</span><span class="token punctuation">,</span>expire <span class="token operator">=</span> <span class="token number">3600</span><span class="token punctuation">,</span>cacheType <span class="token operator">=</span> CacheType<span class="token punctuation">.</span>REMOTE<span class="token punctuation">)</span>    <span class="token keyword">public</span> Book <span class="token function">getById</span><span class="token punctuation">(</span>Integer id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> bookDao<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><h5 id="远程方案的数据同步"><a href="#远程方案的数据同步" class="headerlink" title="远程方案的数据同步"></a>远程方案的数据同步</h5><p>​        由于远程方案中redis保存的数据可以被多个客户端共享，这就存在了数据同步问题。jetcache提供了3个注解解决此问题，分别在更新、删除操作时同步缓存数据，和读取缓存时定时刷新数据</p><p><strong>更新缓存</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@CacheUpdate(name="book_",key="#book.id",value="#book")public boolean update(Book book) &#123;    return bookDao.updateById(book) > 0;&#125;</code></pre><p><strong>删除缓存</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@CacheInvalidate(name="book_",key = "#id")public boolean delete(Integer id) &#123;    return bookDao.deleteById(id) > 0;&#125;</code></pre><p><strong>定时刷新缓存</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@Cached(name="book_",key="#id",expire = 3600,cacheType = CacheType.REMOTE)@CacheRefresh(refresh = 5)public Book getById(Integer id) &#123;    return bookDao.selectById(id);&#125;</code></pre><h5 id="数据报表"><a href="#数据报表" class="headerlink" title="数据报表"></a>数据报表</h5><p>​        jetcache还提供有简单的数据报表功能，帮助开发者快速查看缓存命中信息，只需要添加一个配置即可</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">jetcache</span><span class="token punctuation">:</span>  <span class="token key atrule">statIntervalMinutes</span><span class="token punctuation">:</span> <span class="token number">1</span></code></pre><p>​        设置后，每1分钟在控制台输出缓存数据命中信息</p><pre class=" language-CMD"><code class="language-CMD">[DefaultExecutor] c.alicp.jetcache.support.StatInfoLogger  : jetcache stat from 2022-02-28 09:32:15,892 to 2022-02-28 09:33:00,003cache    |    qps|   rate|   get|    hit|   fail|   expire|   avgLoadTime|   maxLoadTime---------+-------+-------+------+-------+-------+---------+--------------+--------------book_    |   0.66| 75.86%|    29|     22|      0|        0|          28.0|           188---------+-------+-------+------+-------+-------+---------+--------------+--------------</code></pre><p><strong>总结</strong></p><ol><li>jetcache是一个类似于springcache的缓存解决方案，自身不具有缓存功能，它提供有本地缓存与远程缓存多级共同使用的缓存解决方案</li><li>jetcache提供的缓存解决方案受限于目前支持的方案，本地缓存支持两种，远程缓存支持两种</li><li>注意数据进入远程缓存时的类型转换问题</li><li>jetcache提供方法缓存，并提供了对应的缓存更新与刷新功能</li><li>jetcache提供有简单的缓存信息命中报表方便开发者即时监控缓存数据命中情况</li></ol><p><strong>思考</strong></p><p>​        jetcache解决了前期使用缓存方案单一的问题，但是仍然不能灵活的选择缓存进行搭配使用，是否存在一种技术可以灵活的搭配各种各样的缓存使用呢？有，咱们下一节再讲。</p><h4 id="SpringBoot整合j2cache缓存"><a href="#SpringBoot整合j2cache缓存" class="headerlink" title="SpringBoot整合j2cache缓存"></a>SpringBoot整合j2cache缓存</h4><p>​        jetcache可以在限定范围内构建多级缓存，但是灵活性不足，不能随意搭配缓存，本节介绍一种可以随意搭配缓存解决方案的缓存整合框架，j2cache。下面就来讲解如何使用这种缓存框架，以Ehcache与redis整合为例：</p><p><strong>步骤①</strong>：导入j2cache、redis、ehcache坐标</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>net.oschina.j2cache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>j2cache-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.4-release<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>net.oschina.j2cache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>j2cache-spring-boot2-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.8.0-release<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>net.sf.ehcache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>ehcache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>​        j2cache的starter中默认包含了redis坐标，官方推荐使用redis作为二级缓存，因此此处无需导入redis坐标</p><p><strong>步骤②</strong>：配置一级与二级缓存，并配置一二级缓存间数据传递方式，配置书写在名称为j2cache.properties的文件中。如果使用ehcache还需要单独添加ehcache的配置文件</p><pre class=" language-yaml"><code class="language-yaml"><span class="token comment" spellcheck="true"># 1级缓存</span>j2cache.L1.provider_class = ehcacheehcache.configXml = ehcache.xml<span class="token comment" spellcheck="true"># 2级缓存</span>j2cache.L2.provider_class = net.oschina.j2cache.cache.support.redis.SpringRedisProviderj2cache.L2.config_section = redisredis.hosts = localhost<span class="token punctuation">:</span><span class="token number">6379</span><span class="token comment" spellcheck="true"># 1级缓存中的数据如何到达二级缓存</span>j2cache.broadcast = net.oschina.j2cache.cache.support.redis.SpringRedisPubSubPolicy</code></pre><p>​        此处配置不能乱配置，需要参照官方给出的配置说明进行。例如1级供应商选择ehcache，供应商名称仅仅是一个ehcache，但是2级供应商选择redis时要写专用的Spring整合Redis的供应商类名SpringRedisProvider，而且这个名称并不是所有的redis包中能提供的，也不是spring包中提供的。因此配置j2cache必须参照官方文档配置，而且还要去找专用的整合包，导入对应坐标才可以使用。</p><p>​        一级与二级缓存最重要的一个配置就是两者之间的数据沟通方式，此类配置也不是随意配置的，并且不同的缓存解决方案提供的数据沟通方式差异化很大，需要查询官方文档进行设置。</p><p><strong>步骤③</strong>：使用缓存</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SMSCodeServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SMSCodeService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> CodeUtils codeUtils<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> CacheChannel cacheChannel<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">sendCodeToSMS</span><span class="token punctuation">(</span>String tele<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String code <span class="token operator">=</span> codeUtils<span class="token punctuation">.</span><span class="token function">generator</span><span class="token punctuation">(</span>tele<span class="token punctuation">)</span><span class="token punctuation">;</span>        cacheChannel<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"sms"</span><span class="token punctuation">,</span>tele<span class="token punctuation">,</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> code<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkCode</span><span class="token punctuation">(</span>SMSCode smsCode<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String code <span class="token operator">=</span> cacheChannel<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"sms"</span><span class="token punctuation">,</span>smsCode<span class="token punctuation">.</span><span class="token function">getTele</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">asString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> smsCode<span class="token punctuation">.</span><span class="token function">getCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        j2cache的使用和jetcache比较类似，但是无需开启使用的开关，直接定义缓存对象即可使用，缓存对象名CacheChannel。</p><p>​        j2cache的使用不复杂，配置是j2cache的核心，毕竟是一个整合型的缓存框架。缓存相关的配置过多，可以查阅j2cache-core核心包中的j2cache.properties文件中的说明。如下：</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#J2Cache configuration</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true"># Cache Broadcast Method</span><span class="token comment" spellcheck="true"># values:</span><span class="token comment" spellcheck="true"># jgroups -> use jgroups's multicast</span><span class="token comment" spellcheck="true"># redis -> use redis publish/subscribe mechanism (using jedis)</span><span class="token comment" spellcheck="true"># lettuce -> use redis publish/subscribe mechanism (using lettuce, Recommend)</span><span class="token comment" spellcheck="true"># rabbitmq -> use RabbitMQ publisher/consumer mechanism</span><span class="token comment" spellcheck="true"># rocketmq -> use RocketMQ publisher/consumer mechanism</span><span class="token comment" spellcheck="true"># none -> don't notify the other nodes in cluster</span><span class="token comment" spellcheck="true"># xx.xxxx.xxxx.Xxxxx your own cache broadcast policy classname that implement net.oschina.j2cache.cluster.ClusterPolicy</span><span class="token comment" spellcheck="true">#########################################</span><span class="token attr-name">j2cache.broadcast</span> <span class="token punctuation">=</span> <span class="token attr-value">redis</span><span class="token comment" spellcheck="true"># jgroups properties</span><span class="token attr-name">jgroups.channel.name</span> <span class="token punctuation">=</span> <span class="token attr-value">j2cache</span><span class="token attr-name">jgroups.configXml</span> <span class="token punctuation">=</span> <span class="token attr-value">/network.xml</span><span class="token comment" spellcheck="true"># RabbitMQ properties</span><span class="token attr-name">rabbitmq.exchange</span> <span class="token punctuation">=</span> <span class="token attr-value">j2cache</span><span class="token attr-name">rabbitmq.host</span> <span class="token punctuation">=</span> <span class="token attr-value">localhost</span><span class="token attr-name">rabbitmq.port</span> <span class="token punctuation">=</span> <span class="token attr-value">5672</span><span class="token attr-name">rabbitmq.username</span> <span class="token punctuation">=</span> <span class="token attr-value">guest</span><span class="token attr-name">rabbitmq.password</span> <span class="token punctuation">=</span> <span class="token attr-value">guest</span><span class="token comment" spellcheck="true"># RocketMQ properties</span><span class="token attr-name">rocketmq.name</span> <span class="token punctuation">=</span> <span class="token attr-value">j2cache</span><span class="token attr-name">rocketmq.topic</span> <span class="token punctuation">=</span> <span class="token attr-value">j2cache</span><span class="token comment" spellcheck="true"># use ; to split multi hosts</span><span class="token attr-name">rocketmq.hosts</span> <span class="token punctuation">=</span> <span class="token attr-value">127.0.0.1:9876</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true"># Level 1&amp;2 provider</span><span class="token comment" spellcheck="true"># values:</span><span class="token comment" spellcheck="true"># none -> disable this level cache</span><span class="token comment" spellcheck="true"># ehcache -> use ehcache2 as level 1 cache</span><span class="token comment" spellcheck="true"># ehcache3 -> use ehcache3 as level 1 cache</span><span class="token comment" spellcheck="true"># caffeine -> use caffeine as level 1 cache(only in memory)</span><span class="token comment" spellcheck="true"># redis -> use redis as level 2 cache (using jedis)</span><span class="token comment" spellcheck="true"># lettuce -> use redis as level 2 cache (using lettuce)</span><span class="token comment" spellcheck="true"># readonly-redis -> use redis as level 2 cache ,but never write data to it. if use this provider, you must uncomment `j2cache.L2.config_section` to make the redis configurations available.</span><span class="token comment" spellcheck="true"># memcached -> use memcached as level 2 cache (xmemcached),</span><span class="token comment" spellcheck="true"># [classname] -> use custom provider</span><span class="token comment" spellcheck="true">#########################################</span><span class="token attr-name">j2cache.L1.provider_class</span> <span class="token punctuation">=</span> <span class="token attr-value">caffeine</span><span class="token attr-name">j2cache.L2.provider_class</span> <span class="token punctuation">=</span> <span class="token attr-value">redis</span><span class="token comment" spellcheck="true"># When L2 provider isn't `redis`, using `L2.config_section = redis` to read redis configurations</span><span class="token comment" spellcheck="true"># j2cache.L2.config_section = redis</span><span class="token comment" spellcheck="true"># Enable/Disable ttl in redis cache data (if disabled, the object in redis will never expire, default:true)</span><span class="token comment" spellcheck="true"># NOTICE: redis hash mode (redis.storage = hash) do not support this feature)</span><span class="token attr-name">j2cache.sync_ttl_to_redis</span> <span class="token punctuation">=</span> <span class="token attr-value">true</span><span class="token comment" spellcheck="true"># Whether to cache null objects by default (default false)</span><span class="token attr-name">j2cache.default_cache_null_object</span> <span class="token punctuation">=</span> <span class="token attr-value">true</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true"># Cache Serialization Provider</span><span class="token comment" spellcheck="true"># values:</span><span class="token comment" spellcheck="true"># fst -> using fast-serialization (recommend)</span><span class="token comment" spellcheck="true"># kryo -> using kryo serialization</span><span class="token comment" spellcheck="true"># json -> using fst's json serialization (testing)</span><span class="token comment" spellcheck="true"># fastjson -> using fastjson serialization (embed non-static class not support)</span><span class="token comment" spellcheck="true"># java -> java standard</span><span class="token comment" spellcheck="true"># fse -> using fse serialization</span><span class="token comment" spellcheck="true"># [classname implements Serializer]</span><span class="token comment" spellcheck="true">#########################################</span><span class="token attr-name">j2cache.serialization</span> <span class="token punctuation">=</span> <span class="token attr-value">json</span><span class="token comment" spellcheck="true">#json.map.person = net.oschina.j2cache.demo.Person</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true"># Ehcache configuration</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true"># ehcache.configXml = /ehcache.xml</span><span class="token comment" spellcheck="true"># ehcache3.configXml = /ehcache3.xml</span><span class="token comment" spellcheck="true"># ehcache3.defaultHeapSize = 1000</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true"># Caffeine configuration</span><span class="token comment" spellcheck="true"># caffeine.region.[name] = size, xxxx[s|m|h|d]</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#########################################</span><span class="token attr-name">caffeine.properties</span> <span class="token punctuation">=</span> <span class="token attr-value">/caffeine.properties</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true"># Redis connection configuration</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true"># Redis Cluster Mode</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># single -> single redis server</span><span class="token comment" spellcheck="true"># sentinel -> master-slaves servers</span><span class="token comment" spellcheck="true"># cluster -> cluster servers (数据库配置无效，使用 database = 0）</span><span class="token comment" spellcheck="true"># sharded -> sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#########################################</span><span class="token attr-name">redis.mode</span> <span class="token punctuation">=</span> <span class="token attr-value">single</span><span class="token comment" spellcheck="true">#redis storage mode (generic|hash)</span><span class="token attr-name">redis.storage</span> <span class="token punctuation">=</span> <span class="token attr-value">generic</span><span class="token comment" spellcheck="true">## redis pub/sub channel name</span><span class="token attr-name">redis.channel</span> <span class="token punctuation">=</span> <span class="token attr-value">j2cache</span><span class="token comment" spellcheck="true">## redis pub/sub server (using redis.hosts when empty)</span><span class="token attr-name">redis.channel.host</span> <span class="token attr-value">=</span><span class="token comment" spellcheck="true">#cluster name just for sharded</span><span class="token attr-name">redis.cluster_name</span> <span class="token punctuation">=</span> <span class="token attr-value">j2cache</span><span class="token comment" spellcheck="true">## redis cache namespace optional, default[empty]</span><span class="token attr-name">redis.namespace</span> <span class="token attr-value">=</span><span class="token comment" spellcheck="true">## redis command scan parameter count, default[1000]</span><span class="token comment" spellcheck="true">#redis.scanCount = 1000</span><span class="token comment" spellcheck="true">## connection</span><span class="token comment" spellcheck="true"># Separate multiple redis nodes with commas, such as 192.168.0.10:6379,192.168.0.11:6379,192.168.0.12:6379</span><span class="token attr-name">redis.hosts</span> <span class="token punctuation">=</span> <span class="token attr-value">127.0.0.1:6379</span><span class="token attr-name">redis.timeout</span> <span class="token punctuation">=</span> <span class="token attr-value">2000</span><span class="token attr-name">redis.password</span> <span class="token attr-value">=</span><span class="token attr-name">redis.database</span> <span class="token punctuation">=</span> <span class="token attr-value">0</span><span class="token attr-name">redis.ssl</span> <span class="token punctuation">=</span> <span class="token attr-value">false</span><span class="token comment" spellcheck="true">## redis pool properties</span><span class="token attr-name">redis.maxTotal</span> <span class="token punctuation">=</span> <span class="token attr-value">100</span><span class="token attr-name">redis.maxIdle</span> <span class="token punctuation">=</span> <span class="token attr-value">10</span><span class="token attr-name">redis.maxWaitMillis</span> <span class="token punctuation">=</span> <span class="token attr-value">5000</span><span class="token attr-name">redis.minEvictableIdleTimeMillis</span> <span class="token punctuation">=</span> <span class="token attr-value">60000</span><span class="token attr-name">redis.minIdle</span> <span class="token punctuation">=</span> <span class="token attr-value">1</span><span class="token attr-name">redis.numTestsPerEvictionRun</span> <span class="token punctuation">=</span> <span class="token attr-value">10</span><span class="token attr-name">redis.lifo</span> <span class="token punctuation">=</span> <span class="token attr-value">false</span><span class="token attr-name">redis.softMinEvictableIdleTimeMillis</span> <span class="token punctuation">=</span> <span class="token attr-value">10</span><span class="token attr-name">redis.testOnBorrow</span> <span class="token punctuation">=</span> <span class="token attr-value">true</span><span class="token attr-name">redis.testOnReturn</span> <span class="token punctuation">=</span> <span class="token attr-value">false</span><span class="token attr-name">redis.testWhileIdle</span> <span class="token punctuation">=</span> <span class="token attr-value">true</span><span class="token attr-name">redis.timeBetweenEvictionRunsMillis</span> <span class="token punctuation">=</span> <span class="token attr-value">300000</span><span class="token attr-name">redis.blockWhenExhausted</span> <span class="token punctuation">=</span> <span class="token attr-value">false</span><span class="token attr-name">redis.jmxEnabled</span> <span class="token punctuation">=</span> <span class="token attr-value">false</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true"># Lettuce scheme</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># redis -> single redis server</span><span class="token comment" spellcheck="true"># rediss -> single redis server with ssl</span><span class="token comment" spellcheck="true"># redis-sentinel -> redis sentinel</span><span class="token comment" spellcheck="true"># redis-cluster -> cluster servers</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true"># Lettuce Mode</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># single -> single redis server</span><span class="token comment" spellcheck="true"># sentinel -> master-slaves servers</span><span class="token comment" spellcheck="true"># cluster -> cluster servers (数据库配置无效，使用 database = 0）</span><span class="token comment" spellcheck="true"># sharded -> sharded servers  (密码、数据库必须在 hosts 中指定，且连接池配置无效 ; redis://user:password@127.0.0.1:6379/0）</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true">## redis command scan parameter count, default[1000]</span><span class="token comment" spellcheck="true">#lettuce.scanCount = 1000</span><span class="token attr-name">lettuce.mode</span> <span class="token punctuation">=</span> <span class="token attr-value">single</span><span class="token attr-name">lettuce.namespace</span> <span class="token attr-value">=</span><span class="token attr-name">lettuce.storage</span> <span class="token punctuation">=</span> <span class="token attr-value">hash</span><span class="token attr-name">lettuce.channel</span> <span class="token punctuation">=</span> <span class="token attr-value">j2cache</span><span class="token attr-name">lettuce.scheme</span> <span class="token punctuation">=</span> <span class="token attr-value">redis</span><span class="token attr-name">lettuce.hosts</span> <span class="token punctuation">=</span> <span class="token attr-value">127.0.0.1:6379</span><span class="token attr-name">lettuce.password</span> <span class="token attr-value">=</span><span class="token attr-name">lettuce.database</span> <span class="token punctuation">=</span> <span class="token attr-value">0</span><span class="token attr-name">lettuce.sentinelMasterId</span> <span class="token attr-value">=</span><span class="token attr-name">lettuce.maxTotal</span> <span class="token punctuation">=</span> <span class="token attr-value">100</span><span class="token attr-name">lettuce.maxIdle</span> <span class="token punctuation">=</span> <span class="token attr-value">10</span><span class="token attr-name">lettuce.minIdle</span> <span class="token punctuation">=</span> <span class="token attr-value">10</span><span class="token comment" spellcheck="true"># timeout in milliseconds</span><span class="token attr-name">lettuce.timeout</span> <span class="token punctuation">=</span> <span class="token attr-value">10000</span><span class="token comment" spellcheck="true"># redis cluster topology refresh interval in milliseconds</span><span class="token attr-name">lettuce.clusterTopologyRefresh</span> <span class="token punctuation">=</span> <span class="token attr-value">3000</span><span class="token comment" spellcheck="true">#########################################</span><span class="token comment" spellcheck="true"># memcached server configurations</span><span class="token comment" spellcheck="true"># refer to https://gitee.com/mirrors/XMemcached</span><span class="token comment" spellcheck="true">#########################################</span><span class="token attr-name">memcached.servers</span> <span class="token punctuation">=</span> <span class="token attr-value">127.0.0.1:11211</span><span class="token attr-name">memcached.username</span> <span class="token attr-value">=</span><span class="token attr-name">memcached.password</span> <span class="token attr-value">=</span><span class="token attr-name">memcached.connectionPoolSize</span> <span class="token punctuation">=</span> <span class="token attr-value">10</span><span class="token attr-name">memcached.connectTimeout</span> <span class="token punctuation">=</span> <span class="token attr-value">1000</span><span class="token attr-name">memcached.failureMode</span> <span class="token punctuation">=</span> <span class="token attr-value">false</span><span class="token attr-name">memcached.healSessionInterval</span> <span class="token punctuation">=</span> <span class="token attr-value">1000</span><span class="token attr-name">memcached.maxQueuedNoReplyOperations</span> <span class="token punctuation">=</span> <span class="token attr-value">100</span><span class="token attr-name">memcached.opTimeout</span> <span class="token punctuation">=</span> <span class="token attr-value">100</span><span class="token attr-name">memcached.sanitizeKeys</span> <span class="token punctuation">=</span> <span class="token attr-value">false</span></code></pre><p><strong>总结</strong></p><ol><li>j2cache是一个缓存框架，自身不具有缓存功能，它提供多种缓存整合在一起使用的方案</li><li>j2cache需要通过复杂的配置设置各级缓存，以及缓存之间数据交换的方式</li><li>j2cache操作接口通过CacheChannel实现</li></ol><h3 id="KF-5-2-任务"><a href="#KF-5-2-任务" class="headerlink" title="KF-5-2.任务"></a>KF-5-2.任务</h3><p>​        springboot整合第三方技术第二部分我们来说说任务系统，其实这里说的任务系统指的是定时任务。定时任务是企业级开发中必不可少的组成部分，诸如长周期业务数据的计算，例如年度报表，诸如系统脏数据的处理，再比如系统性能监控报告，还有抢购类活动的商品上架，这些都离不开定时任务。本节将介绍两种不同的定时任务技术。</p><h4 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h4><p>​        Quartz技术是一个比较成熟的定时任务框架，怎么说呢？有点繁琐，用过的都知道，配置略微复杂。springboot对其进行整合后，简化了一系列的配置，将很多配置采用默认设置，这样开发阶段就简化了很多。再学习springboot整合Quartz前先普及几个Quartz的概念。</p><ul><li>工作（Job）：用于定义具体执行的工作</li><li>工作明细（JobDetail）：用于描述定时工作相关的信息</li><li>触发器（Trigger）：描述了工作明细与调度器的对应关系</li><li>调度器（Scheduler）：用于描述触发工作的执行规则，通常使用cron表达式定义规则</li></ul><p>​        简单说就是你定时干什么事情，这就是工作，工作不可能就是一个简单的方法，还要设置一些明细信息。工作啥时候执行，设置一个调度器，可以简单理解成设置一个工作执行的时间。工作和调度都是独立定义的，它们两个怎么配合到一起呢？用触发器。完了，就这么多。下面开始springboot整合Quartz。</p><p><strong>步骤①</strong>：导入springboot整合Quartz的starter</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-quartz<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：定义任务Bean，按照Quartz的开发规范制作，继承QuartzJobBean</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyQuartz</span> <span class="token keyword">extends</span> <span class="token class-name">QuartzJobBean</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">executeInternal</span><span class="token punctuation">(</span>JobExecutionContext context<span class="token punctuation">)</span> <span class="token keyword">throws</span> JobExecutionException <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"quartz task run..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤③</strong>：创建Quartz配置类，定义工作明细（JobDetail）与触发器的（Trigger）bean</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuartzConfig</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> JobDetail <span class="token function">printJobDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//绑定具体的工作</span>        <span class="token keyword">return</span> JobBuilder<span class="token punctuation">.</span><span class="token function">newJob</span><span class="token punctuation">(</span>MyQuartz<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">storeDurably</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> Trigger <span class="token function">printJobTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        ScheduleBuilder schedBuilder <span class="token operator">=</span> CronScheduleBuilder<span class="token punctuation">.</span><span class="token function">cronSchedule</span><span class="token punctuation">(</span><span class="token string">"0/5 * * * * ?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//绑定对应的工作明细</span>        <span class="token keyword">return</span> TriggerBuilder<span class="token punctuation">.</span><span class="token function">newTrigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forJob</span><span class="token punctuation">(</span><span class="token function">printJobDetail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">withSchedule</span><span class="token punctuation">(</span>schedBuilder<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        工作明细中要设置对应的具体工作，使用newJob()操作传入对应的工作任务类型即可。</p><p>​        触发器需要绑定任务，使用forJob()操作传入绑定的工作明细对象。此处可以为工作明细设置名称然后使用名称绑定，也可以直接调用对应方法绑定。触发器中最核心的规则是执行时间，此处使用调度器定义执行时间，执行时间描述方式使用的是cron表达式。有关cron表达式的规则，各位小伙伴可以去参看相关课程学习，略微复杂，而且格式不能乱设置，不是写个格式就能用的，写不好就会出现冲突问题。</p><p><strong>总结</strong></p><ol><li>springboot整合Quartz就是将Quartz对应的核心对象交给spring容器管理，包含两个对象，JobDetail和Trigger对象</li><li>JobDetail对象描述的是工作的执行信息，需要绑定一个QuartzJobBean类型的对象</li><li>Trigger对象定义了一个触发器，需要为其指定绑定的JobDetail是哪个，同时要设置执行周期调度器</li></ol><p><strong>思考</strong></p><p>​        上面的操作看上去不多，但是Quartz将其中的对象划分粒度过细，导致开发的时候有点繁琐，spring针对上述规则进行了简化，开发了自己的任务管理组件——Task，如何用呢？咱们下节再说。</p><h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>​        spring根据定时任务的特征，将定时任务的开发简化到了极致。怎么说呢？要做定时任务总要告诉容器有这功能吧，然后定时执行什么任务直接告诉对应的bean什么时间执行就行了，就这么简单，一起来看怎么做</p><p><strong>步骤①</strong>：开启定时任务功能，在引导类上开启定时任务功能的开关，使用注解@EnableScheduling</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token comment" spellcheck="true">//开启定时任务功能</span><span class="token annotation punctuation">@EnableScheduling</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot22TaskApplication</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Springboot22TaskApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p><strong>步骤②</strong>：定义Bean，在对应要定时执行的操作上方，使用注解@Scheduled定义执行的时间，执行时间的描述方式还是cron表达式</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBean</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>cron <span class="token operator">=</span> <span class="token string">"0/1 * * * * ?"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" :spring task run..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        完事，这就完成了定时任务的配置。总体感觉其实什么东西都没少，只不过没有将所有的信息都抽取成bean，而是直接使用注解绑定定时执行任务的事情而已。</p><p>​        如何想对定时任务进行相关配置，可以通过配置文件进行</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">task</span><span class="token punctuation">:</span>       <span class="token key atrule">scheduling</span><span class="token punctuation">:</span>      <span class="token key atrule">pool</span><span class="token punctuation">:</span>           <span class="token key atrule">size</span><span class="token punctuation">:</span> <span class="token number">1                            </span><span class="token comment" spellcheck="true"># 任务调度线程池大小 默认 1</span>      <span class="token key atrule">thread-name-prefix</span><span class="token punctuation">:</span> ssm_          <span class="token comment" spellcheck="true"># 调度线程名称前缀 默认 scheduling-      </span>        <span class="token key atrule">shutdown</span><span class="token punctuation">:</span>          <span class="token key atrule">await-termination</span><span class="token punctuation">:</span> <span class="token boolean important">false        </span><span class="token comment" spellcheck="true"># 线程池关闭时等待所有任务完成</span>          <span class="token key atrule">await-termination-period</span><span class="token punctuation">:</span> 10s    <span class="token comment" spellcheck="true"># 调度线程关闭前最大等待时间，确保最后一定关闭</span></code></pre><p><strong>总结</strong></p><ol><li><p>spring task需要使用注解@EnableScheduling开启定时任务功能</p></li><li><p>为定时执行的的任务设置执行周期，描述方式cron表达式</p></li></ol><h3 id="KF-5-3-邮件"><a href="#KF-5-3-邮件" class="headerlink" title="KF-5-3.邮件"></a>KF-5-3.邮件</h3><p>​        springboot整合第三方技术第三部分我们来说说邮件系统，发邮件是java程序的基本操作，springboot整合javamail其实就是简化开发。不熟悉邮件的小伙伴可以先学习完javamail的基础操作，再来看这一部分内容才能感触到springboot整合javamail究竟简化了哪些操作。简化的多码？其实不多，差别不大，只是还个格式而已。</p><p>​        学习邮件发送之前先了解3个概念，这些概念规范了邮件操作过程中的标准。</p><ul><li>SMTP（Simple Mail Transfer Protocol）：简单邮件传输协议，用于<strong>发送</strong>电子邮件的传输协议</li><li>POP3（Post Office Protocol - Version 3）：用于<strong>接收</strong>电子邮件的标准协议</li><li>IMAP（Internet Mail Access Protocol）：互联网消息协议，是POP3的替代协议</li></ul><p>​        简单说就是SMPT是发邮件的标准，POP3是收邮件的标准，IMAP是对POP3的升级。我们制作程序中操作邮件，通常是发邮件，所以SMTP是使用的重点，收邮件大部分都是通过邮件客户端完成，所以开发收邮件的代码极少。除非你要读取邮件内容，然后解析，做邮件功能的统一处理。例如HR的邮箱收到求职者的简历，可以读取后统一处理。但是为什么不制作独立的投递简历的系统呢？所以说，好奇怪的需求，因为要想收邮件就要规范发邮件的人的书写格式，这个未免有点强人所难，并且极易收到外部攻击，你不可能使用白名单来收邮件。如果能使用白名单来收邮件然后解析邮件，还不如开发个系统给白名单中的人专用呢，更安全，总之就是鸡肋了。下面就开始学习springboot如何整合javamail发送邮件。</p><h4 id="发送简单邮件"><a href="#发送简单邮件" class="headerlink" title="发送简单邮件"></a>发送简单邮件</h4><p><strong>步骤①</strong>：导入springboot整合javamail的starter</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-mail<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：配置邮箱的登录信息</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">mail</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> smtp.126.com    <span class="token key atrule">username</span><span class="token punctuation">:</span> test@126.com    <span class="token key atrule">password</span><span class="token punctuation">:</span> test</code></pre><p>​        java程序仅用于发送邮件，邮件的功能还是邮件供应商提供的，所以这里是用别人的邮件服务，要配置对应信息。</p><p>​        host配置的是提供邮件服务的主机协议，当前程序仅用于发送邮件，因此配置的是smtp的协议。</p><p>​        password并不是邮箱账号的登录密码，是邮件供应商提供的一个加密后的密码，也是为了保障系统安全性。不然外部人员通过地址访问下载了配置文件，直接获取到了邮件密码就会有极大的安全隐患。有关该密码的获取每个邮件供应商提供的方式都不一样，此处略过。可以到邮件供应商的设置页面找POP3或IMAP这些关键词找到对应的获取位置。下例仅供参考：</p><p><img src="img%5Cimage-20220228111251036.png" alt="image-20220228111251036"></p><p><strong>步骤③</strong>：使用JavaMailSender接口发送邮件</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SendMailServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SendMailService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> JavaMailSender javaMailSender<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//发送人</span>    <span class="token keyword">private</span> String from <span class="token operator">=</span> <span class="token string">"test@qq.com"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//接收人</span>    <span class="token keyword">private</span> String to <span class="token operator">=</span> <span class="token string">"test@126.com"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//标题</span>    <span class="token keyword">private</span> String subject <span class="token operator">=</span> <span class="token string">"测试邮件"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//正文</span>    <span class="token keyword">private</span> String context <span class="token operator">=</span> <span class="token string">"测试邮件正文内容"</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        SimpleMailMessage message <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimpleMailMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        message<span class="token punctuation">.</span><span class="token function">setFrom</span><span class="token punctuation">(</span>from<span class="token operator">+</span><span class="token string">"(小甜甜)"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        message<span class="token punctuation">.</span><span class="token function">setTo</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token punctuation">;</span>        message<span class="token punctuation">.</span><span class="token function">setSubject</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>        message<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        javaMailSender<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        将发送邮件的必要信息（发件人、收件人、标题、正文）封装到SimpleMailMessage对象中，可以根据规则设置发送人昵称等。</p><h4 id="发送多组件邮件（附件、复杂正文）"><a href="#发送多组件邮件（附件、复杂正文）" class="headerlink" title="发送多组件邮件（附件、复杂正文）"></a>发送多组件邮件（附件、复杂正文）</h4><p>​        发送简单邮件仅需要提供对应的4个基本信息就可以了，如果想发送复杂的邮件，需要更换邮件对象。使用MimeMessage可以发送特殊的邮件。</p><p><strong>发送网页正文邮件</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@Servicepublic class SendMailServiceImpl2 implements SendMailService &#123;    @Autowired    private JavaMailSender javaMailSender;    //发送人    private String from = "test@qq.com";    //接收人    private String to = "test@126.com";    //标题    private String subject = "测试邮件";    //正文    private String context = "<img src='ABC.JPG'/><a href='https://www.itcast.cn'>点开有惊喜</a>";    public void sendMail() &#123;        try &#123;            MimeMessage message = javaMailSender.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message);            helper.setFrom(to+"(小甜甜)");            helper.setTo(from);            helper.setSubject(subject);            helper.setText(context,true);        //此处设置正文支持html解析            javaMailSender.send(message);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><strong>发送带有附件的邮件</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@Servicepublic class SendMailServiceImpl2 implements SendMailService &#123;    @Autowired    private JavaMailSender javaMailSender;    //发送人    private String from = "test@qq.com";    //接收人    private String to = "test@126.com";    //标题    private String subject = "测试邮件";    //正文    private String context = "测试邮件正文";    public void sendMail() &#123;        try &#123;            MimeMessage message = javaMailSender.createMimeMessage();            MimeMessageHelper helper = new MimeMessageHelper(message,true);        //此处设置支持附件            helper.setFrom(to+"(小甜甜)");            helper.setTo(from);            helper.setSubject(subject);            helper.setText(context);            //添加附件            File f1 = new File("springboot_23_mail-0.0.1-SNAPSHOT.jar");            File f2 = new File("resources\\logo.png");            helper.addAttachment(f1.getName(),f1);            helper.addAttachment("最靠谱的培训结构.png",f2);            javaMailSender.send(message);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p><strong>总结</strong></p><ol><li>springboot整合javamail其实就是简化了发送邮件的客户端对象JavaMailSender的初始化过程，通过配置的形式加载信息简化开发过程</li></ol><h3 id="KF-5-4-消息"><a href="#KF-5-4-消息" class="headerlink" title="KF-5-4.消息"></a>KF-5-4.消息</h3><p>​        springboot整合第三方技术最后一部分我们来说说消息中间件，首先先介绍一下消息的应用。</p><h4 id="消息的概念"><a href="#消息的概念" class="headerlink" title="消息的概念"></a>消息的概念</h4><p>​        从广义角度来说，消息其实就是信息，但是和信息又有所不同。信息通常被定义为一组数据，而消息除了具有数据的特征之外，还有消息的来源与接收的概念。通常发送消息的一方称为消息的生产者，接收消息的一方称为消息的消费者。这样比较后，发现其实消息和信息差别还是很大的。</p><p>​        为什么要设置生产者和消费者呢？这就是要说到消息的意义了。信息通常就是一组数据，但是消息由于有了生产者和消费者，就出现了消息中所包含的信息可以被二次解读，生产者发送消息，可以理解为生产者发送了一个信息，也可以理解为生产者发送了一个命令；消费者接收消息，可以理解为消费者得到了一个信息，也可以理解为消费者得到了一个命令。对比一下我们会发现信息是一个基本数据，而命令则可以关联下一个行为动作，这样就可以理解为基于接收的消息相当于得到了一个行为动作，使用这些行为动作就可以组织成一个业务逻辑，进行进一步的操作。总的来说，消息其实也是一组信息，只是为其赋予了全新的含义，因为有了消息的流动，并且是有方向性的流动，带来了基于流动的行为产生的全新解读。开发者就可以基于消息的这种特殊解，将其换成代码中的指令。</p><p>​        对于消息的理解，初学者总认为消息内部的数据非常复杂，这是一个误区。比如我发送了一个消息，要求接受者翻译发送过去的内容。初学者会认为消息中会包含被翻译的文字，已经本次操作要执行翻译操作而不是打印操作。其实这种现象有点过度解读了，发送的消息中仅仅包含被翻译的文字，但是可以通过控制不同的人接收此消息来确认要做的事情。例如发送被翻译的文字仅到A程序，而A程序只能进行翻译操作，这样就可以发送简单的信息完成复杂的业务了，是通过接收消息的主体不同，进而执行不同的操作，而不会在消息内部定义数据的操作行为，当然如果开发者希望消息中包含操作种类信息也是可以的，只是提出消息的内容可以更简单，更单一。</p><p>​        对于消息的生产者与消费者的工作模式，还可以将消息划分成两种模式，同步消费与异步消息。</p><p>​        所谓同步消息就是生产者发送完消息，等待消费者处理，消费者处理完将结果告知生产者，然后生产者继续向下执行业务。这种模式过于卡生产者的业务执行连续性，在现在的企业级开发中，上述这种业务场景通常不会采用消息的形式进行处理。</p><p>​        所谓异步消息就是生产者发送完消息，无需等待消费者处理完毕，生产者继续向下执行其他动作。比如生产者发送了一个日志信息给日志系统，发送过去以后生产者就向下做其他事情了，无需关注日志系统的执行结果。日志系统根据接收到的日志信息继续进行业务执行，是单纯的记录日志，还是记录日志并报警，这些和生产者无关，这样生产者的业务执行效率就会大幅度提升。并且可以通过添加多个消费者来处理同一个生产者发送的消息来提高系统的高并发性，改善系统工作效率，提高用户体验。一旦某一个消费者由于各种问题宕机了，也不会对业务产生影响，提高了系统的高可用性。</p><p>​        以上简单的介绍了一下消息这种工作模式存在的意义，希望对各位学习者有所帮助。</p><h4 id="Java处理消息的标准规范"><a href="#Java处理消息的标准规范" class="headerlink" title="Java处理消息的标准规范"></a>Java处理消息的标准规范</h4><p>​        目前企业级开发中广泛使用的消息处理技术共三大类，具体如下：</p><ul><li>JMS</li><li>AMQP</li><li>MQTT</li></ul><p>​        为什么是三大类，而不是三个技术呢？因为这些都是规范，就想JDBC技术，是个规范，开发针对规范开发，运行还要靠实现类，例如MySQL提供了JDBC的实现，最终运行靠的还是实现。并且这三类规范都是针对异步消息进行处理的，也符合消息的设计本质，处理异步的业务。对以上三种消息规范做一下普及</p><h5 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h5><p>​        JMS（Java Message Service）,这是一个规范，作用等同于JDBC规范，提供了与消息服务相关的API接口。</p><p><strong>JMS消息模型</strong></p><p>​        JMS规范中规范了消息有两种模型。分别是<strong>点对点模型</strong>和<strong>发布订阅模型</strong>。</p><p>​        <strong>点对点模型</strong>：peer-2-peer，生产者会将消息发送到一个保存消息的容器中，通常使用队列模型，使用队列保存消息。一个队列的消息只能被一个消费者消费，或未被及时消费导致超时。这种模型下，生产者和消费者是一对一绑定的。</p><p>​        <strong>发布订阅模型</strong>：publish-subscribe，生产者将消息发送到一个保存消息的容器中，也是使用队列模型来保存。但是消息可以被多个消费者消费，生产者和消费者完全独立，相互不需要感知对方的存在。</p><p>​        以上这种分类是从消息的生产和消费过程来进行区分，针对消息所包含的信息不同，还可以进行不同类别的划分。</p><p><strong>JMS消息种类</strong></p><p>​        根据消息中包含的数据种类划分，可以将消息划分成6种消息。</p><ul><li>TextMessage</li><li>MapMessage</li><li>BytesMessage</li><li>StreamMessage</li><li>ObjectMessage</li><li>Message （只有消息头和属性）</li></ul><p>​        JMS主张不同种类的消息，消费方式不同，可以根据使用需要选择不同种类的消息。但是这一点也成为其诟病之处，后面再说。整体上来说，JMS就是典型的保守派，什么都按照J2EE的规范来，做一套规范，定义若干个标准，每个标准下又提供一大批API。目前对JMS规范实现的消息中间件技术还是挺多的，毕竟是皇家御用，肯定有人舔，例如ActiveMQ、Redis、HornetMQ。但是也有一些不太规范的实现，参考JMS的标准设计，但是又不完全满足其规范，例如：RabbitMQ、RocketMQ。</p><h5 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h5><p>​        JMS的问世为消息中间件提供了很强大的规范性支撑，但是使用的过程中就开始被人诟病，比如JMS设置的极其复杂的多种类消息处理机制。本来分门别类处理挺好的，为什么会被诟病呢？原因就在于JMS的设计是J2EE规范，站在Java开发的角度思考问题。但是现实往往是复杂度很高的。比如我有一个.NET开发的系统A，有一个Java开发的系统B，现在要从A系统给B系统发业务消息，结果两边数据格式不统一，没法操作。JMS不是可以统一数据格式吗？提供了6种数据种类，总有一款适合你啊。NO，一个都不能用。因为A系统的底层语言不是Java语言开发的，根本不支持那些对象。这就意味着如果想使用现有的业务系统A继续开发已经不可能了，必须推翻重新做使用Java语言开发的A系统。</p><p>​        这时候有人就提出说，你搞那么复杂，整那么多种类干什么？找一种大家都支持的消息数据类型不就解决这个跨平台的问题了吗？大家一想，对啊，于是AMQP孕育而生。</p><p>​        单从上面的说明中其实可以明确感知到，AMQP的出现解决的是消息传递时使用的消息种类的问题，化繁为简，但是其并没有完全推翻JMS的操作API，所以说AMQP仅仅是一种协议，规范了数据传输的格式而已。</p><p>​        AMQP（advanced message queuing protocol）：一种协议（高级消息队列协议，也是消息代理规范），规范了网络交换的数据格式，兼容JMS操作。<br><strong>优点</strong></p><p>​        具有跨平台性，服务器供应商，生产者，消费者可以使用不同的语言来实现</p><p><strong>JMS消息种类</strong></p><p>​        AMQP消息种类：byte[]</p><p>​        AMQP在JMS的消息模型基础上又进行了进一步的扩展，除了点对点和发布订阅的模型，开发了几种全新的消息模型，适应各种各样的消息发送。</p><p><strong>AMQP消息模型</strong></p><ul><li>direct exchange</li><li>fanout exchange</li><li>topic exchange</li><li>headers exchange</li><li>system exchange</li></ul><p>​        目前实现了AMQP协议的消息中间件技术也很多，而且都是较为流行的技术，例如：RabbitMQ、StormMQ、RocketMQ</p><h5 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h5><p>​        MQTT（Message Queueing Telemetry Transport）消息队列遥测传输，专为小设备设计，是物联网（IOT）生态系统中主要成分之一。由于与JavaEE企业级开发没有交集，此处不作过多的说明。</p><p>​        除了上述3种J2EE企业级应用中广泛使用的三种异步消息传递技术，还有一种技术也不能忽略，Kafka。</p><h5 id="KafKa"><a href="#KafKa" class="headerlink" title="KafKa"></a>KafKa</h5><p>​        Kafka，一种高吞吐量的分布式发布订阅消息系统，提供实时消息功能。Kafka技术并不是作为消息中间件为主要功能的产品，但是其拥有发布订阅的工作模式，也可以充当消息中间件来使用，而且目前企业级开发中其身影也不少见。</p><p>​        本节内容讲围绕着上述内容中的几种实现方案讲解springboot整合各种各样的消息中间件。由于各种消息中间件必须先安装再使用，下面的内容采用Windows系统安装，降低各位学习者的学习难度，基本套路和之前学习NoSQL解决方案一样，先安装再整合。</p><h4 id="购物订单发送手机短信案例"><a href="#购物订单发送手机短信案例" class="headerlink" title="购物订单发送手机短信案例"></a>购物订单发送手机短信案例</h4><p>​        为了便于下面演示各种各样的消息中间件技术，我们创建一个购物过程生成订单时为用户发送短信的案例环境，模拟使用消息中间件实现发送手机短信的过程。</p><p>​        手机验证码案例需求如下：</p><ul><li><p>执行下单业务时（模拟此过程），调用消息服务，将要发送短信的订单id传递给消息中间件</p></li><li><p>消息处理服务接收到要发送的订单id后输出订单id（模拟发短信）</p><p>由于不涉及数据读写，仅开发业务层与表现层，其中短信处理的业务代码独立开发，代码如下：</p></li></ul><p><strong>订单业务</strong></p><p>​        <strong>业务层接口</strong></p><pre class=" language-JAVA"><code class="language-JAVA">public interface OrderService &#123;    void order(String id);&#125;</code></pre><p>​        模拟传入订单id，执行下订单业务，参数为虚拟设定，实际应为订单对应的实体类</p><p>​        <strong>业务层实现</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@Servicepublic class OrderServiceImpl implements OrderService &#123;    @Autowired    private MessageService messageService;        @Override    public void order(String id) &#123;        //一系列操作，包含各种服务调用，处理各种业务        System.out.println("订单处理开始");        //短信消息处理        messageService.sendMessage(id);        System.out.println("订单处理结束");        System.out.println();    &#125;&#125;</code></pre><p>​        业务层转调短信处理的服务MessageService</p><p>​        <strong>表现层服务</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@RestController@RequestMapping("/orders")public class OrderController &#123;    @Autowired    private OrderService orderService;    @PostMapping("&#123;id&#125;")    public void order(@PathVariable String id)&#123;        orderService.order(id);    &#125;&#125;</code></pre><p>​        表现层对外开发接口，传入订单id即可（模拟）</p><p><strong>短信处理业务</strong></p><p>​        <strong>业务层接口</strong></p><pre class=" language-JAVA"><code class="language-JAVA">public interface MessageService &#123;    void sendMessage(String id);    String doMessage();&#125;</code></pre><p>​        短信处理业务层接口提供两个操作，发送要处理的订单id到消息中间件，另一个操作目前暂且设计成处理消息，实际消息的处理过程不应该是手动执行，应该是自动执行，到具体实现时再进行设计</p><p>​        <strong>业务层实现</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@Servicepublic class MessageServiceImpl implements MessageService &#123;    private ArrayList<String> msgList = new ArrayList<String>();    @Override    public void sendMessage(String id) &#123;        System.out.println("待发送短信的订单已纳入处理队列，id："+id);        msgList.add(id);    &#125;    @Override    public String doMessage() &#123;        String id = msgList.remove(0);        System.out.println("已完成短信发送业务，id："+id);        return id;    &#125;&#125;</code></pre><p>​        短信处理业务层实现中使用集合先模拟消息队列，观察效果</p><p>​        <strong>表现层服务</strong></p><pre class=" language-JAVA"><code class="language-JAVA">@RestController@RequestMapping("/msgs")public class MessageController &#123;    @Autowired    private MessageService messageService;    @GetMapping    public String doMessage()&#123;        String id = messageService.doMessage();        return id;    &#125;&#125;</code></pre><p>​        短信处理表现层接口暂且开发出一个处理消息的入口，但是此业务是对应业务层中设计的模拟接口，实际业务不需要设计此接口。</p><p>​        下面开启springboot整合各种各样的消息中间件，从严格满足JMS规范的ActiveMQ开始</p><h4 id="SpringBoot整合ActiveMQ"><a href="#SpringBoot整合ActiveMQ" class="headerlink" title="SpringBoot整合ActiveMQ"></a>SpringBoot整合ActiveMQ</h4><p>​        ActiveMQ是MQ产品中的元老级产品，早期标准MQ产品之一，在AMQP协议没有出现之前，占据了消息中间件市场的绝大部分份额，后期因为AMQP系列产品的出现，迅速走弱，目前仅在一些线上运行的产品中出现，新产品开发较少采用。</p><h5 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h5><p>​        windows版安装包下载地址：<a href="https://activemq.apache.org/components/classic/download/">https://activemq.apache.org/components/classic/download</a><a href="https://activemq.apache.org/components/classic/download/">/</a></p><p>​        下载的安装包是解压缩就能使用的zip文件，解压缩完毕后会得到如下文件</p><p><img src="img%5Cimage-20220228160001620.png" alt="image-20220228160001620"></p><p><strong>启动服务器</strong></p><pre class=" language-CMD"><code class="language-CMD">activemq.bat</code></pre><p>​        运行bin目录下的win32或win64目录下的activemq.bat命令即可，根据自己的操作系统选择即可，默认对外服务端口61616。</p><p><strong>访问web管理服务</strong></p><p>​        ActiveMQ启动后会启动一个Web控制台服务，可以通过该服务管理ActiveMQ。</p><pre class=" language-CMD"><code class="language-CMD">http://127.0.0.1:8161/</code></pre><p>​        web管理服务默认端口8161，访问后可以打开ActiveMQ的管理界面，如下：</p><img src="img\image-20220228160844972.png" alt="image-20220228160844972" style="zoom:67%;" /><p>​        首先输入访问用户名和密码，初始化用户名和密码相同，均为：admin，成功登录后进入管理后台界面，如下：</p><p><img src="img%5Cimage-20220228161010401.png" alt="image-20220228161010401"></p><p>​        看到上述界面视为启动ActiveMQ服务成功。</p><p><strong>启动失败</strong></p><p>​        在ActiveMQ启动时要占用多个端口，以下为正常启动信息：</p><pre class=" language-CMD"><code class="language-CMD">wrapper  | --> Wrapper Started as Consolewrapper  | Launching a JVM...jvm 1    | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.orgjvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.jvm 1    |jvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\soft\jdk1.8.0_172\jrejvm 1    |   Heap sizes: current=249344k  free=235037k  max=932352kjvm 1    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.net.ssl.keyStorePassword=password -Djavax.net.ssl.trustStorePassword=password -Djavax.net.ssl.keyStore=../../conf/broker.ks -Djavax.net.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.path=../../bin/win64 -Dwrapper.key=7ySrCD75XhLCpLjd -Dwrapper.port=32000 -Dwrapper.jvm.port.min=31000 -Dwrapper.jvm.port.max=31999 -Dwrapper.pid=9364 -Dwrapper.version=3.2.3 -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=10 -Dwrapper.jvmid=1jvm 1    | Extensions classpath:jvm 1    |   [..\..\lib,..\..\lib\camel,..\..\lib\optional,..\..\lib\web,..\..\lib\extra]jvm 1    | ACTIVEMQ_HOME: ..\..jvm 1    | ACTIVEMQ_BASE: ..\..jvm 1    | ACTIVEMQ_CONF: ..\..\confjvm 1    | ACTIVEMQ_DATA: ..\..\datajvm 1    | Loading message broker from: xbean:activemq.xmljvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@5f3ebfe0: startup date [Mon Feb 28 16:07:48 CST 2022]; root of context hierarchyjvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\soft\activemq\bin\win64\..\..\data\kahadb]jvm 1    |  INFO | KahaDB is version 7jvm 1    |  INFO | PListStore:[D:\soft\activemq\bin\win64\..\..\data\localhost\tmp_storage] startedjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) is startingjvm 1    |  INFO | Listening for connections at: tcp://CZBK-20210302VL:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector openwire startedjvm 1    |  INFO | Listening for connections at: amqp://CZBK-20210302VL:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector amqp startedjvm 1    |  INFO | Listening for connections at: stomp://CZBK-20210302VL:61613?maximumConnections=1000&wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector stomp startedjvm 1    |  INFO | Listening for connections at: mqtt://CZBK-20210302VL:1883?maximumConnections=1000&wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector mqtt startedjvm 1    |  INFO | Starting Jetty serverjvm 1    |  INFO | Creating Jetty connectorjvm 1    |  WARN | ServletContext@o.e.j.s.ServletContextHandler@7350746f&#123;/,null,STARTING&#125; has uncovered http methods for path: /jvm 1    |  INFO | Listening for connections at ws://CZBK-20210302VL:61614?maximumConnections=1000&wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector ws startedjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10434-1646035669595-0:1) startedjvm 1    |  INFO | For help or more information please see: http://activemq.apache.orgjvm 1    |  WARN | Store limit is 102400 mb (current store usage is 0 mb). The data directory: D:\soft\activemq\bin\win64\..\..\data\kahadb only has 68936 mb of usable space. - resetting to maximum available disk space: 68936 mbjvm 1    |  INFO | ActiveMQ WebConsole available at http://127.0.0.1:8161/jvm 1    |  INFO | ActiveMQ Jolokia REST API available at http://127.0.0.1:8161/api/jolokia/</code></pre><p>​        其中占用的端口有：61616、5672、61613、1883、61614，如果启动失败，请先管理对应端口即可。以下就是某个端口占用的报错信息，可以从抛出异常的位置看出，启动5672端口时端口被占用，显示java.net.BindException: Address already in use: JVM_Bind。Windows系统中终止端口运行的操作参看<a href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%90%AF%E5%8A%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">【命令行启动常见问题及解决方案】</a></p><pre class=" language-CMD"><code class="language-CMD">wrapper  | --> Wrapper Started as Consolewrapper  | Launching a JVM...jvm 1    | Wrapper (Version 3.2.3) http://wrapper.tanukisoftware.orgjvm 1    |   Copyright 1999-2006 Tanuki Software, Inc.  All Rights Reserved.jvm 1    |jvm 1    | Java Runtime: Oracle Corporation 1.8.0_172 D:\soft\jdk1.8.0_172\jrejvm 1    |   Heap sizes: current=249344k  free=235038k  max=932352kjvm 1    |     JVM args: -Dactivemq.home=../.. -Dactivemq.base=../.. -Djavax.net.ssl.keyStorePassword=password -Djavax.net.ssl.trustStorePassword=password -Djavax.net.ssl.keyStore=../../conf/broker.ks -Djavax.net.ssl.trustStore=../../conf/broker.ts -Dcom.sun.management.jmxremote -Dorg.apache.activemq.UseDedicatedTaskRunner=true -Djava.util.logging.config.file=logging.properties -Dactivemq.conf=../../conf -Dactivemq.data=../../data -Djava.security.auth.login.config=../../conf/login.config -Xmx1024m -Djava.library.path=../../bin/win64 -Dwrapper.key=QPJoy9ZoXeWmmwTS -Dwrapper.port=32000 -Dwrapper.jvm.port.min=31000 -Dwrapper.jvm.port.max=31999 -Dwrapper.pid=14836 -Dwrapper.version=3.2.3 -Dwrapper.native_library=wrapper -Dwrapper.cpu.timeout=10 -Dwrapper.jvmid=1jvm 1    | Extensions classpath:jvm 1    |   [..\..\lib,..\..\lib\camel,..\..\lib\optional,..\..\lib\web,..\..\lib\extra]jvm 1    | ACTIVEMQ_HOME: ..\..jvm 1    | ACTIVEMQ_BASE: ..\..jvm 1    | ACTIVEMQ_CONF: ..\..\confjvm 1    | ACTIVEMQ_DATA: ..\..\datajvm 1    | Loading message broker from: xbean:activemq.xmljvm 1    |  INFO | Refreshing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchyjvm 1    |  INFO | Using Persistence Adapter: KahaDBPersistenceAdapter[D:\soft\activemq\bin\win64\..\..\data\kahadb]jvm 1    |  INFO | KahaDB is version 7jvm 1    |  INFO | PListStore:[D:\soft\activemq\bin\win64\..\..\data\localhost\tmp_storage] startedjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is startingjvm 1    |  INFO | Listening for connections at: tcp://CZBK-20210302VL:61616?maximumConnections=1000&wireFormat.maxFrameSize=104857600jvm 1    |  INFO | Connector openwire startedjvm 1    | ERROR | Failed to start Apache ActiveMQ (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1)jvm 1    | java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bindjvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:28)jvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2288)jvm 1    |      at org.apache.activemq.broker.BrokerService.startTransportConnector(BrokerService.java:2769)jvm 1    |      at org.apache.activemq.broker.BrokerService.startAllConnectors(BrokerService.java:2665)jvm 1    |      at org.apache.activemq.broker.BrokerService.doStartBroker(BrokerService.java:780)jvm 1    |      at org.apache.activemq.broker.BrokerService.startBroker(BrokerService.java:742)jvm 1    |      at org.apache.activemq.broker.BrokerService.start(BrokerService.java:645)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerService.afterPropertiesSet(XBeanBrokerService.java:73)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeCustomInitMethod(AbstractAutowireCapableBeanFactory.java:1748)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1685)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1615)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:553)jvm 1    |      at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:481)jvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:312)jvm 1    |      at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230)jvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:308)jvm 1    |      at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197)jvm 1    |      at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:756)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:867)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:542)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)jvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)jvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)jvm 1    |      at java.lang.Thread.run(Thread.java:748)jvm 1    | Caused by: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bindjvm 1    |      at org.apache.activemq.util.IOExceptionSupport.create(IOExceptionSupport.java:34)jvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:146)jvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportFactory.doBind(TcpTransportFactory.java:62)jvm 1    |      at org.apache.activemq.transport.TransportFactorySupport.bind(TransportFactorySupport.java:40)jvm 1    |      at org.apache.activemq.broker.TransportConnector.createTransportServer(TransportConnector.java:335)jvm 1    |      at org.apache.activemq.broker.TransportConnector.getServer(TransportConnector.java:145)jvm 1    |      at org.apache.activemq.broker.TransportConnector.asManagedConnector(TransportConnector.java:110)jvm 1    |      at org.apache.activemq.broker.BrokerService.registerConnectorMBean(BrokerService.java:2283)jvm 1    |      ... 46 morejvm 1    | Caused by: java.net.BindException: Address already in use: JVM_Bindjvm 1    |      at java.net.DualStackPlainSocketImpl.bind0(Native Method)jvm 1    |      at java.net.DualStackPlainSocketImpl.socketBind(DualStackPlainSocketImpl.java:106)jvm 1    |      at java.net.AbstractPlainSocketImpl.bind(AbstractPlainSocketImpl.java:387)jvm 1    |      at java.net.PlainSocketImpl.bind(PlainSocketImpl.java:190)jvm 1    |      at java.net.ServerSocket.bind(ServerSocket.java:375)jvm 1    |      at java.net.ServerSocket.<init>(ServerSocket.java:237)jvm 1    |      at javax.net.DefaultServerSocketFactory.createServerSocket(ServerSocketFactory.java:231)jvm 1    |      at org.apache.activemq.transport.tcp.TcpTransportServer.bind(TcpTransportServer.java:143)jvm 1    |      ... 52 morejvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutting downjvm 1    |  INFO | socketQueue interrupted - stoppingjvm 1    |  INFO | Connector openwire stoppedjvm 1    |  INFO | Could not accept connection during shutdown  : null (null)jvm 1    |  INFO | Connector amqp stoppedjvm 1    |  INFO | Connector stomp stoppedjvm 1    |  INFO | Connector mqtt stoppedjvm 1    |  INFO | Connector ws stoppedjvm 1    |  INFO | PListStore:[D:\soft\activemq\bin\win64\..\..\data\localhost\tmp_storage] stoppedjvm 1    |  INFO | Stopping async queue tasksjvm 1    |  INFO | Stopping async topic tasksjvm 1    |  INFO | Stopped KahaDBjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) uptime 0.426 secondsjvm 1    |  INFO | Apache ActiveMQ 5.16.3 (localhost, ID:CZBK-20210302VL-10257-1646035577620-0:1) is shutdownjvm 1    |  INFO | Closing org.apache.activemq.xbean.XBeanBrokerFactory$1@2c9392f5: startup date [Mon Feb 28 16:06:16 CST 2022]; root of context hierarchyjvm 1    |  WARN | Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.apache.activemq.xbean.XBeanBrokerService#0' defined in class path resource [activemq.xml]: Invocation of init method failed; nested exception is java.io.IOException: Transport Connector could not be registered in JMX: java.io.IOException: Failed to bind to server socket: amqp://0.0.0.0:5672?maximumConnections=1000&wireFormat.maxFrameSize=104857600 due to: java.net.BindException: Address already in use: JVM_Bindjvm 1    | ERROR: java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContextjvm 1    | java.lang.RuntimeException: Failed to execute start task. Reason: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContextjvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:91)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)jvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)jvm 1    |      at java.lang.Thread.run(Thread.java:748)jvm 1    | Caused by: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContextjvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)jvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)jvm 1    |      ... 16 morejvm 1    | ERROR: java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContextjvm 1    | java.lang.IllegalStateException: BeanFactory not initialized or already closed - call 'refresh' before accessing beans via the ApplicationContextjvm 1    |      at org.springframework.context.support.AbstractRefreshableApplicationContext.getBeanFactory(AbstractRefreshableApplicationContext.java:164)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.destroyBeans(AbstractApplicationContext.java:1034)jvm 1    |      at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:555)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:64)jvm 1    |      at org.apache.xbean.spring.context.ResourceXmlApplicationContext.<init>(ResourceXmlApplicationContext.java:52)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory$1.<init>(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createApplicationContext(XBeanBrokerFactory.java:104)jvm 1    |      at org.apache.activemq.xbean.XBeanBrokerFactory.createBroker(XBeanBrokerFactory.java:67)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:71)jvm 1    |      at org.apache.activemq.broker.BrokerFactory.createBroker(BrokerFactory.java:54)jvm 1    |      at org.apache.activemq.console.command.StartCommand.runTask(StartCommand.java:87)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.runTask(ShellCommand.java:154)jvm 1    |      at org.apache.activemq.console.command.AbstractCommand.execute(AbstractCommand.java:63)jvm 1    |      at org.apache.activemq.console.command.ShellCommand.main(ShellCommand.java:104)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.apache.activemq.console.Main.runTaskClass(Main.java:262)jvm 1    |      at org.apache.activemq.console.Main.main(Main.java:115)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)jvm 1    |      at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)jvm 1    |      at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)jvm 1    |      at java.lang.reflect.Method.invoke(Method.java:498)jvm 1    |      at org.tanukisoftware.wrapper.WrapperSimpleApp.run(WrapperSimpleApp.java:240)jvm 1    |      at java.lang.Thread.run(Thread.java:748)wrapper  | <-- Wrapper Stopped请按任意键继续. . .</code></pre><h5 id="整合-3"><a href="#整合-3" class="headerlink" title="整合"></a>整合</h5><p>​        做了这么多springboot整合第三方技术，已经摸到门路了，加坐标，做配置，调接口，直接开工</p><p><strong>步骤①</strong>：导入springboot整合ActiveMQ的starter</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-activemq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：配置ActiveMQ的服务器地址</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">activemq</span><span class="token punctuation">:</span>    <span class="token key atrule">broker-url</span><span class="token punctuation">:</span> tcp<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">61616</span></code></pre><p><strong>步骤③</strong>：使用JmsMessagingTemplate操作ActiveMQ</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageServiceActivemqImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MessageService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> JmsMessagingTemplate messagingTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>String id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"待发送短信的订单已纳入处理队列，id："</span><span class="token operator">+</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        messagingTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"order.queue.id"</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">doMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        String id <span class="token operator">=</span> messagingTemplate<span class="token punctuation">.</span><span class="token function">receiveAndConvert</span><span class="token punctuation">(</span><span class="token string">"order.queue.id"</span><span class="token punctuation">,</span>String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已完成短信发送业务，id："</span><span class="token operator">+</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        发送消息需要先将消息的类型转换成字符串，然后再发送，所以是convertAndSend，定义消息发送的位置，和具体的消息内容，此处使用id作为消息内容。</p><p>​        接收消息需要先将消息接收到，然后再转换成指定的数据类型，所以是receiveAndConvert，接收消息除了提供读取的位置，还要给出转换后的数据的具体类型。</p><p><strong>步骤④</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p><pre class=" language-JAVA"><code class="language-JAVA">@Componentpublic class MessageListener &#123;    @JmsListener(destination = "order.queue.id")    @SendTo("order.other.queue.id")    public String receive(String id)&#123;        System.out.println("已完成短信发送业务，id："+id);        return "new:"+id;    &#125;&#125;</code></pre><p>​        使用注解@JmsListener定义当前方法监听ActiveMQ中指定名称的消息队列。</p><p>​        如果当前消息队列处理完还需要继续向下传递当前消息到另一个队列中使用注解@SendTo即可，这样即可构造连续执行的顺序消息队列。</p><p><strong>步骤⑤</strong>：切换消息模型由点对点模型到发布订阅模型，修改jms配置即可</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">activemq</span><span class="token punctuation">:</span>    <span class="token key atrule">broker-url</span><span class="token punctuation">:</span> tcp<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">61616</span>  <span class="token key atrule">jms</span><span class="token punctuation">:</span>    <span class="token key atrule">pub-sub-domain</span><span class="token punctuation">:</span> <span class="token boolean important">true</span></code></pre><p>​        pub-sub-domain默认值为false，即点对点模型，修改为true后就是发布订阅模型。</p><p><strong>总结</strong></p><ol><li>springboot整合ActiveMQ提供了JmsMessagingTemplate对象作为客户端操作消息队列</li><li>操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口61616</li><li>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@JmsListener</li><li>配置jms的pub-sub-domain属性可以在点对点模型和发布订阅模型间切换消息模型</li></ol><h4 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h4><p>​        RabbitMQ是MQ产品中的目前较为流行的产品之一，它遵从AMQP协议。RabbitMQ的底层实现语言使用的是Erlang，所以安装RabbitMQ需要先安装Erlang。</p><p><strong>Erlang安装</strong></p><p>​        windows版安装包下载地址：<a href="https://www.erlang.org/downloads">https</a><a href="https://www.erlang.org/downloads">://www.erlang.org/downloads</a></p><p>​        下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕需要重启，需要重启，需要重启。</p><p>​        安装的过程中可能会出现依赖Windows组件的提示，根据提示下载安装即可，都是自动执行的，如下：</p><p><img src="img%5Cimage-20220228164851551.png" alt="image-20220228164851551"></p><p>​        Erlang安装后需要配置环境变量，否则RabbitMQ将无法找到安装的Erlang。需要配置项如下，作用等同JDK配置环境变量的作用。</p><ul><li>ERLANG_HOME</li><li>PATH</li></ul><h5 id="安装-4"><a href="#安装-4" class="headerlink" title="安装"></a>安装</h5><p>​        windows版安装包下载地址：<a href="https://rabbitmq.com/install-windows.html">https://</a><a href="https://rabbitmq.com/install-windows.html">rabbitmq.com/install-windows.html</a></p><p>​        下载完毕后得到exe安装文件，一键傻瓜式安装，安装完毕后会得到如下文件</p><img src="img\image-20220228165151524.png" alt="image-20220228165151524" style="zoom:67%;" /><p><strong>启动服务器</strong></p><pre class=" language-CMD"><code class="language-CMD">rabbitmq-service.bat start        # 启动服务rabbitmq-service.bat stop        # 停止服务rabbitmqctl status                # 查看服务状态</code></pre><p>​        运行sbin目录下的rabbitmq-service.bat命令即可，start参数表示启动，stop参数表示退出，默认对外服务端口5672。</p><p>​        注意：启动rabbitmq的过程实际上是开启rabbitmq对应的系统服务，需要管理员权限方可执行。</p><p>​        说明：有没有感觉5672的服务端口很熟悉？activemq与rabbitmq有一个端口冲突问题，学习阶段无论操作哪一个？请确保另一个处于关闭状态。</p><p>​        说明：不喜欢命令行的小伙伴可以使用任务管理器中的服务页，找到RabbitMQ服务，使用鼠标右键菜单控制服务的启停。</p><img src="img\image-20220228170147193.png" alt="image-20220228170147193" style="zoom:67%;" /><p><strong>访问web管理服务</strong></p><p>​        RabbitMQ也提供有web控制台服务，但是此功能是一个插件，需要先启用才可以使用。</p><pre class=" language-CMD"><code class="language-CMD">rabbitmq-plugins.bat list                            # 查看当前所有插件的运行状态rabbitmq-plugins.bat enable rabbitmq_management        # 启动rabbitmq_management插件</code></pre><p>​        启动插件后可以在插件运行状态中查看是否运行，运行后通过浏览器即可打开服务后台管理界面</p><pre class=" language-CMD"><code class="language-CMD">http://localhost:15672</code></pre><p>​        web管理服务默认端口15672，访问后可以打开RabbitMQ的管理界面，如下：</p><p><img src="img%5Cimage-20220228170504793.png" alt="image-20220228170504793"></p><p>​        首先输入访问用户名和密码，初始化用户名和密码相同，均为：guest，成功登录后进入管理后台界面，如下：</p><p><img src="img%5Cimage-20220228170535261.png" alt="image-20220228170535261"></p><h5 id="整合-direct模型"><a href="#整合-direct模型" class="headerlink" title="整合(direct模型)"></a>整合(direct模型)</h5><p>​        RabbitMQ满足AMQP协议，因此不同的消息模型对应的制作不同，先使用最简单的direct模型开发。</p><p><strong>步骤①</strong>：导入springboot整合amqp的starter，amqp协议默认实现为rabbitmq方案</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：配置RabbitMQ的服务器地址</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">rabbitmq</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> localhost    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">5672</span></code></pre><p><strong>步骤③</strong>：初始化直连模式系统设置</p><p>​        由于RabbitMQ不同模型要使用不同的交换机，因此需要先初始化RabbitMQ相关的对象，例如队列，交换机等</p><pre class=" language-JAVA"><code class="language-JAVA">@Configurationpublic class RabbitConfigDirect &#123;    @Bean    public Queue directQueue()&#123;        return new Queue("direct_queue");    &#125;    @Bean    public Queue directQueue2()&#123;        return new Queue("direct_queue2");    &#125;    @Bean    public DirectExchange directExchange()&#123;        return new DirectExchange("directExchange");    &#125;    @Bean    public Binding bindingDirect()&#123;        return BindingBuilder.bind(directQueue()).to(directExchange()).with("direct");    &#125;    @Bean    public Binding bindingDirect2()&#123;        return BindingBuilder.bind(directQueue2()).to(directExchange()).with("direct2");    &#125;&#125;</code></pre><p>​        队列Queue与直连交换机DirectExchange创建后，还需要绑定他们之间的关系Binding，这样就可以通过交换机操作对应队列。</p><p><strong>步骤④</strong>：使用AmqpTemplate操作RabbitMQ</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageServiceRabbitmqDirectImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MessageService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> AmqpTemplate amqpTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>String id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"待发送短信的订单已纳入处理队列（rabbitmq direct），id："</span><span class="token operator">+</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        amqpTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"directExchange"</span><span class="token punctuation">,</span><span class="token string">"direct"</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        amqp协议中的操作API接口名称看上去和jms规范的操作API接口很相似，但是传递参数差异很大。</p><p><strong>步骤⑤</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p><pre class=" language-JAVA"><code class="language-JAVA">@Componentpublic class MessageListener &#123;    @RabbitListener(queues = "direct_queue")    public void receive(String id)&#123;        System.out.println("已完成短信发送业务(rabbitmq direct)，id："+id);    &#125;&#125;</code></pre><p>​        使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。</p><h5 id="整合-topic模型"><a href="#整合-topic模型" class="headerlink" title="整合(topic模型)"></a>整合(topic模型)</h5><p><strong>步骤①</strong>：同上</p><p><strong>步骤②</strong>：同上</p><p><strong>步骤③</strong>：初始化主题模式系统设置</p><pre class=" language-JAVA"><code class="language-JAVA">@Configurationpublic class RabbitConfigTopic &#123;    @Bean    public Queue topicQueue()&#123;        return new Queue("topic_queue");    &#125;    @Bean    public Queue topicQueue2()&#123;        return new Queue("topic_queue2");    &#125;    @Bean    public TopicExchange topicExchange()&#123;        return new TopicExchange("topicExchange");    &#125;    @Bean    public Binding bindingTopic()&#123;        return BindingBuilder.bind(topicQueue()).to(topicExchange()).with("topic.*.id");    &#125;    @Bean    public Binding bindingTopic2()&#123;        return BindingBuilder.bind(topicQueue2()).to(topicExchange()).with("topic.orders.*");    &#125;&#125;</code></pre><p>​        主题模式支持routingKey匹配模式，*表示匹配一个单词，#表示匹配任意内容，这样就可以通过主题交换机将消息分发到不同的队列中，详细内容请参看RabbitMQ系列课程。    </p><table><thead><tr><th><strong>匹配键</strong></th><th><strong>topic.*.*</strong></th><th><strong>topic.#</strong></th></tr></thead><tbody><tr><td>topic.order.id</td><td>true</td><td>true</td></tr><tr><td>order.topic.id</td><td>false</td><td>false</td></tr><tr><td>topic.sm.order.id</td><td>false</td><td>true</td></tr><tr><td>topic.sm.id</td><td>false</td><td>true</td></tr><tr><td>topic.id.order</td><td>true</td><td>true</td></tr><tr><td>topic.id</td><td>false</td><td>true</td></tr><tr><td>topic.order</td><td>false</td><td>true</td></tr></tbody></table><p><strong>步骤④</strong>：使用AmqpTemplate操作RabbitMQ</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageServiceRabbitmqTopicImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MessageService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> AmqpTemplate amqpTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>String id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"待发送短信的订单已纳入处理队列（rabbitmq topic），id："</span><span class="token operator">+</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        amqpTemplate<span class="token punctuation">.</span><span class="token function">convertAndSend</span><span class="token punctuation">(</span><span class="token string">"topicExchange"</span><span class="token punctuation">,</span><span class="token string">"topic.orders.id"</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        发送消息后，根据当前提供的routingKey与绑定交换机时设定的routingKey进行匹配，规则匹配成功消息才会进入到对应的队列中。</p><p><strong>步骤⑤</strong>：使用消息监听器在服务器启动后，监听指定队列</p><pre class=" language-JAVA"><code class="language-JAVA">@Componentpublic class MessageListener &#123;    @RabbitListener(queues = "topic_queue")    public void receive(String id)&#123;        System.out.println("已完成短信发送业务(rabbitmq topic 1)，id："+id);    &#125;    @RabbitListener(queues = "topic_queue2")    public void receive2(String id)&#123;        System.out.println("已完成短信发送业务(rabbitmq topic 22222222)，id："+id);    &#125;&#125;</code></pre><p>​        使用注解@RabbitListener定义当前方法监听RabbitMQ中指定名称的消息队列。</p><p><strong>总结</strong></p><ol><li>springboot整合RabbitMQ提供了AmqpTemplate对象作为客户端操作消息队列</li><li>操作ActiveMQ需要配置ActiveMQ服务器地址，默认端口5672</li><li>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RabbitListener</li><li>RabbitMQ有5种消息模型，使用的队列相同，但是交换机不同。交换机不同，对应的消息进入的策略也不同</li></ol><h4 id="SpringBoot整合RocketMQ"><a href="#SpringBoot整合RocketMQ" class="headerlink" title="SpringBoot整合RocketMQ"></a>SpringBoot整合RocketMQ</h4><p>​        RocketMQ由阿里研发，后捐赠给apache基金会，目前是apache基金会顶级项目之一，也是目前市面上的MQ产品中较为流行的产品之一，它遵从AMQP协议。</p><h5 id="安装-5"><a href="#安装-5" class="headerlink" title="安装"></a>安装</h5><p>​        windows版安装包下载地址：<a href="https://rocketmq.apache.org/">https://rocketmq.apache.org</a><a href="https://rocketmq.apache.org/">/</a></p><p>​        下载完毕后得到zip压缩文件，解压缩即可使用，解压后得到如下文件</p><p><img src="img%5Cimage-20220228174453471.png" alt="image-20220228174453471"></p><p>​        RocketMQ安装后需要配置环境变量，具体如下：</p><ul><li>ROCKETMQ_HOME</li><li>PATH</li><li>NAMESRV_ADDR （建议）： 127.0.0.1:9876</li></ul><p>​        关于NAMESRV_ADDR对于初学者来说建议配置此项，也可以通过命令设置对应值，操作略显繁琐，建议配置。系统学习RocketMQ知识后即可灵活控制该项。</p><p><strong>RocketMQ工作模式</strong></p><p>​        在RocketMQ中，处理业务的服务器称为broker，生产者与消费者不是直接与broker联系的，而是通过命名服务器进行通信。broker启动后会通知命名服务器自己已经上线，这样命名服务器中就保存有所有的broker信息。当生产者与消费者需要连接broker时，通过命名服务器找到对应的处理业务的broker，因此命名服务器在整套结构中起到一个信息中心的作用。并且broker启动前必须保障命名服务器先启动。</p><img src="img\image-20220228175123790.png" alt="image-20220228175123790" style="zoom:80%;" /><p><strong>启动服务器</strong></p><pre class=" language-CMD"><code class="language-CMD">mqnamesrv        # 启动命名服务器mqbroker        # 启动broker</code></pre><p>​        运行bin目录下的mqnamesrv命令即可启动命名服务器，默认对外服务端口9876。</p><p>​        运行bin目录下的mqbroker命令即可启动broker服务器，如果环境变量中没有设置NAMESRV_ADDR则需要在运行mqbroker指令前通过set指令设置NAMESRV_ADDR的值，并且每次开启均需要设置此项。</p><p><strong>测试服务器启动状态</strong></p><p>​        RocketMQ提供有一套测试服务器功能的测试程序，运行bin目录下的tools命令即可使用。</p><pre class=" language-CMD"><code class="language-CMD">tools org.apache.rocketmq.example.quickstart.Producer        # 生产消息tools org.apache.rocketmq.example.quickstart.Consumer        # 消费消息</code></pre><h5 id="整合（异步消息）"><a href="#整合（异步消息）" class="headerlink" title="整合（异步消息）"></a>整合（异步消息）</h5><p><strong>步骤①</strong>：导入springboot整合RocketMQ的starter，此坐标不由springboot维护版本</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.rocketmq<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>rocketmq-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.2.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：配置RocketMQ的服务器地址</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">rocketmq</span><span class="token punctuation">:</span>  <span class="token key atrule">name-server</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">9876</span>  <span class="token key atrule">producer</span><span class="token punctuation">:</span>    <span class="token key atrule">group</span><span class="token punctuation">:</span> group_rocketmq</code></pre><p>​        设置默认的生产者消费者所属组group。</p><p><strong>步骤③</strong>：使用RocketMQTemplate操作RocketMQ</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageServiceRocketmqImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MessageService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> RocketMQTemplate rocketMQTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>String id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"待发送短信的订单已纳入处理队列（rocketmq），id："</span><span class="token operator">+</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        SendCallback callback <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SendCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span>SendResult sendResult<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息发送成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onException</span><span class="token punctuation">(</span>Throwable e<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消息发送失败！！！！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">;</span>        rocketMQTemplate<span class="token punctuation">.</span><span class="token function">asyncSend</span><span class="token punctuation">(</span><span class="token string">"order_id"</span><span class="token punctuation">,</span>id<span class="token punctuation">,</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        使用asyncSend方法发送异步消息。</p><p><strong>步骤④</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p><pre class=" language-JAVA"><code class="language-JAVA">@Component@RocketMQMessageListener(topic = "order_id",consumerGroup = "group_rocketmq")public class MessageListener implements RocketMQListener<String> &#123;    @Override    public void onMessage(String id) &#123;        System.out.println("已完成短信发送业务(rocketmq)，id："+id);    &#125;&#125;</code></pre><p>​        RocketMQ的监听器必须按照标准格式开发，实现RocketMQListener接口，泛型为消息类型。</p><p>​        使用注解@RocketMQMessageListener定义当前类监听RabbitMQ中指定组、指定名称的消息队列。</p><p><strong>总结</strong></p><ol><li>springboot整合RocketMQ使用RocketMQTemplate对象作为客户端操作消息队列</li><li>操作RocketMQ需要配置RocketMQ服务器地址，默认端口9876</li><li>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@RocketMQMessageListener</li></ol><h4 id="SpringBoot整合Kafka"><a href="#SpringBoot整合Kafka" class="headerlink" title="SpringBoot整合Kafka"></a>SpringBoot整合Kafka</h4><h5 id="安装-6"><a href="#安装-6" class="headerlink" title="安装"></a>安装</h5><p>​        windows版安装包下载地址：<a href="https://kafka.apache.org/downloads">https://</a><a href="https://kafka.apache.org/downloads">kafka.apache.org/downloads</a></p><p>​        下载完毕后得到tgz压缩文件，使用解压缩软件解压缩即可使用，解压后得到如下文件</p><p><img src="img%5Cimage-20220228181442155.png" alt="image-20220228181442155"></p><p>​        建议使用windows版2.8.1版本。</p><p><strong>启动服务器</strong></p><p>​        kafka服务器的功能相当于RocketMQ中的broker，kafka运行还需要一个类似于命名服务器的服务。在kafka安装目录中自带一个类似于命名服务器的工具，叫做zookeeper，它的作用是注册中心，相关知识请到对应课程中学习。</p><pre class=" language-CMD"><code class="language-CMD">zookeeper-server-start.bat ..\..\config\zookeeper.properties        # 启动zookeeperkafka-server-start.bat ..\..\config\server.properties                # 启动kafka</code></pre><p>​        运行bin目录下的windows目录下的zookeeper-server-start命令即可启动注册中心，默认对外服务端口2181。</p><p>​        运行bin目录下的windows目录下的kafka-server-start命令即可启动kafka服务器，默认对外服务端口9092。</p><p><strong>创建主题</strong></p><p>​        和之前操作其他MQ产品相似，kakfa也是基于主题操作，操作之前需要先初始化topic。</p><pre class=" language-CMD"><code class="language-CMD"># 创建topickafka-topics.bat --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic itheima# 查询topickafka-topics.bat --zookeeper 127.0.0.1:2181 --list                    # 删除topickafka-topics.bat --delete --zookeeper localhost:2181 --topic itheima</code></pre><p><strong>测试服务器启动状态</strong></p><p>​        Kafka提供有一套测试服务器功能的测试程序，运行bin目录下的windows目录下的命令即可使用。</p><pre class=" language-CMD"><code class="language-CMD">kafka-console-producer.bat --broker-list localhost:9092 --topic itheima                            # 测试生产消息kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic itheima --from-beginning    # 测试消息消费</code></pre><h5 id="整合-4"><a href="#整合-4" class="headerlink" title="整合"></a>整合</h5><p><strong>步骤①</strong>：导入springboot整合Kafka的starter，此坐标由springboot维护版本</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p><strong>步骤②</strong>：配置Kafka的服务器地址</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">kafka</span><span class="token punctuation">:</span>    <span class="token key atrule">bootstrap-servers</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">9092</span>    <span class="token key atrule">consumer</span><span class="token punctuation">:</span>      <span class="token key atrule">group-id</span><span class="token punctuation">:</span> order</code></pre><p>​        设置默认的生产者消费者所属组id。</p><p><strong>步骤③</strong>：使用KafkaTemplate操作Kafka</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MessageServiceKafkaImpl</span> <span class="token keyword">implements</span> <span class="token class-name">MessageService</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> KafkaTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> kafkaTemplate<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>String id<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"待发送短信的订单已纳入处理队列（kafka），id："</span><span class="token operator">+</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>        kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"itheima2022"</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        使用send方法发送消息，需要传入topic名称。</p><p><strong>步骤④</strong>：使用消息监听器在服务器启动后，监听指定位置，当消息出现后，立即消费消息</p><pre class=" language-JAVA"><code class="language-JAVA">@Componentpublic class MessageListener &#123;    @KafkaListener(topics = "itheima2022")    public void onMessage(ConsumerRecord<String,String> record)&#123;        System.out.println("已完成短信发送业务(kafka)，id："+record.value());    &#125;&#125;</code></pre><p>​        使用注解@KafkaListener定义当前方法监听Kafka中指定topic的消息，接收到的消息封装在对象ConsumerRecord中，获取数据从ConsumerRecord对象中获取即可。</p><p><strong>总结</strong></p><ol><li><p>springboot整合Kafka使用KafkaTemplate对象作为客户端操作消息队列</p></li><li><p>操作Kafka需要配置Kafka服务器地址，默认端口9092</p></li><li><p>企业开发时通常使用监听器来处理消息队列中的消息，设置监听器使用注解@KafkaListener。接收消息保存在形参ConsumerRecord对象中</p></li></ol><h2 id="KF-6-监控"><a href="#KF-6-监控" class="headerlink" title="KF-6.监控"></a>KF-6.监控</h2><p>​        在说监控之前，需要回顾一下软件业的发展史。最早的软件完成一些非常简单的功能，代码不多，错误也少。随着软件功能的逐步完善，软件的功能变得越来越复杂，功能不能得到有效的保障，这个阶段出现了针对软件功能的检测，也就是软件测试。伴随着计算机操作系统的逐步升级，软件的运行状态也变得开始让人捉摸不透，出现了不稳定的状况。伴随着计算机网络的发展，程序也从单机状态切换成基于计算机网络的程序，应用于网络的程序开始出现，由于网络的不稳定性，程序的运行状态让使用者更加堪忧。互联网的出现彻底打破了软件的思维模式，随之而来的互联网软件就更加凸显出应对各种各样复杂的网络情况之下的弱小。计算机软件的运行状况已经成为了软件运行的一个大话题，针对软件的运行状况就出现了全新的思维，建立起了初代的软件运行状态监控。</p><p>​        什么是监控？就是通过软件的方式展示另一个软件的运行情况，运行的情况则通过各种各样的指标数据反馈给监控人员。例如网络是否顺畅、服务器是否在运行、程序的功能是否能够整百分百运行成功，内存是否够用，等等等等。</p><p>​        本章要讲解的监控就是对软件的运行情况进行监督，但是springboot程序与非springboot程序的差异还是很大的，为了方便监控软件的开发，springboot提供了一套功能接口，为开发者加速开发过程。</p><h3 id="KF-6-1-监控的意义"><a href="#KF-6-1-监控的意义" class="headerlink" title="KF-6-1.监控的意义"></a>KF-6-1.监控的意义</h3><p>​        对于现代的互联网程序来说，规模越来越大，功能越来越复杂，还要追求更好的客户体验，因此要监控的信息量也就比较大了。由于现在的互联网程序大部分都是基于微服务的程序，一个程序的运行需要若干个服务来保障，因此第一个要监控的指标就是服务是否正常运行，也就是<strong>监控服务状态是否处理宕机状态</strong>。一旦发现某个服务宕机了，必须马上给出对应的解决方案，避免整体应用功能受影响。其次，由于互联网程序服务的客户量是巨大的，当客户的请求在短时间内集中达到服务器后，就会出现各种程序运行指标的波动。比如内存占用严重，请求无法及时响应处理等，这就是第二个要监控的重要指标，<strong>监控服务运行指标</strong>。虽然软件是对外提供用户的访问需求，完成对应功能的，但是后台的运行是否平稳，是否出现了不影响客户使用的功能隐患，这些也是要密切监控的，此时就需要在不停机的情况下，监控系统运行情况，日志是一个不错的手段。如果在众多日志中找到开发者或运维人员所关注的日志信息，简单快速有效的过滤出要看的日志也是监控系统需要考虑的问题，这就是第三个要监控的指标，<strong>监控程序运行日志</strong>。虽然我们期望程序一直平稳运行，但是由于突发情况的出现，例如服务器被攻击、服务器内存溢出等情况造成了服务器宕机，此时当前服务不能满足使用需要，就要将其重启甚至关闭，如果快速控制服务器的启停也是程序运行过程中不可回避的问题，这就是第四个监控项，<strong>管理服务状态</strong>。以上这些仅仅是从大的方面来思考监控这个问题，还有很多的细节点，例如上线了一个新功能，定时提醒用户续费，这种功能不是上线后马上就运行的，但是当前功能是否真的启动，如果快速的查询到这个功能已经开启，这也是监控中要解决的问题，等等。看来监控真的是一项非常重要的工作。</p><p>​        通过上述描述，可以看出监控很重要。那具体的监控要如何开展呢？还要从实际的程序运行角度出发。比如现在有3个服务支撑着一个程序的运行，每个服务都有自己的运行状态。</p><img src="img\image-20220301093704396.png" alt="image-20220301093704396" style="zoom:50%;" /><p>​        此时被监控的信息就要在三个不同的程序中去查询并展示，但是三个服务是服务于一个程序的运行的，如果不能合并到一个平台上展示，监控工作量巨大，而且信息对称性差，要不停的在三个监控端查看数据。如果将业务放大成30个，300个，3000个呢？看来必须有一个单独的平台，将多个被监控的服务对应的监控指标信息汇总在一起，这样更利于监控工作的开展。</p><img src="img\image-20220301094001896.png" alt="image-20220301094001896" style="zoom:50%;" /><p>​        新的程序专门用来监控，新的问题就出现了，是被监控程序主动上报信息还是监控程序主动获取信息？如果监控程序不能主动获取信息，这就意味着监控程序有可能看到的是很久之前被监控程序上报的信息，万一被监控程序宕机了，监控程序就无法区分究竟是好久没法信息了，还是已经下线了。所以监控程序必须具有主动发起请求获取被监控服务信息的能力。</p><img src="img\image-20220301094259844.png" alt="image-20220301094259844" style="zoom:50%;" /><p>​        如果监控程序要监控服务时，主动获取对方的信息。那监控程序如何知道哪些程序被自己监控呢？不可能在监控程序中设置我监控谁，这样互联网上的所有程序岂不是都可以被监控到，这样的话信息安全将无法得到保障。合理的做法只能是在被监控程序启动时上报监控程序，告诉监控程序你可以监控我了。看来需要在被监控程序端做主动上报的操作，这就要求被监控程序中配置对应的监控程序是谁。</p><img src="img\image-20220301094547748.png" alt="image-20220301094547748" style="zoom:50%;" /><p>​        被监控程序可以提供各种各样的指标数据给监控程序看，但是每一个指标都代表着公司的机密信息，并不是所有的指标都可以给任何人看的，乃至运维人员，所以对被监控指标的是否开放出来给监控系统看，也需要做详细的设定。</p><p>​        以上描述的整个过程就是一个监控系统的基本流程。</p><p><strong>总结</strong></p><ol><li>监控是一个非常重要的工作，是保障程序正常运行的基础手段</li><li>监控的过程通过一个监控程序进行，它汇总所有被监控的程序的信息集中统一展示</li><li>被监控程序需要主动上报自己被监控，同时要设置哪些指标被监控</li></ol><p><strong>思考</strong></p><p>​        下面就要开始做监控了，新的问题就来了，监控程序怎么做呢？难道要自己写吗？肯定是不现实的，如何进行监控，咱们下节再讲。</p><h3 id="KF-6-2-可视化监控平台"><a href="#KF-6-2-可视化监控平台" class="headerlink" title="KF-6-2.可视化监控平台"></a>KF-6-2.可视化监控平台</h3><p>​        springboot抽取了大部分监控系统的常用指标，提出了监控的总思想。然后就有好心的同志根据监控的总思想，制作了一个通用性很强的监控系统，因为是基于springboot监控的核心思想制作的，所以这个程序被命名为<strong>Spring Boot Admin</strong>。</p><p>​        Spring Boot Admin，这是一个开源社区项目，用于管理和监控SpringBoot应用程序。这个项目中包含有客户端和服务端两部分，而监控平台指的就是服务端。我们做的程序如果需要被监控，将我们做的程序制作成客户端，然后配置服务端地址后，服务端就可以通过HTTP请求的方式从客户端获取对应的信息，并通过UI界面展示对应信息。</p><p>​        下面就来开发这套监控程序，先制作服务端，其实服务端可以理解为是一个web程序，收到一些信息后展示这些信息。</p><p><strong>服务端开发</strong></p><p><strong>步骤①</strong>：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>de.codecentric<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-admin-starter-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.5.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>​        上述过程可以通过创建项目时使用勾选的形式完成。</p><img src="img\image-20220301102432817.png" alt="image-20220301102432817" style="zoom:50%;" /><p><strong>步骤②</strong>：在引导类上添加注解@EnableAdminServer，声明当前应用启动后作为SpringBootAdmin的服务器使用</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token annotation punctuation">@EnableAdminServer</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Springboot25AdminServerApplication</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Springboot25AdminServerApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        做到这里，这个服务器就开发好了，启动后就可以访问当前程序了，界面如下。</p><img src="img\image-20220301103028468.png" alt="image-20220301103028468" style="zoom: 50%;" /><p>​        由于目前没有启动任何被监控的程序，所以里面什么信息都没有。下面制作一个被监控的客户端程序。</p><p><strong>客户端开发</strong></p><p>​        客户端程序开发其实和服务端开发思路基本相似，多了一些配置而已。</p><p><strong>步骤①</strong>：导入springboot admin对应的starter，版本与当前使用的springboot版本保持一致，并将其配置成web工程</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>de.codecentric<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-admin-starter-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.5.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>​        上述过程也可以通过创建项目时使用勾选的形式完成，不过一定要小心，端口配置成不一样的，否则会冲突。</p><p><strong>步骤②</strong>：设置当前客户端将信息上传到哪个服务器上，通过yml文件配置</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">boot</span><span class="token punctuation">:</span>    <span class="token key atrule">admin</span><span class="token punctuation">:</span>      <span class="token key atrule">client</span><span class="token punctuation">:</span>        <span class="token key atrule">url</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">8080</span></code></pre><p>​        做到这里，这个客户端就可以启动了。启动后再次访问服务端程序，界面如下。</p><img src="img\image-20220301103838079.png" alt="image-20220301103838079" style="zoom: 50%;" /><p>​        可以看到，当前监控了1个程序，点击进去查看详细信息。</p><img src="img\image-20220301103936386.png" alt="image-20220301103936386" style="zoom: 50%;" /><p>​        由于当前没有设置开放哪些信息给监控服务器，所以目前看不到什么有效的信息。下面需要做两组配置就可以看到信息了。</p><ol><li><p>开放指定信息给服务器看</p></li><li><p>允许服务器以HTTP请求的方式获取对应的信息</p><p>配置如下：</p></li></ol><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">boot</span><span class="token punctuation">:</span>    <span class="token key atrule">admin</span><span class="token punctuation">:</span>      <span class="token key atrule">client</span><span class="token punctuation">:</span>        <span class="token key atrule">url</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//localhost<span class="token punctuation">:</span><span class="token number">8080</span><span class="token key atrule">management</span><span class="token punctuation">:</span>  <span class="token key atrule">endpoint</span><span class="token punctuation">:</span>    <span class="token key atrule">health</span><span class="token punctuation">:</span>      <span class="token key atrule">show-details</span><span class="token punctuation">:</span> always  <span class="token key atrule">endpoints</span><span class="token punctuation">:</span>    <span class="token key atrule">web</span><span class="token punctuation">:</span>      <span class="token key atrule">exposure</span><span class="token punctuation">:</span>        <span class="token key atrule">include</span><span class="token punctuation">:</span> <span class="token string">"*"</span></code></pre><p>​        上述配置对于初学者来说比较容易混淆。简单解释一下，到下一节再做具体的讲解。springbootadmin的客户端默认开放了13组信息给服务器，但是这些信息除了一个之外，其他的信息都不让通过HTTP请求查看。所以你看到的信息基本上就没什么内容了，只能看到一个内容，就是下面的健康信息。</p><img src="img\image-20220301104742563.png" alt="image-20220301104742563" style="zoom: 50%;" /><p>​        但是即便如此我们看到健康信息中也没什么内容，原因在于健康信息中有一些信息描述了你当前应用使用了什么技术等信息，如果无脑的对外暴露功能会有安全隐患。通过配置就可以开放所有的健康信息明细查看了。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">management</span><span class="token punctuation">:</span>  <span class="token key atrule">endpoint</span><span class="token punctuation">:</span>    <span class="token key atrule">health</span><span class="token punctuation">:</span>      <span class="token key atrule">show-details</span><span class="token punctuation">:</span> always</code></pre><p>​        健康明细信息如下：</p><img src="img\image-20220301105116554.png" alt="image-20220301105116554" style="zoom: 50%;" /><p>​        目前除了健康信息，其他信息都查阅不了。原因在于其他12种信息是默认不提供给服务器通过HTTP请求查阅的，所以需要开启查阅的内容项，使用*表示查阅全部。记得带引号。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">endpoints</span><span class="token punctuation">:</span>  <span class="token key atrule">web</span><span class="token punctuation">:</span>    <span class="token key atrule">exposure</span><span class="token punctuation">:</span>      <span class="token key atrule">include</span><span class="token punctuation">:</span> <span class="token string">"*"</span></code></pre><p>​        配置后再刷新服务器页面，就可以看到所有的信息了。</p><img src="img\image-20220301105554494.png" alt="image-20220301105554494" style="zoom: 50%;" /><p>​        以上界面中展示的信息量就非常大了，包含了13组信息，有性能指标监控，加载的bean列表，加载的系统属性，日志的显示控制等等。</p><p><strong>配置多个客户端</strong></p><p>​        可以通过配置客户端的方式在其他的springboot程序中添加客户端坐标，这样当前服务器就可以监控多个客户端程序了。每个客户端展示不同的监控信息。</p><img src="img\image-20220301110352170.png" alt="image-20220301110352170" style="zoom: 50%;" /><p>​        进入监控面板，如果你加载的应用具有功能，在监控面板中可以看到3组信息展示的与之前加载的空工程不一样。</p><ul><li>类加载面板中可以查阅到开发者自定义的类，如左图</li></ul><p>​                        <img src="img\image-20220301161246835.png" alt="image-20220301161246835" style="zoom:33%;" /><img src="img\image-20220301161949431.png" alt="image-20220301161949431" style="zoom:33%;" /></p><ul><li>映射中可以查阅到当前应用配置的所有请求</li></ul><p>​                        <img src="img\image-20220301161418791.png" alt="image-20220301161418791" style="zoom: 33%;" /><img src="img\image-20220301162008737.png" alt="image-20220301162008737" style="zoom:33%;" /></p><ul><li>性能指标中可以查阅当前应用独有的请求路径统计数据</li></ul><p>​                        <img src="img\image-20220301161906949.png" alt="image-20220301161906949" style="zoom: 33%;" /><img src="img\image-20220301162040670.png" alt="image-20220301162040670" style="zoom: 33%;" /></p><p><strong>总结</strong></p><ol><li>开发监控服务端需要导入坐标，然后在引导类上添加注解@EnableAdminServer，并将其配置成web程序即可</li><li>开发被监控的客户端需要导入坐标，然后配置服务端服务器地址，并做开放指标的设定即可</li><li>在监控平台中可以查阅到各种各样被监控的指标，前提是客户端开放了被监控的指标</li></ol><p><strong>思考</strong></p><p>​        之前说过，服务端要想监控客户端，需要主动的获取到对应信息并展示出来。但是目前我们并没有在客户端开发任何新的功能，但是服务端确可以获取监控信息，谁帮我们做的这些功能呢？咱们下一节再讲。</p><h3 id="KF-6-3-监控原理"><a href="#KF-6-3-监控原理" class="headerlink" title="KF-6-3.监控原理"></a>KF-6-3.监控原理</h3><p>​        通过查阅监控中的映射指标，可以看到当前系统中可以运行的所有请求路径，其中大部分路径以/actuator开头</p><img src="img\image-20220301170214076.png" alt="image-20220301170214076" style="zoom: 50%;" /><p>​        首先这些请求路径不是开发者自己编写的，其次这个路径代表什么含义呢？既然这个路径可以访问，就可以通过浏览器发送该请求看看究竟可以得到什么信息。</p><p><img src="img%5Cimage-20220301170723057.png" alt="image-20220301170723057"></p><p>​        通过发送请求，可以得到一组json信息，如下</p><pre class=" language-json"><code class="language-json">&amp;#<span class="token number">123</span><span class="token punctuation">;</span>    <span class="token property">"_links"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>        <span class="token property">"self"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"beans"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/beans"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"caches-cache"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/caches/&amp;#123;cache&amp;#125;"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"caches"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/caches"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"health"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/health"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"health-path"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/health/&amp;#123;*path&amp;#125;"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"info"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/info"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"conditions"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/conditions"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"shutdown"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/shutdown"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"configprops"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/configprops"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"configprops-prefix"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/configprops/&amp;#123;prefix&amp;#125;"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"env"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/env"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"env-toMatch"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/env/&amp;#123;toMatch&amp;#125;"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"loggers"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/loggers"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"loggers-name"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/loggers/&amp;#123;name&amp;#125;"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"heapdump"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/heapdump"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"threaddump"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/threaddump"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"metrics-requiredMetricName"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/metrics/&amp;#123;requiredMetricName&amp;#125;"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">true</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"metrics"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/metrics"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"scheduledtasks"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/scheduledtasks"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">,</span>        <span class="token property">"mappings"</span><span class="token operator">:</span> &amp;#<span class="token number">123</span><span class="token punctuation">;</span>            <span class="token property">"href"</span><span class="token operator">:</span> <span class="token string">"http://localhost:81/actuator/mappings"</span><span class="token punctuation">,</span>            <span class="token property">"templated"</span><span class="token operator">:</span> <span class="token boolean">false</span>        &amp;#<span class="token number">125</span><span class="token punctuation">;</span>    &amp;#<span class="token number">125</span><span class="token punctuation">;</span>&amp;#<span class="token number">125</span><span class="token punctuation">;</span></code></pre><p>​        其中每一组数据都有一个请求路径，而在这里请求路径中有之前看到过的health，发送此请求又得到了一组信息</p><pre class=" language-JSON"><code class="language-JSON">&#123;    "status": "UP",    "components": &#123;        "diskSpace": &#123;            "status": "UP",            "details": &#123;                "total": 297042808832,                "free": 72284409856,                "threshold": 10485760,                "exists": true            &#125;        &#125;,        "ping": &#123;            "status": "UP"        &#125;    &#125;&#125;</code></pre><p>​        当前信息与监控面板中的数据存在着对应关系</p><img src="img\image-20220301171025615.png" alt="image-20220301171025615" style="zoom:50%;" /><p>​        原来监控中显示的信息实际上是通过发送请求后得到json数据，然后展示出来。按照上述操作，可以发送更多的以/actuator开头的链接地址，获取更多的数据，这些数据汇总到一起组成了监控平台显示的所有数据。</p><p>​        到这里我们得到了一个核心信息，监控平台中显示的信息实际上是通过对被监控的应用发送请求得到的。那这些请求谁开发的呢？打开被监控应用的pom文件，其中导入了springboot admin的对应的client，在这个资源中导入了一个名称叫做actuator的包。被监控的应用之所以可以对外提供上述请求路径，就是因为添加了这个包。</p><p><img src="img%5Cimage-20220301171437817.png" alt="image-20220301171437817"></p><p>​        这个actuator是什么呢？这就是本节要讲的核心内容，监控的端点。</p><p>​        Actuator，可以称为端点，描述了一组监控信息，SpringBootAdmin提供了多个内置端点，通过访问端点就可以获取对应的监控信息，也可以根据需要自定义端点信息。通过发送请求路劲**/actuator<strong>可以访问应用所有端点信息，如果端点中还有明细信息可以发送请求</strong>/actuator/端点名称**来获取详细信息。以下列出了所有端点信息说明：</p><table><thead><tr><th>ID</th><th>描述</th><th>默认启用</th></tr></thead><tbody><tr><td>auditevents</td><td>暴露当前应用程序的审计事件信息。</td><td>是</td></tr><tr><td>beans</td><td>显示应用程序中所有 Spring bean 的完整列表。</td><td>是</td></tr><tr><td>caches</td><td>暴露可用的缓存。</td><td>是</td></tr><tr><td>conditions</td><td>显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。</td><td>是</td></tr><tr><td>configprops</td><td>显示所有 @ConfigurationProperties 的校对清单。</td><td>是</td></tr><tr><td>env</td><td>暴露 Spring ConfigurableEnvironment 中的属性。</td><td>是</td></tr><tr><td>flyway</td><td>显示已应用的 Flyway 数据库迁移。</td><td>是</td></tr><tr><td>health</td><td>显示应用程序健康信息</td><td>是</td></tr><tr><td>httptrace</td><td>显示 HTTP 追踪信息（默认情况下，最后 100 个  HTTP 请求/响应交换）。</td><td>是</td></tr><tr><td>info</td><td>显示应用程序信息。</td><td>是</td></tr><tr><td>integrationgraph</td><td>显示 Spring Integration 图。</td><td>是</td></tr><tr><td>loggers</td><td>显示和修改应用程序中日志记录器的配置。</td><td>是</td></tr><tr><td>liquibase</td><td>显示已应用的 Liquibase 数据库迁移。</td><td>是</td></tr><tr><td>metrics</td><td>显示当前应用程序的指标度量信息。</td><td>是</td></tr><tr><td>mappings</td><td>显示所有 @RequestMapping 路径的整理清单。</td><td>是</td></tr><tr><td>scheduledtasks</td><td>显示应用程序中的调度任务。</td><td>是</td></tr><tr><td>sessions</td><td>允许从 Spring Session 支持的会话存储中检索和删除用户会话。当使用 Spring Session 的响应式 Web 应用程序支持时不可用。</td><td>是</td></tr><tr><td>shutdown</td><td>正常关闭应用程序。</td><td>否</td></tr><tr><td>threaddump</td><td>执行线程 dump。</td><td>是</td></tr><tr><td>heapdump</td><td>返回一个 hprof 堆 dump 文件。</td><td>是</td></tr><tr><td>jolokia</td><td>通过 HTTP 暴露 JMX bean（当  Jolokia 在 classpath 上时，不适用于 WebFlux）。</td><td>是</td></tr><tr><td>logfile</td><td>返回日志文件的内容（如果已设置 logging.file 或 logging.path 属性）。支持使用 HTTP Range 头来检索部分日志文件的内容。</td><td>是</td></tr><tr><td>prometheus</td><td>以可以由 Prometheus 服务器抓取的格式暴露指标。</td><td>是</td></tr></tbody></table><p>​        上述端点每一项代表被监控的指标，如果对外开放则监控平台可以查询到对应的端点信息，如果未开放则无法查询对应的端点信息。通过配置可以设置端点是否对外开放功能。使用enable属性控制端点是否对外开放。其中health端点为默认端点，不能关闭。</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">management</span><span class="token punctuation">:</span>  <span class="token key atrule">endpoint</span><span class="token punctuation">:</span>    <span class="token key atrule">health</span><span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true"># 端点名称</span>      <span class="token key atrule">show-details</span><span class="token punctuation">:</span> always    <span class="token key atrule">info</span><span class="token punctuation">:</span>                        <span class="token comment" spellcheck="true"># 端点名称</span>      <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true                </span><span class="token comment" spellcheck="true"># 是否开放</span></code></pre><p>​        为了方便开发者快速配置端点，springboot admin设置了13个较为常用的端点作为默认开放的端点，如果需要控制默认开放的端点的开放状态，可以通过配置设置，如下：</p><pre class=" language-YAML"><code class="language-YAML">management:  endpoints:    enabled-by-default: true    # 是否开启默认端点，默认值true</code></pre><p>​        上述端点开启后，就可以通过端点对应的路径查看对应的信息了。但是此时还不能通过HTTP请求查询此信息，还需要开启通过HTTP请求查询的端点名称，使用“*”可以简化配置成开放所有端点的WEB端HTTP请求权限。</p><pre class=" language-YAML"><code class="language-YAML">management:  endpoints:    web:      exposure:        include: "*"</code></pre><p>​        整体上来说，对于端点的配置有两组信息，一组是endpoints开头的，对所有端点进行配置，一组是endpoint开头的，对具体端点进行配置。</p><pre class=" language-YAML"><code class="language-YAML">management:  endpoint:        # 具体端点的配置    health:      show-details: always    info:      enabled: true  endpoints:    # 全部端点的配置    web:      exposure:        include: "*"    enabled-by-default: true</code></pre><p><strong>总结</strong></p><ol><li><p>被监控客户端通过添加actuator的坐标可以对外提供被访问的端点功能</p></li><li><p>端点功能的开放与关闭可以通过配置进行控制</p></li><li><p>web端默认无法获取所有端点信息，通过配置开放端点功能</p></li></ol><h3 id="KF-6-4-自定义监控指标"><a href="#KF-6-4-自定义监控指标" class="headerlink" title="KF-6-4.自定义监控指标"></a>KF-6-4.自定义监控指标</h3><p>​        端点描述了被监控的信息，除了系统默认的指标，还可以自行添加显示的指标，下面就通过3种不同的端点的指标自定义方式来学习端点信息的二次开发。</p><p><strong>INFO端点</strong></p><p>​        info端点描述了当前应用的基本信息，可以通过两种形式快速配置info端点的信息</p><ul><li><p>配置形式</p><p>在yml文件中通过设置info节点的信息就可以快速配置端点信息</p><pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">info</span><span class="token punctuation">:</span>  <span class="token key atrule">appName</span><span class="token punctuation">:</span> @project.artifactId@  <span class="token key atrule">version</span><span class="token punctuation">:</span> @project.version@  <span class="token key atrule">company</span><span class="token punctuation">:</span> 传智教育  <span class="token key atrule">author</span><span class="token punctuation">:</span> itheima</code></pre><p>配置完毕后，对应信息显示在监控平台上</p><img src="img\image-20220301174133248.png" alt="image-20220301174133248" style="zoom:50%;" /><p>也可以通过请求端点信息路径获取对应json信息</p><img src="img\image-20220301174241310.png" alt="image-20220301174241310" style="zoom:50%;" /></li><li><p>编程形式</p><p>通过配置的形式只能添加固定的数据，如果需要动态数据还可以通过配置bean的方式为info端点添加信息，此信息与配置信息共存</p><pre class=" language-JAVA"><code class="language-JAVA">@Componentpublic class InfoConfig implements InfoContributor &#123;    @Override    public void contribute(Info.Builder builder) &#123;        builder.withDetail("runTime",System.currentTimeMillis());        //添加单个信息        Map infoMap = new HashMap();                infoMap.put("buildTime","2006");        builder.withDetails(infoMap);                                    //添加一组信息    &#125;&#125;</code></pre></li></ul><p><strong>Health端点</strong></p><p>​        health端点描述当前应用的运行健康指标，即应用的运行是否成功。通过编程的形式可以扩展指标信息。</p><pre class=" language-JAVA"><code class="language-JAVA">@Componentpublic class HealthConfig extends AbstractHealthIndicator &#123;    @Override    protected void doHealthCheck(Health.Builder builder) throws Exception &#123;        boolean condition = true;        if(condition) &#123;            builder.status(Status.UP);                    //设置运行状态为启动状态            builder.withDetail("runTime", System.currentTimeMillis());            Map infoMap = new HashMap();            infoMap.put("buildTime", "2006");            builder.withDetails(infoMap);        &#125;else&#123;            builder.status(Status.OUT_OF_SERVICE);        //设置运行状态为不在服务状态            builder.withDetail("上线了吗？","你做梦");        &#125;    &#125;&#125;</code></pre><p>​        当任意一个组件状态不为UP时，整体应用对外服务状态为非UP状态。</p><img src="img\image-20220301174751845.png" alt="image-20220301174751845" style="zoom:50%;" /><p><strong>Metrics端点</strong></p><p>​        metrics端点描述了性能指标，除了系统自带的监控性能指标，还可以自定义性能指标。</p><pre class=" language-JAVA"><code class="language-JAVA">@Servicepublic class BookServiceImpl extends ServiceImpl<BookDao, Book> implements IBookService &#123;    @Autowired    private BookDao bookDao;    private Counter counter;    public BookServiceImpl(MeterRegistry meterRegistry)&#123;        counter = meterRegistry.counter("用户付费操作次数：");    &#125;    @Override    public boolean delete(Integer id) &#123;        //每次执行删除业务等同于执行了付费业务        counter.increment();        return bookDao.deleteById(id) > 0;    &#125;&#125;</code></pre><p>​        在性能指标中就出现了自定义的性能指标监控项</p><img src="img\image-20220301175101812.png" alt="image-20220301175101812" style="zoom:50%;" /><p><strong>自定义端点</strong></p><p>​        可以根据业务需要自定义端点，方便业务监控</p><pre class=" language-JAVA"><code class="language-JAVA">@Component@Endpoint(id="pay",enableByDefault = true)public class PayEndpoint &#123;    @ReadOperation    public Object getPay()&#123;        Map payMap = new HashMap();        payMap.put("level 1","300");        payMap.put("level 2","291");        payMap.put("level 3","666");        return payMap;    &#125;&#125;</code></pre><p>​        由于此端点数据spirng boot admin无法预知该如何展示，所以通过界面无法看到此数据，通过HTTP请求路径可以获取到当前端点的信息，但是需要先开启当前端点对外功能，或者设置当前端点为默认开发的端点。</p><img src="img\image-20220301175355482.png" alt="image-20220301175355482" style="zoom:50%;" /><p><strong>总结</strong></p><ol><li>端点的指标可以自定义，但是每种不同的指标根据其功能不同，自定义方式不同</li><li>info端点通过配置和编程的方式都可以添加端点指标</li><li>health端点通过编程的方式添加端点指标，需要注意要为对应指标添加启动状态的逻辑设定</li><li>metrics指标通过在业务中添加监控操作设置指标</li><li>可以自定义端点添加更多的指标</li></ol><h2 id="开发实用篇完结"><a href="#开发实用篇完结" class="headerlink" title="开发实用篇完结"></a>开发实用篇完结</h2><p>​        开发实用篇到这里就暂时完结了，在开发实用篇中我们讲解了大量的第三方技术的整合方案，选择的方案都是市面上比较流行的常用方案，还有一些国内流行度较低的方案目前还没讲，留到番外篇中慢慢讲吧。</p><p>​        整体开发实用篇中讲解的内容可以分为两大类知识：实用性知识与经验性知识。</p><p>​        实用性知识就是新知识了，springboot整合各种技术，每种技术整合中都有一些特殊操作，整体来说其实就是三句话。加坐标做配置调接口。经验性知识是对前面两篇中出现的一些知识的补充，在学习基础篇时如果将精力放在这些东西上就有点学偏了，容易钻牛角尖，放到实用开发篇中结合实际开发说一些不常见的但是对系统功能又危害的操作解决方案，提升理解。</p><p>​        开发实用篇做到这里就告一段落，下面就要着手准备原理篇了。市面上很多课程原理篇讲的过于高深莫测，在新手还没明白123的时候就开始讲微积分了，着实让人看了着急。至于原理篇我讲成什么样子？一起期待吧。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx卸载和安装</title>
      <link href="/c-sin7/lhsin.cn/2022/02/21/%E5%8D%B8%E8%BD%BDnginx/"/>
      <url>/c-sin7/lhsin.cn/2022/02/21/%E5%8D%B8%E8%BD%BDnginx/</url>
      
        <content type="html"><![CDATA[<h2 id="nginx卸载和安装"><a href="#nginx卸载和安装" class="headerlink" title="nginx卸载和安装"></a>nginx卸载和安装</h2><p>本机环境：CentOS 7.6 ，使用yum安装的Nginx</p><p>1、查看nginx服务是否在运行。</p><pre class=" language-BASH"><code class="language-BASH"> ps -ef | grep nginx</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230221185727539.png" alt="image-20230221185727539" style="zoom:80%;" /><p>2、查看nginx安装目录（注意目录）</p><pre class=" language-bash"><code class="language-bash"><span class="token function">whereis</span> nginx</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230221185825023.png" alt="image-20230221185825023" style="zoom:80%;" /><p>3、终止nginx服务运行</p><pre class=" language-bash"><code class="language-bash">/usr/local/nginx-webServer/sbin/nginx -s stop</code></pre><p>再次查看后，服务已经终止</p><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230221185908842.png" alt="image-20230221185908842" style="zoom:80%;" /><p>4、全局查找nginx相关的文件：</p><pre class=" language-bash"><code class="language-bash"><span class="token function">find</span> / -name nginx*</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230221185937683.png" alt="image-20230221185937683" style="zoom:80%;" /><p>5、对相关文件（第二步骤的查询结果）进行删除</p><pre class=" language-bash"><code class="language-bash"><span class="token function">rm</span> -rf <span class="token function">file</span> /usr/bin/nginx*<span class="token function">rm</span> -rf <span class="token function">file</span> /usr/local/nginx*</code></pre><p>6、使用yum卸载 nginx及相关依赖</p><pre class=" language-bash"><code class="language-bash">yum remove nginx</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230221190125106.png" alt="image-20230221190125106" style="zoom:80%;" /><p>如果提示”This system is not registered with an entitlement server. You can use subscription-manager”，原因：Red Hat Subscription Manager订阅管理器，它会让你一直register。</p><p>解决：停止掉该插件的使用，在配置文件中把enable=0即可。</p><pre class=" language-bash"><code class="language-bash">vim /etc/yum/pluginconf.d/subscription-manager.conf</code></pre><img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230221190800936.png" alt="image-20230221190800936" style="zoom:80%;" /><p>到此，nginx卸载删除完成。</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> CentOS </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
