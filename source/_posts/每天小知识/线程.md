---
title: 线程
author: sin
categories: 小知识 
tags: 
  - 线程
---

### 线程

线程包括以下这几个状态：

创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting（睡眠或等待一定的事件）、waiting（等待被唤醒）、消亡（dead）

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/682616-20161115183635779-1231872003.jpg" alt="img" style="zoom: 67%;" />

注意点：

1、当线程进入就绪状态后，不代表立刻就能获取CPU执行时间

2、如果调用了sleep方法，必须捕获InterruptedException异常或者将该异常向上层抛出。当线程睡眠时间满后，不一定会立即得到执行，因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。

3、调用yield方法并不会让线程进入阻塞状态，而是让线程**重回就绪**状态，它只需要等待重新获取CPU执行时间，这一点是和sleep方法不一样的。

4、wait方法会让线程进入阻塞状态，并且会释放线程占有的锁，并交出CPU执行权限。

5、调用join方法实际上是调用了Object的wait方法。由于wait方法会让线程释放对象锁，所以join方法同样会让线程释放对一个对象持有的锁。







### Thread类中常用的方法：

以下是关系到线程 *运行状态* 的几个方法：

1）start方法

start()用来启动一个线程，当调用start方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。

2）run方法

run()方法是不需要用户来调用的，当通过start方法启动一个线程之后，当线程获得了CPU执行时间，便进入run方法体去执行具体的任务。注意**，继承Thread类必须重写run方法**，在run方法中定义具体要执行的任务。

3）sleep方法

sleep方法有两个重载版本：

```
sleep(long millis)     //参数为毫秒
sleep(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒
```

sleep相当于让线程睡眠，交出CPU，让CPU去执行其他的任务。

但是有一点要非常注意，sleep方法不会释放锁，也就是说如果当前线程持有对某个对象的锁，则即使调用sleep方法，其他线程也无法访问这个对象。

4）yield方法

调用yield方法会让**当前线程交出CPU权限**，让CPU去执行其他的线程。它跟sleep方法类似，同样**不会释放锁**。但是yield不能控制具体的交出CPU的时间，另外，yield方法只能让<u>拥有相同优先级的线程</u>有获取CPU执行时间的机会。

5）join方法

join方法有三个重载版本：

```
join()
join(long millis)     //参数为毫秒
join(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒
```

假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的事件。

6）interrupt方法

单独调用interrupt方法可以使得处于阻塞状态的线程抛出一个异常，可以用来中断一个正处于阻塞状态的线程；另外，通过interrupt方法和isInterrupted()方法来停止正在运行的线程。

直接调用interrupt方法可以中断处于阻塞状态的线程，但不能中断正在运行中的线程。

如果配合isInterrupted()能够中断正在运行的线程，因为调用interrupt方法相当于将中断标志位置为true，那么可以通过调用isInterrupted()判断中断标志是否被置位来中断线程的执行。

7）stop方法

stop方法已经是一个废弃的方法，它是一个不安全的方法。因为调用stop方法会直接终止run方法的调用，并且会抛出一个ThreadDeath错误，如果线程持有某个对象锁的话，会完全释放锁，导致对象状态不一致。所以stop方法基本是不会被用到的。

8）destroy方法

destroy方法也是废弃的方法。基本不会被使用到。





### 以下是关系到线程属性的几个方法:

1）getId

用来得到线程ID

2）getName和setName

用来得到或者设置线程名称。

3）getPriority和setPriority

用来获取和设置线程优先级。

4）setDaemon和isDaemon

用来设置线程是否成为守护线程和判断线程是否是守护线程。

​	守护线程和用户线程的区别在于：

​	守护线程依赖于创建它的线程，而用户线程则不依赖。

​	举个简单的例子：如果在main线程中创建了一个守护线程，当main方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在JVM中，像垃圾收集器线程就是守护线程。

5）public final boolean isAlive()
测试线程是否处于活动状态。

6）public static void yield()
暂停当前正在执行的线程对象，并执行其他线程

7）currentThread()

用来获取当前线程



### sleep 和 wait 方法解释

sleep()方法是Thread类里面的，主要的意义就是让当前线程停止执行，让出cpu给其他的线程，但是不会释放对象锁资源以及监控的状态，当指定的时间到了之后又会自动恢复运行状态。

wait()方法是Object类里面的，主要的意义就是让线程放弃当前的对象的锁，进入等待此对象的等待锁定池，只有针对此对象调动notify方法后本线程才能够进入对象锁定池准备获取对象锁进入运行状态。





### **start 和 run 方法解释**

1、start：用start方法来启动线程，真正实现了多线程运行，这时<u>无需等待run方法体代码执行完毕而直接继续执行下面的代码</u>。

通过调用Thread类的start()方法来启动一个线程，这时此线程处于**就绪（可运行）**状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法，这里方法 run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程随即终止。
2、run： run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然**只有主线程**这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到写线程的目的。



总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。这两个方法应该都比较熟悉，把需要并行处理的代码放在run()方法中，start()方法启动线程将自动调用 run()方法，这是由jvm的内存机制规定的。并且run()方法必须是public访问权限，返回值类型为void。

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/716271-20170320112245721-1831918220.jpg" alt="img" style="zoom:67%;" />

## 创建一个线程

Java 提供了三种创建线程的方法：

- 通过实现 Runnable 接口；
- 通过继承 Thread 类本身；
- 通过 Callable 和 Future 创建线程。



**实现并启动线程有两种方法**
1、写一个类继承自Thread类，重写run方法。用start方法启动线程
2、写一个类实现Runnable接口，实现run方法。用new Thread(Runnable target).start()方法来启动



**多线程原理：**

**多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发**

相当于玩游戏机，只有一个游戏机（cpu），可是有很多人要玩，于是，start是排队！等CPU选中你就是轮到你，你就run（），当CPU的运行的时间片执行完，这个线程就继续排队，等待下一次的run（）



### 通过实现 Runnable 接口来创建线程

创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。

为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：

```java
public void run()
```

可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。

在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。

Thread 定义了几个构造方法，下面的这个是我们经常使用的：

```java
Thread(Runnable threadOb,String threadName);
```

这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。

新线程创建之后，你调用它的 start() 方法它才会运行。



### 通过继承Thread来创建线程

创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。

继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。

该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。



### 通过 Callable 和 Future 创建线程

- 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
- 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
- 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
- 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。



## 创建线程的三种方式的对比

- 采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。
- 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。









