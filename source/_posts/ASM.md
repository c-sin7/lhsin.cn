---
title: ASM
author: sin
categories: ASM
summary: ASM知识
tags: 
  - ASM
---

### 2.2 INT 21H的1号功能，输入一个字符串"Hello,world",存放在内存，然后倒序输出

```ASM
;2.2 INT 21H的1号功能，输入一个字符串"Hello,world",存放在内存，然后倒序输出
S1 SEGMENT

S1 ENDS

S2 SEGMENT
    DW 30H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
	MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP

	;输入 cx作计数器
    SUB CX,CX
L1: 
	MOV AH,1
    INT 21H
    CMP AL,0DH
    JE  L2
    XOR AH,AH
    PUSH AX
    INC CX
    JMP L1
    
    ;输出
L2: 
	POP DX
    MOV AH,2
    INT 21H
    LOOP L2
    
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN

```

### 2.3 INT 21H的A号功能，输入一个字符串"Hello,world",存放在内存，然后倒序输出

```ASM
;2.3 INT 21H的A号功能，输入一个字符串"Hello,world",存放在内存，然后倒序输出
S1 SEGMENT
	BUFF DB 250,?,250 DUP(?)
	SHOW DB 0DH,0AH,'THE REVERSE STRING IS:$'
S1 ENDS

S2 SEGMENT STACK
    DW 30H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
	MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP

	;输入
	MOV AH,0AH
	INT 21H
	
	MOV SI,DX
	INC SI
	MOV AL,DS:[SI]	;真实数据总个数
	CBW 
	MOV CX,AX		;计数器
	ADD SI,AX		;串尾 不包括ODH	

	;输出
	LEA DX,SHOW
	MOV AH,09H
	INT 21H
L0:	
	MOV DL,DS:[SI]
	MOV AH,2
	INT 21H
	DEC SI
	LOOP L0

EXIT:
	MOV AH,4CH
	INT 21H
MAIN ENDP
S3 ENDS
	END MAIN
```

### 3.1 将 BX 中的无符号数以二进制的形式输出

```ASM
;3.1将 BX 中的无符号数以二进制的形式输出
S1 SEGMENT
    A DW 6C3BH  
S1 ENDS

S2 SEGMENT
	DB 30 DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP
    
    MOV CX,10H
    MOV BX,A
L0: 
	ROL BX,1
    MOV DL,30H
    ADC DL,0
    MOV AH,2
    INT 21H
    LOOP L0

EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN

```

### 3.4 将BX的无符号数以十进制数形式输出

```ASM
;3.4 将 BX 中的无符号数以十进制的形式输出
S1 SEGMENT
    A DW 2A3BH
    CNT DW 0
S1 ENDS

S2 SEGMENT
    DW 30H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP
    
    MOV BX,A
	MOV AX,BX
	MOV CX,0AH
	
	;转化并入栈
	;DX余数 AX商
L0:
	XOR DX,DX
	DIV CX
	PUSH DX		;余数进栈
	INC CNT
	CMP AX,0
	JNE L0
	
	;输出
	MOV CX,CNT
L1:	
	POP DX
	ADD DX,30H
	MOV AH,2
	INT 21H
	LOOP L1

EXIT:   
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN
```

### 3.5 将BX的有符号数以十进制数形式输出

```ASM
;3.5 将BX的有符号数以十进制数形式输出
S1 SEGMENT
	A DW 8000H
S1 ENDS
S2 SEGMENT
	DW 30H DUP(?)
TOP LABEL WORD
S2 ENDS
S3 SEGMENT
	ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
	MOV AX,S1
	MOV DS,AX
	MOV AX,S2
	MOV SS,AX
	LEA SP,TOP
	
	MOV BX,A
	MOV AX,BX
	MOV DI,10
	MOV CX,0
	
	;判断正负数
	CMP AX,0
	JGE L1
	
	NEG AX
	PUSH AX
	MOV DL,'-'
	MOV AH,2
	INT 21H
	POP AX
	
L0:
	XOR DX,DX
	IDIV DI    ;/10
	PUSH DX    ;压余数
	INC CX     ;记录除了几次
	CMP AX,0   ;比较除完了没
	JNE L0
	
L1:
	POP DX
	ADD DX,30H
	MOV AH,2
	INT 21H
	LOOP L1

EXIT:
	MOV AH,4CH
	INT 21H
	
MAIN ENDP
S3 ENDS
	END MAIN
```

### 4.2 输入两个字X,Y，计算Z=X+Y,并把Z的结果显示出来，X,Y的输入可以是任何进制

```ASM
;4.2 输入两个字X,Y，计算Z=X+Y,并把Z的结果显示出来，X,Y的输入可以是任何进制
S1 SEGMENT
    X DW 0
    Y DW 0
    Z DW 0
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP
    
    MOV CX,16
    XOR BX,BX
    
    ;输入并放置在bx
L0: 
	MOV AH,1
    INT 21H
    CMP AL,0DH
    JE  L1
    CMP AL,30H
    JB L0
    CMP AL,31H
    JA L0
    SHR AL,1
    RCL BX,1
    LOOP L0
L1:
	MOV X,BX

	;吸收回车
	MOV AH,1
	INT 21H  
    
    ;输入并放置在bx
L2: 
	MOV AH,1
    INT 21H
    CMP AL,0DH
    JE  L3
    CMP AL,30H
    JB L2
    CMP AL,31H
    JA L2
    SHR AL,1
    RCL BX,1
    LOOP L2
L3:
	MOV Y,BX
	
	
	;两数相加
	MOV DX,X
	MOV BX,Y
	ADD BX,DX
	MOV CX,16
L4:
	ROL BX,1
	MOV DX,30H
	ADC DX,0
	MOV AH,2
	INT 21H
	LOOP L4
    
EXIT:
    MOV AH,4CH
    INT 21H
	
MAIN ENDP
S3 ENDS
    END MAIN

```

### 4.3 输入一个有符号的十进制数，并以十六进制输出

```ASM
;4.3 输入一个有符号的十进制数，并以十六进制输出
S1 SEGMENT
	NUM DW 8000
	F	DW 0
S1 ENDS

S2 SEGMENT
	DW 30H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
	ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
	MOV AX,S1
	MOV DS,AX
	MOV AX,S2
	MOV SS,AX
	LEA SP,TOP
	XOR BX,BX

	CALL READIN
	CMP F,0
	JNE	L3
L3:
	NEG BX
	CALL CHANGE
	
EXIT:	
	MOV AH,4CH
	INT 21H
MAIN ENDP

READIN PROC NEAR
	;输入 判断正负
L0:
	MOV AH,1
	INT 21H
	CMP AL,0DH
	JE  EXIT1
	CMP AL,'-'
	JNE L1
	INC F
	
L1:
	SUB AL,30H
	JL  L0
	CMP AL,9D
	JG	L0

	;->10
	CBW
	XCHG AX,BX
	MOV CX,10D
	MUL CX
	XCHG BX,AX
	ADD BX,AX
	JMP L0
	
EXIT1:
	RET
	
READIN ENDP

CHANGE PROC NEAR
	;10->16
	MOV CX,4
L2:
	PUSH CX
	MOV CL,4
	ROL BX,CL
	MOV DL,BL
	AND DL,0FH
	ADD DL,30H
	CMP DL,39H
	JBE DISP
	ADD DL,7
DISP:
	MOV AH,2
	INT 21H
	POP CX
	LOOP L2
	
	RET
CHANGE ENDP

S3 ENDS
	END MAIN
```



### 5.1 试编写一个汇编语言程序，要求对键盘输入的小写字母用大写字母显示出来

```ASM
;5.1对键盘输入的小写字母用大写字母显示出来
S1 SEGMENT
S1 ENDS

S2 SEGMENT
	DW 30H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
	ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
	MOV AX,S1
	MOV DS,AX
	MOV AX,S2
	MOV SS,AX
	LEA SP,TOP
 
	;输入小写
L1:
	MOV AH,1
	INT 21H
	CMP AL,'a'
	JB L1
	CMP AL,'z'
	JA L1
	MOV BL,AL
	
	MOV DL,0DH
	MOV AH,2
	INT 21H
	MOV DL,0AH
	MOV AH,2
	INT 21H
	
	;变大写输出
	MOV DL,BL
	SUB DL,20H
	MOV AH,2
	INT 21H

EXIT:
	MOV AH,4CH
	INT 21H
MAIN ENDP
S3 ENDS
	END MAIN
```

### 5.2编写程序，从键盘接收一个小写字母，然后找出它的前导字符和后续字符，再按顺序显示这三个字符

```ASM
;5.2接收一个小写字母，然后找出前导字符和后续字符，按顺序输出
S1 SEGMENT
S1 ENDS

S2 SEGMENT
	DW 30H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
	ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
	MOV AX,S1
	MOV DS,AX
	MOV AX,S2
	MOV SS,AX
	LEA SP,TOP
 
	;输入
L0:
	MOV AH,1
	INT 21H
	CMP AL,'a'
	JB L0
	CMP AL,'z'
	JA L0
	MOV BL,AL
	DEC BL
	
	;输出
	MOV DL,0DH
	MOV AH,2
	INT 21H
	MOV DL,0AH
	MOV AH,2
	INT 21H	
	
	MOV CX,2
	MOV DL,BL
L1:
	MOV AH,2
	INT 21H
	ADD DL,2
	LOOP L1

EXIT:
	MOV AH,4CH
	INT 21H
MAIN ENDP
S3 ENDS
	END MAIN
```

### 5.3将 AX 寄存器中的 16 位数分成 4 组，每组 4 位，然后把这四组数分别放在 AL、BL、CL 和 DL 中

```ASM
;5.3将AX寄存器的16位数分为四组，每组四位，分别放在AL，BL，CL，DL中
S1 SEGMENT
	A1	DW	0
	B1	DW	0
	C1	DW	0
	D1	DW	0
S1 ENDS

S2 SEGMENT
	DW 30H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
	ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
	MOV AX,S1
	MOV DS,AX
	MOV AX,S2
	MOV SS,AX
	LEA SP,TOP
	
	MOV AX,0ABCDH
	MOV CL,4	

	ROL AX,CL
	MOV BX,AX
	AND BX,000FH
	MOV SI,BX

	ROL AX,CL
	MOV BX,AX
	AND BX,000FH
	MOV DI,BX

	ROL AX,CL
	MOV BX,AX
	AND BX,000FH
	MOV BP,BX

	ROL AX,CL
	MOV BX,AX
	AND BX,000FH
	MOV DX,BX
	
	MOV AX,SI
	MOV BX,DI
	MOV CX,BP
		

EXIT:
	MOV AH,4CH
	INT 21H

MAIN ENDP
S3 ENDS
	END MAIN

```



```ASM
;5.3将AX寄存器的16位数分为四组，每组四位，分别放在AL，BL，CL，DL中
S1 SEGMENT
S1 ENDS

S2 SEGMENT
	DW 30H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
	ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
	MOV AX,S1
	MOV DS,AX
	MOV AX,S2
	MOV SS,AX
	LEA SP,TOP
	
	MOV AX,0ABCDH
	PUSH AX
	
	MOV CL,4
	ROL AX,CL
	PUSH AX
	AND AX,000FH

	POP BX
	ROL BX,CL
	PUSH BX
	AND BX,000FH

	POP CX
	SHR CX,1
	SHR CX,1
	SHR CX,1
	SHR CX,1

	SHR CX,1
	SHR CX,1
	SHR CX,1
	SHR CX,1
	PUSH CX
	AND CX,00F0H

	POP DX
	AND DX,000FH
	SHR CX,1
	SHR CX,1
	SHR CX,1
	SHR CX,1

	MOV AH,4CH
	INT 21H
MAIN ENDP
S3 ENDS
	END MAIN
```

### 5.4比较string1和string2所含字符是否相同，相同'MATCH',不同'NOTMATCH'

```ASM
;5.4比较string1和string2所含字符是否相同，相同'MATCH',不同'NOTMATCH'
S1 SEGMENT
	STRING1 DB 'ABCDEFGH$'
	STRING2 DB 'QQQQQQQQ$'
	MATCH	DB 'MATCH$'
	NOTMATCH	DB 'NOTMATCH$'
S1 ENDS

S2 SEGMENT
	DW 30H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
	ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
	MOV AX,S2
	MOV SS,AX
	MOV AX,S1
	MOV DS,AX
	MOV ES,AX
	
	LEA SI,STRING1
	LEA DI,STRING2
	MOV CX,8
	
	CLD
	
	REPNE CMPSB
	JNE NO
	
YES:
	LEA DX,MATCH
	MOV AH,09H
	INT 21H
	JMP EXIT
NO:
	LEA DX,NOTMATCH
	MOV AH,09H
	INT 21H
	
EXIT:
	MOV AH,4CH
	INT 21H
MAIN ENDP
S3 ENDS
	END MAIN
```



### 5.6将一个含有20个数据的数组M分成两个数组，
正数组P和负数组N,并分别把两个数组的数据的个数显示出来

```ASM
;5.6 将一个含有20个数据的数组M分成两个数组，
;正数组P和负数组N,并分别把两个数组的数据的个数显示出来
S1 SEGMENT
    COUNT DB 20
    M DW 1,-2,3,-4,5,-6,7,-8,9,-10,11,-12,13,-14,15,-16,17,-18,19,20
    CNTP DW 0
    P DW 20 DUP(?)
    CNTN DW 0
    N DW 20 DUP(?)
    POST DB 0DH,0AH,'Positive:$'
    NEGE DB 0DH,0AH,'Negative:$'
    ENT DB 0DH,0AH,'$'
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
	MOV AX,S2
	MOV SS,AX
	LEA SP,TOP
	
	MOV SI,0
    MOV DI,0
    MOV BP,0
    MOV CX,20
L0: 
	MOV BX,M[SI]
	ADD SI,2
	CMP BX,0
	JS	L2
	
	;正数
L1: 
	MOV P[DI],BX
	INC CNTP
	ADD DI,2
	JMP L3
	
	;负数
L2: 
	MOV N[BP],BX
	INC CNTN
	ADD BP,2
	JMP L3
L3: 
	LOOP L0
	
	
	;AH余数 AL商
	MOV AX,CNTP
	MOV BL,10
	DIV BL
	MOV BX,AX
	LEA DX,POST
	MOV AH,9
	INT 21H

	ADD BL,30H
	MOV DL,BL
	MOV AH,2
	INT 21H
	ADD BH,30H
	MOV DL,BH
	MOV AH,2
	INT 21H
	
	LEA DX,ENT
	MOV AH,9
	INT 21H
	
	MOV AX,CNTN
	MOV BL,10
	DIV BL
	MOV BX,AX
	LEA DX,NEGE
	MOV AH,9
	INT 21H
	
	ADD BL,30H
	MOV DL,BL
	MOV AH,2
	INT 21H
	ADD BH,30H
	MOV DL,BH
	MOV AH,2
	INT 21H
	
EXIT:	
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN
```



### 5.7 求出首地址为 DATA 的 100D 字数组中的最小偶数，并存放在 AX 中

两次循环 前指针找出偶数放在ax 后指针找出偶数放在dx，假设ax是最小偶数，ax和dx进行比较

```ASM
;5.7 求出首地址为 DATA 的 100D 字数组中的最小偶数，并存放在 AX 中
S1 SEGMENT
    DATA DW 100D DUP(?)
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP

	MOV BX,0
    MOV CX,100
    
L0:
	MOV AX,DATA[BX]
	TEST AX,1
	ADD BX,2
	LOOPNZ L0	;ZF=0和CF>0，继续循环
	JNZ EXIT	;循环结束且没有偶数
	JCXZ EXIT	;循环结束且最后一个是偶数，在BX
	JZ	L1		;循环未结束，找到偶数 进行比较
L1:
	MOV DX,DATA[BX]
	TEST DX,1
	ADD BX,2
	JNZ	L0
	CMP DX,AX	
	JGE	L2		;继续向下找更小的偶数
	MOV AX,DX	;更新最小偶数值
	LOOP L0
L2:
	LOOP L1

EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN
```

### 5.8 把 AX 中存放的 16 位二进制数 K 看作是 8 个二进制的“四分之一字节”

### 数一下值为 3(即 11B)的四分之一的字节数，并将该数在终端上显示出来。

```ASM
;5.8 把 AX 中存放的 16 位二进制数 K 看作是 8 个二进制的“四分之一字节”。
;数一下值为 3(即 11B)的四分之一字节数，并将该数在终端上显示出来。
S1 SEGMENT
	K DW 6C3BH
S1 ENDS

S2 SEGMENT
	DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP
    
    MOV AX,K
    MOV BP,8		;循环次数
    MOV CL,2		;循环位数
    XOR DX,DX		;11B的个数
    
L0:
	CMP BP,0
	JE	EXIT
	DEC BP
	
	ROL AX,CL
	MOV BX,AX
	AND BX,3
	CMP BX,3
	
	JE	L1
	JNE L0
	
L1:
	INC DX
	JMP L0
	
EXIT:
	ADD DL,30H
	MOV AH,2
	INT 21H
	
    MOV AH,4CH
    INT 21H
    
MAIN ENDP
S3 ENDS
    END MAIN
```

### 5.9输入一个四位的 16 进制数，并在终端上显示等值的二进制数

```ASM
;5.9 输入一个四位的 16 进制数，并在终端上显示等值的二进制数。
S1 SEGMENT
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
	MOV AX,S1
	MOV DS,AX
	MOV AX,S2
	MOV SS,AX
	LEA SP,TOP
	
	;输入
	MOV BX,0
	MOV CX,4
L0:
	PUSH CX
	MOV CL,4
	ROL BX,CL
	MOV AH,1
	INT 21H
	
	;NUMBER
	CMP AL,30H
	JB	L0
	CMP AL,39H
	JA	L1
	SUB AL,30H
	JMP L3
	
L1:	;APHAL
	CMP AL,41H
	JB	L0
	CMP AL,46H
	JA	L2
	SUB AL,37H
	JMP L3
	
L2:	;SMALL A
	CMP AL,61H
	JB	L0
	CMP AL,66H
	JA	L0
	SUB AL,57H
	JMP L3

L3:
	ADD BL,AL
	POP CX
	LOOP L0
	
	MOV DL,0DH
	MOV AH,2
	INT 21H
	MOV DL,0AH
	MOV AH,2
	INT 21H
	
	MOV CX,16
L4:
	MOV DL,30H
	ROL BX,1
	ADC DL,0
	MOV AH,2
	INT 21H
	LOOP L4
	
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN
```

### 5.10设有一段英文，其字符变量名为 ENG，并以$字符结束。试编写一程序，查对单词 SUN在该文中的出现次数，并以格式“SUN：xxxx”显示出次数。

```ASM
;5.10 一段英文 名ENG，以$结束,计算SUN在该文中出现的字数，格式SUNXXXX显示出次数
S1 SEGMENT
    ENG DB 'SUNSSUN;;SUN S,,,SUN$'
	PUT DB 'SUN'

	COUNT DB '0000',0DH,0AH,'$'
	SUN DB 'SUN'
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV ES,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP
    
    XOR AX,AX
    MOV DX,PUT-ENG-2
    CALL CMPSTR
    CALL CHANGE
    
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP

CMPSTR PROC NEAR
L1:
    MOV DI,BX
    LEA SI,SUN
    
    MOV CX,3
    REPE CMPSB
    JNZ L2
    INC AX
    ADD BX,2 ;匹配成功
    SUB DX,2
L2:
	INC BX ;匹配下一个
	DEC DX
	CMP DX,0
	JG L1

CMPSTR ENDP

CHANGE PROC NEAR
L3:
	MOV CH,4 
	MOV CL,4
	LEA BX,COUNT 
L4: 
	ROL AX,CL
	MOV DX,AX
	AND DL,0FH ;取一位16进制数
	ADD DL,30H
	CMP DL,39H
	JLE L5
	ADD DL,07H
L5: 
	MOV [BX],DL
	INC BX
	DEC CH
	JNZ L4
	
 	LEA DX,PUT
 	MOV AH,09H
	INT 21H
CHANGE ENDP

S3 ENDS
    END MAIN

```

### 5.11从键盘输入一系列以$为结束符的字符串，对其中<u>非数字字符</u>计数，并显示计数结果。

```ASM
;从键盘输入一系列以$为结束符的字符串，
;对其中的非数字字符计数，并显示出计数结果。
S1 SEGMENT
    STRING DB 100 DUP(?)
    CNT DW 0
    DISPLAY DB 0DH,0AH,'THE COUNT:$'
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP
   
    LEA BX,STRING
L1:
	MOV AH,1		;输入
	INT 21H
	MOV [BX],AL
	INC BX
	CMP AL,'$'		;结束?
	JE	L3			
	CMP AL,30H		;0-9
	JB	L2
	CMP AL,39H
	JA	L2
	JMP L1
	
L2:
	INC CNT
	JMP L1
	
L3:
	;转成十进制
	MOV AX,CNT
	MOV BL,10
	DIV BL
	MOV BX,AX
	
	LEA DX,DISPLAY
	MOV AH,9
	INT 21H
	
	;BX放到DX
	MOV DL,30H
	ADD DL,BL
	MOV AH,2
	INT 21H
	
	MOV DL,30H
	ADD DL,BH
	MOV AH,2
	INT 21H
	
	MOV DL,0DH
	MOV AH,2
	INT 21H
	MOV DL,0AH
	MOV AH,2
	INT 21H
	
EXIT:   
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
	END MAIN
```

### 5.12 首地址为 MEM 的 100D 字数组，删除数组中所有为 0 的项，并将后续项向前压缩，最后将数组的剩余部分补上 0

```ASM
;5.12 首地址为 MEM 的 100D 字数组，删除数组中所有为 0 的项，
;并将后续项向前压缩，最后将数组的剩余部分补上 0。
S1 SEGMENT
    MEM DW 1,0,0,0,0,0,0,0,0,0
    	DW 2,1,0,3,4,5,6,7,8,9
    	DW 3,0,0,0,0,0,0,0,0,0
    	DW 4,1,2,0,4,5,6,7,8,9
    	DW 5,0,0,0,0,0,0,0,0,0
    	DW 6,1,2,3,4,5,0,7,8,9
    	DW 7,0,0,0,0,0,0,0,0,0
    	DW 8,1,2,3,4,5,6,7,0,9
    	DW 9,0,0,0,0,0,0,0,0,0
    	DW 0,1,2,3,4,5,6,7,8,0
    CNT DW 0
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP
	
	MOV CX,100
	MOV SI,0
L0:
	CMP CX,0
	JE	L3
	
	MOV AX,MEM[SI]
	MOV DI,SI
	ADD SI,2
	DEC CX
	CMP AX,0
	JNE	L0
	
	;把后面的前移
L1:
	INC CNT			;记录数组中0的个数
	MOV DX,MEM[SI]
	MOV MEM[DI],DX	;DX是中间量
	JMP L0
	
	;剩余部分补零
	MOV CX,CNT
L3:
	MOV SI,198
	MOV MEM[SI],0
	SUB SI,2
	LOOP L3
	
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN
```

### 5.13在 STRING 到 STRING+99 单元中存放着一个字符串
测试该字符串中是否存在数字，如有则把 CL 的第 5 位置 1，否则将该位置 0。

```ASM
;在 STRING 到 STRING+99 单元中存放着一个字符串
;测试该字符串中是否存在数字，如有则把 CL 的第 5 位置 1，否则将该位置 0。
S1 SEGMENT
	STRING DB 'HELLOABCDE1',90 DUP('A') 
S1 ENDS

S2 SEGMENT
	DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP
   
	MOV CX,100
	LEA BX,STRING 
L0:
	MOV AL,[BX]
	INC BX
    CMP AL,30H
    JB	L1
    CMP AL,39H
    JNA	L2
L1:
	LOOP L0
	
	;存在数字
L2:
	MOV CL,00010000b
	JMP EXIT
  
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN
```

### 5.14

```ASM
;5.14 在首地址为 TABLE 的数组中按递增次序存放着 100H 个 16 位补码数
;把出现次数最多的数及其出现次数分别存放于 AX 和 CX 中
S1 SEGMENT
	TABEL	DW	6 DUP(-1),10 DUP(1),25 DUP(2),15 DUP(3),200 DUP(4)
	TEMP	DW	?
S1 ENDS

S2 SEGMENT
	DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME CS:S3,DS:S1,SS:S2
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP
    
    MOV CX,128
    MOV SI,0	;第二组的个数
    MOV DI,0	;第一组的个数
    MOV DX,0	;出现次数最大的值
    LEA BX,TABEL
	MOV DX,[BX]
    
;一段一段记录个数，相等增加个数，大于则记录下一组，比较存储两组个数，再进行下一轮
L1:
	CMP CX,0
	JE	EXIT
	DEC CX
	
	;后边组的个数是DI   后指针
	MOV AX,[BX]
	ADD BX,2
	INC DI
	CMP	AX,[BX]
	JNE L2
	
	CMP CX,0
	JNE	L1
	
L2:
	CMP DI,SI
	JB	L3		;不用变动
	;后边组的次数更多，需要更新
	MOV DX,AX	;DX保存数值较大值
	MOV SI,DI	;SI保存次数较大值

L3:
	XOR	DI,DI
	JMP L1		
	
EXIT:
	MOV CX,SI
	
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN

```

### 5.15 数据段中已定义了一个有 n 个<u>字</u>数据的数组 M,求出 M 中绝对值最大的数，放在数据段的 M+2n 单元中(最后一个单元),并将该数的偏移地址存放在 M+2(n+1)单元中

```ASM
;5.15 数据段中已定义了一个有 n 个字数据的数组 M，
;求出 M 中绝对值最大的数，放在数据段的 M+2n 单元中
;并将该数的偏移地址存放在 M+2(n+1)单元中
S1 SEGMENT
    M DW 10 DUP(5),10 DUP(2),5 DUP(-10)
    CNT	DW	($-M)/2
    MAX	DW	?
    ADDRESS DW ?
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP
	
	;第一次
	MOV SI,0
	MOV AX,M[SI]
	ADD SI,2
	CMP AX,0
	JGE	L0
	NEG AX
L0:	
	MOV MAX,AX
	MOV BX,SI
	
	;N-1次循环比较
	MOV CX,CNT
	DEC CX 
L1:
	CMP CX,0
	JE	L3
	MOV AX,M[SI]
	ADD SI,2
	DEC CX
	CMP AX,0
	JGE	L2
	NEG AX
	
L2:
	CMP MAX,AX
	JAE L1
	;出现绝对值更大的数，需更新
	MOV MAX,AX
	MOV BX,SI
	JMP L1
	
	;存放数据
L3:
	ADD SI,2
	MOV DX,M[BX]
	MOV M[SI],DX
	ADD SI,2
	MOV M[SI],BX
	
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN

```

### 5.16在首地址为 DATA 的字数组中存放着 100H 个 16 位补码数
求出它们的平均值放在 AX 寄存器中,并求出数组中有多少个数小于此平均值，将结果放在 BX 寄存 器中。 

```ASM
;5.16 在首地址为 DATA 的字数组中存放着 100H 个 16 位补码数
;求出它们的平均值放在 AX 寄存器中；
;并求出数组中有多少个数小于此平均值，将结果放在 BX 寄存 器中。 
S1 SEGMENT
    DATA DW	3 DUP(-1),4 DUP(1),25 DUP(2),15 DUP(3),200 DUP(4)
    AVER DW ?
    CNT	DW	0
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP

	MOV CX,128
	MOV AX,0
	MOV SI,0
L0:
	MOV DX,DATA[SI]
	ADD SI,2
	ADD AX,DX	;AX作SUM
	LOOP L0
	
	MOV BP,100H
	DIV BP
	MOV AH,0
	MOV AVER,AX

	;遍历比较
	MOV SI,0
	MOV CX,128
L1: 
	MOV DX,DATA[SI]
	ADD SI,2
	CMP DX,AVER
	JAE L2
	INC CNT
L2:
	LOOP L1
	
	MOV BX,CNT
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN
```

### 5.17把 AX 中的 16 进制数转换为 ASCII 码,并将对应的 ASCII 码依次存放到 MEM 数组中的四个字节中
例如，当(AX)=2A49H 时，MEM 中的 4 个字节为39H，34H，41H，32H

```asm
;5.17 试编制一个程序把 AX 中的 16 进制数转换为 ASCII 码
;并将对应的 ASCII 码依次存放到 MEM 数组中的四个字节中
;例如，当(AX)=2A49H 时，MEM 中的 4 个字节为39H，34H，41H，32H
S1 SEGMENT
    MEM DB 4 DUP(?)
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP

	MOV AX,2A49H
	MOV CX,4
	MOV SI,3
L0:
	PUSH CX
	MOV CL,4
	ROL AX,CL
	MOV DX,AX
	AND DX,0FH
	ADD DX,30H
	CMP DX,3AH
	JB	L1
	ADD DX,7
	
	;存放数据	
L1:
	MOV MEM[SI],DL
	DEC SI
	POP CX
	LOOP L0	
	
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN


```

### 5.18把 0~100D 之间的 30 个数存入以 GRADE 为首地址的 30 字数组中
GRADE+i 表示学号为 i+1 的学生的成绩
数组 RANK 为 30 个学生的名次表
RANK+i 的内容是学号为 i+1 的学生的名次
根据 GRADE 中的学生成绩，将学生名次填入 RANK数组中
(提示：一个学生的名次等于成绩高于这个学生的人数加 1)

```asm
;5.18 把 0~100D 之间的 30 个数存入以 GRADE 为首地址的 30 字数组中
;GRADE+i 表示学号为 i+1 的学生的成绩
;数组 RANK 为 30 个学生的名次表
;RANK+i 的内容是学号为 i+1 的学生的名次
;根据 GRADE 中的学生成绩，将学生名次填入 RANK数组中
;(提示：一个学生的名次等于成绩高于这个学生的人数加 1。
S1 SEGMENT
    GRADE DW 13 DUP(90),4 DUP(80),5 DUP(70),2 DUP(60),0064H,6 DUP(95)
    NUM DW 0
    RANK DW 30 DUP(?)
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP

	MOV SI,0
	MOV DI,0
	MOV CX,30
L0:
	MOV AX,GRADE[SI]
	ADD SI,2
	MOV DI,0
	MOV NUM,0
	
L1:
	CMP DI,30
	JE	L3
	MOV BX,GRADE[DI]
	ADD DI,2
	CMP AX,BX
	JA	L2
	JMP L1	
L2:
	INC NUM
	JMP L1
	
L3:
	MOV DX,NUM
	MOV RANK[SI],DX
	LOOP L0
	
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN
```

### 5.19 已知数组 A 包含 15 个互不相等的整数，数组 B 包含 20 个互不相等的整数

### 把既在 A 中又在 B 中出现的整数存放于数组 C 中

```asm
;5.19 已知数组 A 包含 15 个互不相等的整数，数组 B 包含 20 个互不相等的整数
;把既在 A 中又在 B 中出现的整数存放于数组 C 中
S1 SEGMENT
    ARRYA	DB	0,1,2,3,4,5,6,7,8,9,10,11,12,13,14
    ARRYB	DB	5,6,7,8,9,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29
    ARRYC	DB	15 DUP(?)
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP

	MOV SI,0
	MOV BX,0
	MOV CX,15
	;外循环
L0:
	PUSH CX
	MOV CX,20
	
	MOV AL,ARRYA[SI]
	INC SI
	
	;内循环
	MOV DI,0
L1:
	CMP ARRYB[DI],AL
	INC DI
	JE L2		
	LOOP L1		;接着比较
	
L2:
	MOV ARRYC[BX],AL
	INC BX
	
	POP CX	
	LOOP L0	
	
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN
```

### 5.20 设在 A、B 和 C 单元中分别存放着三个数。

### 若三个数都不是 0，则求出三数之和存放在D 单元中

### 若其中有一个数为 0，则把其它两单元也清 0

```asm
;5.20 设在 A、B 和 C 单元中分别存放着三个数。
;若三个数都不是 0，则求出三数之和存放在D 单元中
;若其中有一个数为 0，则把其它两单元也清 0

S1 SEGMENT
    NUMA	DW	10
	NUMB	DW	0
    NUMC	DW	0
    NUMD	DW	0
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP

	XOR DX,DX
	MOV AX,NUMA
	CMP AX,0
	JE  L1
	ADD DX,AX
	
	MOV AX,NUMB
	CMP AX,0
	JE  L1
	ADD DX,AX
	
	MOV AX,NUMC
	CMP AX,0
	JE  L1
	ADD DX,AX
	JMP L2
	
	;清零
L1:
	MOV BX,0
	LEA SI,NUMA
	MOV [SI],BX
	LEA SI,NUMB
	MOV [SI],BX
	LEA SI,NUMC
	MOV [SI],BX
	JMP EXIT
	
L2:
	LEA DI,NUMD
	MOV DX,[DI]

EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN

```

### 5.21比较数组 ARRAY 中的三个 16 位补码数，并根据比较结果在终端上显示如下信息：

### (1) 如果三个数都不相等则显示 0；

### (2) 如果三个数有二个数相等则显示 1；

### (3) 如果三个数都相等则显示 2

```ASM
;5.21比较数组 ARRAY 中的三个 16 位补码数，并根据比较结果在终端上显示如下信息：
;(1) 如果三个数都不相等则显示 0；
;(2) 如果三个数有二个数相等则显示 1；
;(3) 如果三个数都相等则显示 2

S1 SEGMENT
    ARRAY	DW	1,2,1
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP

	LEA SI,ARRAY
	MOV AX,[SI]
	ADD SI,2
	MOV BX,[SI]
	ADD SI,2
	MOV DX,[SI]
	CMP AX,BX
	JE  L1
	JNE L2
	
	;A=B
L1:
	CMP BX,DX
	JE	L3
	JNE L4
	
	;A≠B
L2:
	CMP BX,DX
	JE	L4
	CMP AX,DX
	JE	L4
	JNE L5
	
	;ALL OK
L3:
	MOV DL,32H
	MOV AH,2
	INT 21H
	JMP EXIT
	
	;JUST ONE
L4:
	MOV DL,31H
	MOV AH,2
	INT 21H
	JMP EXIT
	
	;ALL NOT
L5:
	MOV DL,30H
	MOV AH,2
	INT 21H
	JMP EXIT
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN

```

### 5.22 从键盘输入一系列字符(以回车符结束)，并按字母、数字、及其它字符分类计数，最后显示出这三类的计数结果 OK

```ASM
;从键盘输入一系列字符(以回车符结束)，并按字母、数字、及其它字符分类计数，
;最后显示出这三类的计数结果
S1 SEGMENT
	BUFF	DB 250,?,250 DUP(?)
    CNTA	DW	0
    CNTN	DW	0
    CNTO	DW	0
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP

	LEA DX,BUFF
	MOV	AH,0AH
	INT 21H
	
	MOV	SI,1
	XOR CH,CH
	MOV CL,BUFF[SI]
L0:
	INC SI
	MOV AL,BUFF[SI]
	CMP AL,30H
	JB	L3
	CMP AL,3AH
	JB	L2
	CMP AL,41H
	JB	L3
	CMP AL,5AH
	JB	L1
	CMP AL,61H
	JB	L3
	CMP AL,7AH
	JB	L1

L1:
	INC CNTA
	MOV BX,CNTA
	LOOP L0
L2:
	INC CNTN
	MOV DX,CNTN
	LOOP L0
L3:
	INC CNTO
	MOV DI,CNTO
	LOOP L0
	
	MOV DX,0DH
	MOV AH,2
	INT 21H
	MOV DX,0AH
	MOV AH,2
	INT 21H
	MOV DX,CNTA
	MOV AH,2
	ADD DX,30H
	INT 21H
	
	MOV DX,CNTN
	ADD DX,30H
	MOV AH,2
	INT 21H
	MOV DX,0DH
	MOV AH,2
	INT 21H
	MOV DX,0AH
	MOV AH,2
	INT 21H
	
	MOV DX,CNTO
	ADD DX,30H
	MOV AH,2
	INT 21H
	MOV DX,0DH
	MOV AH,2
	INT 21H
	MOV DX,0AH
	MOV AH,2
	INT 21H
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN
```

### 5.23 已定义了两个整数变量 A 和 B，试编写程序完成下列功能：

(1) 若两个数中有一个是奇数，则将奇数存入 A 中，偶数存入 B 中；

(2) 若两个数中均为奇数，则将两数加 1 后存回原变量；

(3) 若两个数中均为偶数，则两个变量均不改变。

```ASM
;5.23 已定义了两个整数变量 A 和 B
;(1) 若两个数中有一个是奇数，则将奇数存入 A 中，偶数存入 B 中；
;(2) 若两个数中均为奇数，则将两数加 1 后存回原变量；
;(3) 若两个数中均为偶数，则两个变量均不改变。
S1 SEGMENT
    NUMA	DW	2A32H
    NUMB	DW	2A31H
S1 ENDS

S2 SEGMENT
    DW 100H DUP(?)
TOP LABEL WORD
S2 ENDS

S3 SEGMENT
    ASSUME DS:S1,SS:S2,CS:S3
MAIN PROC FAR
    MOV AX,S1
    MOV DS,AX
    MOV AX,S2
    MOV SS,AX
    LEA SP,TOP

L0:
	MOV AX,NUMA
	TEST AX,1
	JE	L2
	
	;奇数
L1:
	MOV BX,NUMB
	TEST BX,1
	JNE	L4
	JMP EXIT
	
	
	;偶数
L2:	
	MOV BX,NUMB
	TEST BX,1
	JNE	L3
	JMP EXIT
	
	;A奇B偶
L3:
	XCHG AX,BX
	JMP EXIT
	;都是奇数，都+1
L4:
	INC AX
	LEA SI,NUMA
	MOV [SI],AX
	INC BX
	LEA SI,NUMB
	MOV [SI],BX
	
EXIT:
    MOV AH,4CH
    INT 21H
MAIN ENDP
S3 ENDS
    END MAIN
```





