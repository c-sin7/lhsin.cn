---
title: 图
author: sin
date: 2023-02-14
categories: 寒假学习
summary: 图
tags: 
  - 算法
---

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230216003048349.png" alt="image-20230216003048349" style="zoom:50%;" />

```java
// 点结构的描述
public class Node {
	public int value;
	public int in;
	public int out;
	public ArrayList<Node> nexts;
	public ArrayList<Edge> edges;

	public Node(int value) {
		this.value = value;
		in = 0;
		out = 0;
		nexts = new ArrayList<>();
		edges = new ArrayList<>();
	}
}

public class Edge {
	public int weight;
	public Node from;
	public Node to;

	public Edge(int weight, Node from, Node to) {
		this.weight = weight;
		this.from = from;
		this.to = to;
	}

}
```



<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230216151546877.png" alt="image-20230216151546877" style="zoom:67%;" />

dfs：入栈就打印

栈就是目前的整条路径

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230216155321236.png" alt="image-20230216155321236" style="zoom:50%;" />

拓扑序一定是有向无环图

拓扑排序不唯一

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230216155621339.png" alt="image-20230216155621339" style="zoom: 50%;" />

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230216171826931.png" alt="image-20230216171826931" style="zoom:50%;" />



最小生成树、k算法：贪心

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230216173001736.png" alt="image-20230216173001736" style="zoom:50%;" />

最小生成树要求是无向图

最小生成树：在不影响所有点都连通的情况下，所有边加起来的最小值是多少

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230217015404059.png" alt="image-20230217015404059" style="zoom:50%;" />



<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230217015604608.png" alt="image-20230217015604608" style="zoom:50%;" />

有环：

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230217015748668.png" alt="image-20230217015748668" style="zoom:50%;" />

p算法：贪心

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230217020027679.png" alt="image-20230217020027679" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230217102648873.png" alt="image-20230217102648873" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230217102740533.png" alt="image-20230217102740533" style="zoom:50%;" />

因为a、b都被解锁了，再解锁d会成环，所以不选3这个边

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230217103457736.png" alt="image-20230217103457736" style="zoom:50%;" />

所有点都解锁就可以停止

p：

用一个点解锁周围所有边，弹出一个点代价都是O(logN)，当所有点都被拽进来，结束

点<<边或者点很少，p会好

k：略过所有边才能结束，边多就卡了



边多的时候用p

k能过的p一定能过