---
title: 堆和比较器
author: sin
date: 2023-01-17
categories: 寒假学习
summary: 比较器
tags: 
  - 算法
---

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230118001020769.png" alt="image-20230118001020769" style="zoom:50%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230118105845576.png" alt="image-20230118105845576" style="zoom:50%;" />

复杂度O(N*logN)





堆：优先级队列 PQ

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230118105920373.png" alt="image-20230118105920373" style="zoom:50%;" />

完全二叉树：要么这一层是满的，要么==从左往右==在变满的路上，是最后一层

以下均是：

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230118110411932.png" alt="image-20230118110411932" style="zoom:50%;" />

从0出发的一段连续数组可以被当作完全二叉树

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230118110953244.png" alt="image-20230118110953244" style="zoom:50%;" />父节点是向下取整，和int一样



堆就是完全二叉树、提及堆要说明是大根堆还是小根堆

大根堆：每一棵子树的最大值都是头节点的值

大根堆就是根节点是整棵树的最大值(根节点大于等于左右子树的最大值)，对于他的任意子树，根节点也是最大值。

堆的调整：与父节点(i-1)/2比较，直到小于等于父节点或者到根节点

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230118120637296.png" alt="image-20230118120637296" style="zoom:50%;" />



下沉：

把根节点挪到heapSize位置，heapSize--；然后arr[heapSize]与arr[0]交换并进行调整下沉

在左孩子没越界的情况下：把两个孩子中较大的拎出来、与父节点pk，小就下沉，一样大选哪边都行

停：较大的孩子都不再比index位置的数大；已经没孩子了



假设位置7的数出错了，x—>x’

重新调整：两个实际只会发生一个

1. heapInsert(7) 上浮
2. heapify(7) 下沉

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230118213012114.png" alt="image-20230118213012114" style="zoom:50%;" />

堆可以加重复值，有序表treeMap不行



heapInser和heapify复杂度都是O(logN) 二叉树高度是logN



数据量增加常数法

如果，数据量为N时，时间复杂度为O(N*logN)，

当增加常数倍时，则可以推出数据量为2N，时间复杂度为O(N*logN)。（常数项可以忽略）



证明：数据量2N的上限是O(N * logN)，下限：把2N分成N和N，先后成堆，第一个N成堆可得树高度是logN，第二个N是在第一个N的基础上，也就是在高度为logN的树上添加，故下限也是O(N * logN)，夹逼定理可以得2N的就是O(N * logN)。

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119105736370.png" alt="image-20230119105736370" style="zoom:50%;" />



经典的建堆是O(N * logN)，优化的是O(N)

调堆是O(N * logN)

堆排序是建堆+调堆 = O(N * logN)



如果有N个节点，可以认为叶节点有N/2个，最多往下看一回

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119111837548.png" alt="image-20230119111837548" style="zoom:50%;" />

等比数列，最后收敛于O(N)

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119112031982.png" alt="image-20230119112031982" style="zoom:50%;" />



<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119112643790.png" alt="image-20230119112643790" style="zoom:50%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119110626225.png" alt="image-20230119110626225" style="zoom:50%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119110640120.png" alt="image-20230119110640120" style="zoom:50%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119110709243.png" alt="image-20230119110709243" style="zoom:50%;" />





第八节

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119131714564.png" alt="image-20230119131714564" style="zoom:50%;" />



<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119131047354.png" alt="image-20230119131047354" style="zoom:50%;" />





java和c++

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119131310628.png" alt="image-20230119131310628" style="zoom:50%;" />

题目给的数据量为10^3^，若算法时间复杂度为O(N^2^)，则能通过

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119131350741.png" alt="image-20230119131350741" style="zoom:50%;" />



线段以开始位置，从小到大排序

[1,7]  1（小根堆的数字个数） ≤  1(该线段起点)   线段终点7放到小根堆

[2,3]  2（小根堆的数字个数） ≤  2(该线段起点)   线段终点3放到小根堆

小根堆里的数字个数就是这个线段的答案

在小根堆中，≤ 线段起点的pop



总结：每条线段的结尾边界 和 下一条线段的起始边界pk，上一条穿过了起始边界就是有重合

就是==重合区域==以每个线段起始位置开始的情况下，有多少条线段穿过去



 <img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230119193205363.png" alt="image-20230119193205363" style="zoom:50%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230120194319736.png" alt="image-20230120194319736" style="zoom:50%;" />



==重合的两条线段，重合区域的左边界必是某条线段的左边界==

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230120194601305.png" alt="image-20230120194601305" style="zoom:33%;" />

假设，每条线段的左边界就是重合区域的左边界，那么求出每个线段向右贯穿的最大数量就是答案

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230120210409187.png" alt="image-20230120210409187" style="zoom:50%;" />











<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230120215422888.png" alt="image-20230120215422888" style="zoom:50%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230120215440126.png" alt="image-20230120215440126" style="zoom:50%;" />







5

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230120215459166.png" alt="image-20230120215459166" style="zoom:50%;" />

6

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230124102749867.png" alt="image-20230124102749867" style="zoom:50%;" />

7

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230124110129254.png" alt="image-20230124110129254" style="zoom:50%;" />

8

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230124110445678.png" alt="image-20230124110445678" style="zoom:50%;" />

9

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230124110542330.png" alt="image-20230124110542330" style="zoom:50%;" />

10

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230124095858525.png" alt="image-20230124095858525" style="zoom:50%;" />

11

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230124095915028.png" alt="image-20230124095915028" style="zoom:50%;" />

12

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230124100101528.png" alt="image-20230124100101528" style="zoom:50%;" />

List<List<Integer>>：时间点——得奖人数



不会影响得奖区，故还是上一个时间节点的得奖名单

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230206234301091.png" alt="image-20230206234301091" style="zoom:50%;" />

1：第一个if 、用户购买数=0，先塞两个0

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230206234526860.png" alt="image-20230206234526860" style="zoom: 80%;" />

2：调整买卖

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230206234654890.png" alt="image-20230206234654890" style="zoom: 80%;" />

3：第一次购买，之前没有进得奖区/候选区

反正先进去，后面再调整

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230206234849625.png" alt="image-20230206234849625" style="zoom:80%;" />

4：move方法，得奖区(0)和候选区(0)看看是否能够交换



复杂度

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230207000503107.png" alt="image-20230207000503107" style="zoom:67%;" />