---
title: 算法试题讲解
author: sin
date: 2023-02-08
categories: 寒假学习
summary: 算法试题讲解
tags: 
  - 算法
---

第11节

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208134859807.png" alt="image-20230208134859807" style="zoom: 80%;" />







解决思路：

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208192306854.png" alt="image-20230208192306854" style="zoom:50%;" />

part一：寻找单链表的第一个入环节点

环外6个节点，环内8个节点

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208155218001.png" alt="image-20230208155218001" style="zoom:50%;" />

终会相遇

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208155349886.png" alt="image-20230208155349886" style="zoom:50%;" />

快指针回到原点，慢指针停在原地，之后快慢指针都只走一步

之后，快慢指针一定会在第一个入环节点相遇





part二：分别找两个链表的第一个入环节点

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208162428630.png" alt="image-20230208162428630" style="zoom:50%;" />

用容器找到相交节点：

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208171823403.png" alt="image-20230208171823403" style="zoom:50%;" />

不用容器，通过计算两个链表的长度len1，len2，如果最后一个节点的内存地址相同，则相交

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208172004178.png" alt="image-20230208172004178" style="zoom:50%;" />

接下来，如果len1=100，len2=80，再让head1，head2从头开始，且head1慢20步再走

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208172230206.png" alt="image-20230208172230206" style="zoom:50%;" />

经历两个while后，如果n>0，链表一正常，如果n<0，链表二正常

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208173321982.png" alt="image-20230208173321982" style="zoom: 80%;" />

part三：两链表都有环只有三种情况

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208192225671.png" alt="image-20230208192225671" style="zoom:50%;" />

如果loop1==loop2，则为情况（二），否则是情况（一）/（三）

区分一、三的方法：loop1走上一圈，在一圈结束前，如果遇到loop2，则为情况三，否则是情况二

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208192714952.png" alt="image-20230208192714952" style="zoom:50%;" />





<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230209002805008.png" alt="image-20230209002805008" style="zoom:80%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208193341796.png" alt="image-20230208193341796" style="zoom: 80%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208193303734.png" alt="image-20230208193303734" style="zoom:80%;" />

只要出现三次，按第一次出现的顺序就是先序，第二次是中序，第三次后序

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208232912693.png" alt="image-20230208232912693" style="zoom:50%;" />

先序：——X——，前部分A

后序：———X———，后部分B

A∩B就是X的祖先



<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230208235418863.png" alt="image-20230208235418863" style="zoom:50%;" />

解释：

1. 

除了X，X的祖先，X的孩子，剩下的可以分为两类：都是兄弟

- X作为左树的右兄弟们（圈圈都是）

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230209002056451.png" alt="image-20230209002056451" style="zoom:50%;" />

- X作为右树的左兄弟们

  <img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230209002216799.png" alt="image-20230209002216799" style="zoom:50%;" />



<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230209002342827.png" alt="image-20230209002342827" style="zoom:50%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230209002614404.png" alt="image-20230209002614404" style="zoom:50%;" />







<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230209002820397.png" alt="image-20230209002820397" style="zoom:80%;" />

用栈去实现非递归的二叉树先中后遍历

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230209002927568.png" alt="image-20230209002927568" style="zoom:50%;" />

头左右->头右左->左右头

用两个栈实现后序遍历

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209103145555.png" alt="image-20230209103144949" style="zoom:50%;" />

只用一个栈，实现后序遍历

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209104223949.png" alt="image-20230209104223949" style="zoom:50%;" />

整棵树都可以被左边界分解

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230209105206484.png" alt="image-20230209105206484" style="zoom:50%;" />