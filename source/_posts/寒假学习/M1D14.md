---
title: 归并排序
author: sin
date: 2023-01-14
categories: 寒假学习
summary: 归并排序
tags: 
  - 算法
---

第五节：

归并排序：O(N*logN)

每次调整步长，一共需要调整logN次，每次都merge，每次都是O(N)，所以总共是O(N*logN)

开始merge的时候，L到M有序，M+1到R有序

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230114203208759.png" alt="image-20230114203208759" style="zoom:50%;" />

必然有一方先越界，

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230114203844799.png" alt="image-20230114203844799" style="zoom: 67%;" />

迭代版——非递归，设置步长，就是左组/右组的长度

比如说步长=1时，就是2和3比较，步长=2时，就是1、2和3、4比较

凑不够一组时就跳过到下一个步长长度，直到步长超过数组长度停止

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230114212327687.png" alt="image-20230114212327687" style="zoom:50%;" />

L是左组的第一个下标位置，每次都是从第一个左组跳到下一个左组

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230114214348318.png" alt="image-20230114214348318" style="zoom:50%;" />



<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230114220131331.png" alt="image-20230114220131331" style="zoom:50%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230114220909813.png" alt="image-20230114220909813" style="zoom:67%;" />

防止溢出：当这个步长非常接近N，但是当步长*2之后溢出会变成负数。数N非常靠近整数最大值。

等于N/2时不能停

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230114220828296.png" alt="image-20230114220828296" style="zoom: 67%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230114220812180.png" alt="image-20230114220812180" style="zoom:50%;" />

问题一：小和问题

在数的左边比该数小的值累加，整体再累加和

左组小就产生小和，当拷贝右组数的时候，不考虑小和

包括右指针在内，比2小的数有1个



相等的时候，先拷贝右边的，这样才能清楚有几个比它大

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230115094216571.png" alt="image-20230115094216571" style="zoom: 80%;" />

题目二：

找数组中所有的逆序对：

x作为左组的时候才会产生逆序对

从右往左merge，相等的拷贝右边，然后谁大拷贝谁

题目三：

求数组中，num > num右边的数 * 2的个数

==单调性与回退==

```java
// [L...M]    [M+1...R]
int res = 0;

// 目前囊括进来的数，是从[M+1, windowR)
int windowR = M + 1;
for (int i = L; i <= M; i++) {
    while (windowR <= R && arr[i] > (arr[windowR] * 2)) {
        windowR++;
    }
}
```
