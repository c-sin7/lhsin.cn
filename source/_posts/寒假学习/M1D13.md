---
title: 链表和队列
author: sin
date: 2023-01-13
categories: 寒假学习
summary: 链表和队列
tags: 
  - 算法
---

第四节：

链表

栈和队列

栈和队列相互转换

1. 两个栈q和h——>队列：
2. 两个队列q和h——>栈：
   - LinkedList<>()可以当做队列
     - <img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230113222256946.png" alt="image-20230113222256946" style="zoom:67%;" />
   - push：直接push进队列q
     - <img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230113222234485.png" alt="image-20230113222234485" style="zoom:67%;" />
   - pop：
     - 只要长度 > 1，就把队列q的前n-1个弹出进队列h
     - 然后单独弹出第n个数
     - 再相互换两个队列的内存，也就是引用
     - <img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230113222044750.png" alt="image-20230113222044750" style="zoom: 67%;" />
   - peek：
     - 返回栈顶就是在pop的基础上，把弹出来改成offer压进去即可
     - <img src = "C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230113222333566.png" alt = "image-20230113222333566" style="zoom: 67%;" />



递归：

任何递归都可以改成非递归

递归逻辑图：

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230114101401006.png" alt="image-20230114101401006" style="zoom:50%;" />

master公式：针对递归函数且子规模一致情况下适用

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230114101636756.png" alt="image-20230114101636756" style="zoom:67%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230114110636529.png" alt="image-20230114110636529" style="zoom:67%;" />

Hashmap哈希表：增删改查默认是常数时间的O(1)，但是常数比较大

1. 存基础类型：有多少内存就开多少内存
2. 存自定义类型：仅仅只存内存地址，8字节

HashSet：只要key，不要Hashmap的value，即有伴随数据的是哈希表，没有伴随数据的是HashSet

String a和String b

a == b的话比较的是引用，

内容的比较采用a.equals(b)

在hashmap里面，只要是基础类型，如Integer、String，比较的都是值，就是比较内容



TreeMap 有序表是个接口名

红黑树、avl树、sb树、跳表都可以实现有序表，且它们的增删改查都能做到O(logN)，功能比哈希表强大，但时间复杂度没哈希表那么逆天O(1) 

有序表中，原生的Key是按值传递，有序表是不会存同样的key，但是按值传递的时候有序组织。

有序表比哈希表多的功能：

- 可以找最小key和最大key

```java
treeMap.firstKey();
treeMap.lastKey();
```

- 可以找离目标key最近的最小和最大key，包括目标key

```java
treeMap.floorKey(4);//<=4
treeMap.ceilingKey(4);//>=4
```

