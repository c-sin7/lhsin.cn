---
title: 哈希表
author: sin
date: 2023-01-30
categories: 寒假学习
summary: 哈希表
tags: 
  - 算法
---

hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在[哈希表](https://so.csdn.net/so/search?q=哈希表&spm=1001.2101.3001.7020)中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。





hashcode代表对象的地址说的是对象在hash表中的位置，物理地址说的对象存放在内存中的地址 。 通过对象的内部地址(也就是物理地址)转换成一个整数，然后该整数通过hash函数的算法就得到了hashcode 。



equals方法和hashcode的关系？

1、如果两个对象equals相等，那么这两个对象的HashCode一定也相同

2、如果两个对象的HashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，

存放于同一个位置。hashCode()只表示对象的哈希码，哈希码相同的对象不一定相等，反之，没有重写equals方法的前提下，两个对象相等，则hashCode一定相同



equals方法重写的话，建议也一起重写hashcode方法



### HashMap

HashMap 基于哈希表的 Map 接口实现，是以 key-value 存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的 key、value 都可以为 null，此外，HashMap 中的映射不是有序的。

jdk1.8 之前 HashMap 由 数组 + 链表 组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突（两个对象调用的 hashCode 方法计算的哈希值经哈希函数算出来的地址被别的元素占用）而存在的（“拉链法”解决冲突）。jdk1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（或者红黑树的边界值，默认为 8 ）并且当前数组的长度大于 64 时，此时此索引位置上的所有数据改为使用红黑树存储。

补充：将链表转换成红黑树前会判断，即便阈值大于 8，但是数组长度小于 64，此时并不会将链表变为红黑树，而是选择逬行数组扩容。

这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要逬行左旋，右旋，变色这些操作来保持平衡。同时数组长度小于64时，搜索时间相对要快些。所以结上所述为了提高性能和减少搜索时间，底层阈值大于8并且数组长度大于64时，链表才转换为红黑树，具体可以参考 treeifyBin() 方法。

当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于 8 并且数组长度大于 64 时，链表转换为红黑树时，效率也变的更高效



HashMap 特点：

    存储无序的。
    
    键和值位置都可以是 null，但是键位置只能存在一个 null。
    
    键位置是唯一的，是底层的数据结构控制的。
    
    jdk1.8 前数据结构是链表+数组，jdk1.8 之后是链表+数组+红黑树。
    
    阈值（边界值）> 8 并且数组长度大于 64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。
    
    默认的扩容方式：扩容为原来容量的 2 倍，并将原有的数据复制过来。


size 表示 HashMap 中键值对的实时数量，注意这个不等于数组的长度。
threshold（临界值）= capacity（容量）* loadFactor（负载因子）。这个值是当前已占用数组长度的最大值。size 超过这个值就重新 resize（扩容），扩容后的 HashMap 容量是之前容量的两倍。默认的临界值是**12 = 16 * 0.75**



面试题

1、HashMap 中 hash 函数是怎么实现的？还有哪些hash函数的实现方式？
答：对于 key 的 hashCode 做 hash 操作，无符号右移 16 位然后做异或运算。还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移 16 位异或运算效率是最高的。

2、当两个对象的 hashCode 相等时会怎么样？
答：会产生哈希碰撞。若 key 值内容相同则替换旧的 value，不然连接到链表后面，链表长度超过阈值 8 就转换为红黑树存储。

3、什么是哈希碰撞，如何解决哈希碰撞？
答：只要两个元素的 key 计算的哈希码值相同就会发生哈希碰撞。jdk8 之前使用链表解决哈希碰撞。jdk8之后使用链表 + 红黑树解决哈希碰撞。

4、如果两个键的 hashCode 相同，如何存储键值对？
答：通过 equals 比较内容是否相同。相同：则新的 value 覆盖之前的 value。不相同：则将新的键值对添加到哈希表中。



HashMap继承关系说明：

    Cloneable 空接口，表示可以克隆。创建并返回 HashMap 对象的一个副本。
    Serializable 序列化接口。属于标记性接口。HashMap 对象可以被序列化和反序列化。
    AbstractMap 父类提供了 Map 实现接口。以最大限度地减少实现此接口所需的工作。




<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230130111557966.png" alt="image-20230130111557966" style="zoom:67%;" />

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230130111317617.png" alt="image-20230130111317617" style="zoom:67%;" />



成员变量说明：

    loadFactor 是用来衡量 HashMap 满的程度，表示HashMap的疏密程度，影响 hash 操作到同一个数组位置的概率，计算 HashMap 的实时负载因子的方法为：size/capacity，而不是占用桶的数量去除以 capacity。capacity 是桶的数量，也就是 table 的长度 length。
    loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。
    当 HashMap 里面容纳的元素已经达到 HashMap 数组长度的 75% 时，表示 HashMap 太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。所以开发中尽量减少扩容的次数，可以通过创建 HashMap 集合对象时指定初始容量来尽量避免。
    在 HashMap 的构造器中可以定制 loadFactor。


为什么负载因子设置为0.75，初始化临界值是12？

loadFactor 越趋近于1，那么数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。

<img src="C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230130112026592.png" alt="image-20230130112026592" style="zoom:50%;" />