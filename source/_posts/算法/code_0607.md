---
title: code_0607
author: sin
date: 2023-06-07
categories: 算法
summary: 回文数
tags: 
  - 算法
  - java
  - 力扣
---

# code_0607

## 回文数

方法一：int->String

需要额外的非常量空间来创建问题描述中所不允许的字符串。

方法二：将数字本身反转
问题：

反转后的数字可能大于 int.MAX，整数溢出。

为避免数字反转可能导致的溢出问题，考虑只反转数字的一半

例如，输入 1221，可以将数字 “1221” 的后半部分从 “21” 反转为 “12”，并将其与前半部分 “12” 进行比较，二者相同，是回文。

算法：

首先，处理一些临界情况。

1. 所有负数都不可能是回文
2. 除了 0 以外，所有个位是 0 的数字不可能是回文

对于数字 1221，如果执行 1221 % 10，我们将得到最后一位数字 1，要得到倒数第二位数字，我们可以先通过除以 10 把最后一位数字从 1221 中移除，1221 / 10 = 122，再求出上一步结果除以 10 的余数，122 % 10 = 2，就可以得到倒数第二位数字。

如果我们把最后一位数字乘以 10，再加上倒数第二位数字，1 * 10 + 2 = 12，就得到了我们想要的反转后的数字。如果继续这个过程，我们将得到更多位数的反转数字。



问题是，如何知道反转数字的位数已经达到原始数字位数的一半？

由于整个过程不断将原始数字除以 10，然后给反转后的数字乘上 10，所以，当原始数字**小于或等于**反转后的数字时，意味着已经处理了一半位数的数字了。

```java
class Solution {
public:
    bool isPalindrome(int x) {
        // 特殊情况：
        // 如上所述，当 x < 0 时，x 不是回文数。
        // 同样地，如果数字的最后一位是 0，为了使该数字为回文，
        // 则其第一位数字也应该是 0
        // 只有 0 满足这一属性
        if (x < 0 || (x % 10 == 0 && x != 0)) {
            return false;
        }

        int revertedNumber = 0;
        while (x > revertedNumber) {
            revertedNumber = revertedNumber * 10 + x % 10;
            x /= 10;
        }
    
        // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。
        // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123，
        // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。
        return x == revertedNumber || x == revertedNumber / 10;
    }

};
```

复杂度分析

时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)。
空间复杂度：O(1)。我们只需要常数空间存放若干变量。



Java 中，可以使用 `Integer.toString(int i)` 方法将 `int` 类型的变量转换为 `String` 类型

Java中，可以使用 `String.valueOf(int i)` 方法将 `int` 类型的变量转换为 `String` 类型

Java 中，可以通过 `charAt(int index)` 方法获取字符串中某个位置上的字符

 Java 中，`equal` 方法用于判断两个字符串的内容是否相同，而 `==` 运算符用于判断两个字符串对象的引用是否相同。

 Java 中，可以使用 `StringBuilder` 和 `StringBuffer` 类的 `reverse()` 方法将字符串进行反转（即转置）。具体用法如下：

```java
String str = "hello world";
StringBuilder sb = new StringBuilder(str);
sb.reverse();
String reversedStr = sb.toString();
```





## 罗马数字->整数

方法一：从左往右，小数在大数左边，减法，否则加法

方法二：从右往左，记录当前遇到的最大的数字，遇到更大的就加，并且更新最大数，遇到小的就减

**复杂度分析**

- 时间复杂度：O(n)，其中 n 是字符串 s的长度。
- 空间复杂度：O(1)



## 老鼠和奶酪

https://leetcode.cn/problems/mice-and-cheese/

方法一：贪心 + 排序

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230608095852151.png" alt="image-20230608095852151" style="zoom:80%;" />



时间复杂度：O(nlog⁡n)，其中 n 是数组 reward1 和 reward2 的长度。创建数组 diffs 需要 O(n) 的时间，将数组 diffs 排序需要 O(nlog⁡n) 的时间，排序后计算 diffs 的 k 个最大值之和需要 O(k) 的时间，其中 k≤n，因此时间复杂度是 O(nlog⁡n)O(nlogn)。

空间复杂度：O(n)，其中 n 是数组 reward1 和 reward2 的长度。需要创建长度为 n 的数组 diffs 并排序，数组需要 O(n) 的空间，排序需要 O(log⁡n) 的递归调用栈空间，因此空间复杂度是 O(n)



：

数组排序Arrays.sort()需要时间为O(nlog⁡n) 