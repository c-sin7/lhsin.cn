---
title: code_0608
author: sin
date: 2023-06-08
categories: 算法
summary: 铺瓷砖、最长公共前缀
tags: 
  - 算法
  - java
  - 力扣
---

# code_0608

#### 一个int类型的数，提取出二进制中最右侧的1来 

```java
int rightestOne = eor & (-eor);
```

`-eor` 表示对 `eor` 取反后再加上 1，即得到 `eor` 的补码表示中最右侧的 1 所对应的值



#### 将i位置值设置为1

```java
int ans=0;
ans |= (1 << i);
```

这段代码的作用是将 `ans` 的第 `i` 位设置为 1，其它位不变。

具体地，`1 << i` 的值是二进制数 `0000...0001` 向左移动 `i` 位后得到的结果，即在第 `i` 位上是 1，其它位都是 0，

例如当 `i=3` 时，`1 << i` 的值为 `0000...1000`。然后使用或运算符 `|`，将 `ans` 的第 `i` 位设置为 1，而其它位则根据 `ans` 原先的值来保持不变。例如：

```java
int ans = 11; // 假设原来的 ans 值为 1011
int i = 1;    // 设置第 1 位为 1，即在第二位上设置为 1
ans |= (1 << i);
System.out.println(Integer.toBinaryString(ans)); // 打印输出 11011
```

在上述代码中，原来的 `ans` 值为 1011（十进制的 11），我们希望将它的第 2 位（从右往左数，即二进制数的第 2 位）设置为 1，即得到二进制数 11011（十进制的 27）。使用上述代码即可实现该目的，输出结果为 `11011`，与预期相符。



#### 使用双端队列实现栈有两种方式：

1. 在队列头部实现栈的 push 操作，即调用 `addFromHead` 方法插入元素，在队列头部调用 `popFromHead` 方法去除元素。
2. 在队列尾部实现栈的 push 操作，即调用 `addFromBottom` 方法插入元素，在队列尾部调用 `popFromBottom` 方法去除元素。



#### “打表”

可以理解为“预处理表格数据”，即将一些数据事先计算好并保存在数据结构中，以供程序运行时直接调用，而无需再进行计算。打表在某些场景下可以提高算法的效率和程序的运行速度，通常使用的数据结构有数组、哈希表、二维矩阵等。

例如，在计算斐波那契数列的时候，由于每个数的值都只跟前两个数的值有关，可以事先计算出数列中的所有数字并存在一个数组中，程序在需要时直接调用即可，这样可以避免重复计算，提高程序效率。这就是打表的一个常见应用。

另外，在算法竞赛中，打表也是一种常用的技巧，通过合理的打表可以大幅缩短算法的运行时间，从而在比赛中取得更好的成绩。



#### NP-Complete问题

是指一类非常重要的计算机科学问题，它表示了所有NP问题中最困难的一类问题之一，目前没有已知的有效算法可以在多项式时间内解决它们，即不存在可以在“多项式时间”内解决该问题的算法。

NP问题是指在多项式时间内可以验证一个解是否正确的问题，例如旅行商问题（TSP问题）和子集和问题（Subset Sum）就是NP问题，因为在多项式时间内可以验证某个解是否是正确的。而NP-Complete问题是一类特殊的NP问题，它具有这样的特性：如果有一种NP问题可以在多项式时间内转化成某个NP-Complete问题，那么这个NP问题就可以被认为是“和NP-Complete问题同样困难”的问题。





可视化数据网站：http://int-e.eu/~bf3/squares/view.html#13,11



<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230608200322152.png" alt="image-20230608200322152" style="zoom:80%;" />

![image-20230608200300117](https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230608200300117.png)