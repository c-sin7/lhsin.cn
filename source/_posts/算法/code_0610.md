---
title: code_0610
author: sin
date: 2023-06-10
categories: 算法
summary: 比较字符串最小字母出现频次
tags: 
  - 算法
  - java
  - 力扣
---

# code_0610

## 比较字符串最小字母出现频次

<img src="https://raw.githubusercontent.com/c-sin7/picgoIMG/main/image-20230611103348916.png" alt="image-20230611103348916" style="zoom:80%;" />

```java
class Solution {
    public int[] numSmallerByFrequency(String[] queries, String[] words) {
        int[] count = new int[12];
        for (String s : words) {
            count[f(s)]++;
        }
        for (int i = 9; i >= 1; i--) {
            count[i] += count[i + 1];
        }
        int[] res = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            String s = queries[i];
            res[i] = count[f(s) + 1];
        }
        return res;
    }

    public int f(String s) {
        int cnt = 0;
        char ch = 'z';
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c < ch) {
                ch = c;
                cnt = 1;
            } else if (c == ch) {
                cnt++;
            }
        }
        return cnt;
    }
}
```

复杂度分析

时间复杂度：O((n+m)p)，其中 n 是 queries 的长度，m 是 words 的长度，p 是 queries 和 words 中的最长字符串的长度。
空间复杂度：O(1)。不统计返回值所占用的空间，我们只使用到了常数个变量。



```java
ListNode dummy = new ListNode(0)
```

这行代码创建了一个新的 `ListNode` 对象 `dummy`，它的值为 0。

`ListNode` 通常用于创建单向链表和双向链表。在这个示例中，它创建了一个单向链表的头结点，值为 0。

在链表的构造过程中，可以使用一个虚拟的头结点，也就是 dummy 节点，来简化链表的处理过程。`dummy` 节点的 `next` 属性指向链表的第一个真实节点，这意味着不需要特殊处理链表头部。同时，还可以保持链表节点数据的一致性和避免代码重复。

这种方法在很多链表问题中都被广泛使用，适用于链表的插入、删除和查找等操作。由于 dummy 节点不占用数据空间，因此不会引入额外的空间复杂度，所以这种方法被认为是一种优雅的编程技巧。